We set out to establish a phase distinction between writing and
proving algorithms in the Coq environment. Concretely, this means
allowing to write algorithms as easily as in a practical functional programming language
whilst giving them as rich a specification as desired and proving that
the code meets the specification using the whole Coq proof
apparatus. 

This is achieved by extending conversion to an equivalence which relates types
and subsets based on them, a technique  
originating from the ``Predicate subtyping'' feature of PVS and
following mathematical convention. The typing judgments can be
translated to CCI by means of an interpretation which inserts
coercions at the appropriate places. These coercions can contain
existential variables representing the propositional parts of the final
term. We will present a prototype implementation of this process
which can be used in a variety of situations in the proof assistant.