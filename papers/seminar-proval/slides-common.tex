\usepackage[T1]{fontenc}
\usepackage{concrete}

\mode<all>
{
\setbeamerfont{block title}{size={}}
\usefonttheme{serif}
\usefonttheme{professionalfonts}
\setbeamercovered{invisible}
\useoutertheme[subsection=false]{smoothbars}
\useinnertheme[shadow=true]{rounded}
\usecolortheme{orchid}
\usecolortheme{whale}
\setbeamertemplate{navigation symbols}{}
\setbeamertemplate{mini frames}[box]
\setbeamertemplate{itemize items}[triangle]
\setbeamertemplate{enumerate items}[square]

}

\usepackage[latin1]{inputenc}
\usepackage{xspace} % To get the right spacings in front of : and so on
\usepackage[english]{babel}
\usepackage{abbrevs}
\usepackage{subfigure}
\usepackage{ifthen}
\usepackage{mycoqdoc}
\usepackage{bussproofs}
\usepackage{pgf}

\def\nat{`N}

% macro for typesetting keywords
\renewcommand{\coqdockw}[1]{\texttt{#1}}

\EnableBpAbbreviations
\def\fCenter{\vdash}
\def\seq{\fCenter}

\hypersetup{
  pdftitle = Programing in Coq,
  pdfauthor = Matthieu Sozeau,
  pdfsubject = Theoretical Computer Science
 } 


\input{grammar-macros}

\newboolean{defineTheoremEn}
\newboolean{defineTheoremFr}
\setboolean{defineTheoremEn}{true}
\setboolean{defineTheoremFr}{false}
\input{mathenv}
\setboolean{displayLabels}{true}

\input{typing-macros}
\def\infvspace{0.5cm}

\input{typing-decl}
\input{subtyping-decl}

\input{typing-algo}
\input{subtyping-algo}

\input{typing-impl}
\input{subtyping-impl}

\newqsymbol{"="}{\triangleq}

% [Short Paper Title] (optional, use only with long paper titles)
\title{\Program{}ing in \Coq}

\author[Matthieu Sozeau]
{{\sc Matthieu Sozeau} \\ under the direction of {\sc Christine Paulin-Mohring}}


\def\LRI{\name{LRI}}
\def\INRIAFuturs{\name{INRIA Futurs}}
\def\Proval{\name{Proval}}

\institute[]
{
  \LRI{}, Univ. Paris-Sud - \Demons{} Team \& \INRIAFuturs{} - \Proval{} Project
}

\date % (optional, should be abbreviation of conference name)
{Demons-Proval-Logical seminar \\
9 march 2007}

\subject{Theoretical Computer Science}

\pgfdeclareimage[height=0.5cm]{ups-logo}{../figures/ups-logo}
\pgfdeclareimage[height=0.5cm]{lri-logo}{../figures/lri-logo}
\pgfdeclareimage[height=0.5cm]{inria-logo}{../figures/inria-logo}

\def\imgheight{7.5cm}


\pgfdeclareimage[height=\imgheight]{bigpic1}{bigpic1}
\pgfdeclareimage[height=\imgheight]{bigpic2}{bigpic2}
\pgfdeclareimage[height=\imgheight]{bigpic3}{bigpic3}
\pgfdeclareimage[height=\imgheight]{bigpic4}{bigpic4}
\pgfdeclareimage[height=\imgheight]{bigpic5}{bigpic5}

\pgfdeclareimage[height=3cm]{lambda-cube}{../figures/lambda-cube}

\pgfdeclareimage[interpolate=true,height=8cm]{subtac-syntax}{capturesyntax}
\pgfdeclareimage[interpolate=true,height=8cm]{myhd-proof}{capturemyhd-proof}
\pgfdeclareimage[interpolate=true,height=8cm]{myhd-extract}{capturemyhd-extract}
\pgfdeclareimage[interpolate=true,height=8cm]{mytail-extract}{capturemytail-extract}
\pgfdeclareimage[interpolate=true,height=8cm]{mytest-good}{capturemytest-ok}
\pgfdeclareimage[interpolate=true,height=8cm]{mytest-good-extract}{capturemytest-ok-extract}
\pgfdeclareimage[interpolate=true,height=8cm]{mytest-bad}{capturemytest-bad}

\pgfdeclareimage[interpolate=true,height=8cm]{append-proof}{captureappend-proof}
\pgfdeclareimage[interpolate=true,height=8cm]{append-extract}{captureappend-extract}
\pgfdeclareimage[interpolate=true,height=8cm]{append-app}{captureappend-app}

\def\typea{\vdash}
\def\suba{\rightslice}

\newcommand{\indfig}{
  \begin{center}
    \AXC{$`G, {(\tele{x_i : X_i `~ y_i : Y_i})}_{0}^{j-1} \vdash ?_j : x_j :
      X_j `~ y_j : Y_j \quad `A j `: [0..i]$}
    \UIC{$`G \vdash c(\tele{?_i}) : I~\tele{x_i} \suba I~\tele{y_i} : s$}
    \DP    
  \end{center}
}   

\begin{document}

\begin{frame}[plain]
  \titlepage
  \vfill\hfill
  \pgfuseimage{ups-logo}
  \pgfuseimage{lri-logo}
  \pgfuseimage{inria-logo}
\end{frame}

% \begin{frame}[plain]
%   \frametitle{The Big Picture}
%   \only<1>{\pgfuseimage{bigpic1}}\only<2>{\pgfuseimage{bigpic2}}\only<3>{\pgfuseimage{bigpic3}}\only<4>{\pgfuseimage{bigpic4}}\only<5>{\pgfuseimage{bigpic5}}
% \end{frame}

\frame{\tableofcontents}

\section{The idea}

\subsection{A simple idea}
\begin{frame}
  \frametitle{A simple idea}
  
  \begin{block}{Definition}
    $\{ x : T `| P \}$ is the set of objects of set $T$ verifying property $P$. 
  \end{block}
  
  \begin{itemize}
  \item Useful for specifying, widely used in mathematics ;    
  \item Separates object and property.
  \end{itemize}
  \pause
  \begin{block}{Adapting the idea} 
    \begin{center}
      \BAX{}{$t : T$}
      {$P[t/x]$}
      {$t : \mysubset{x}{T}{P}$}
      {}\DP\quad      
      \UAX{}{$t : \mysubset{x}{T}{P}$}
      {$t : T$}
      {}
      \DP
    \end{center}
  \end{block}  
\end{frame}

\subsection{From \PVS to \Coq}
\begin{frame}
  \frametitle{From ``\ps''\ldots}
  
  \begin{block}{\PVS{}}
    \vspace{0.7em}
    \begin{itemize}
    \item Specialized typing algorithm for subset types, generating
      \emph{Type-checking conditions}.    
      \begin{tabular}{lcll}
        $t : \mysubset{x}{T}{P}$ & used as & $t : T$
        & ok \\
        $t : T$ & used as & $t : \mysubset{x}{T}{P}$ 
        & if $P[t/x]$
      \end{tabular}
      \pause
      
    \item[{\bf +}] Practical success ; \pause
    \item[{\bf --}] No strong safety guarantee in \PVS{}.
    \end{itemize}  
  \end{block}
%   \pause 
%   \begin{block}{\Coq{}}
%     Use coercions to explicit the equivalence:
%     \begin{tabular}{lclcl}
%       $t : \mysubset{x}{T}{P}$ & \only<4>{$"<=>"$} \only<5->{$"->"$} & $t : T$
%       & \only<5->{$"~>"$} & \only<5->{$\pi_1~t$ \\
%         $t : T$ & $"->"$ & $t : \mysubset{x}{T}{P}$ 
%         & $"~>"$ & $\sref{elt}~{t}~(\alert<3->{? : P[t/x]})$}
%     \end{tabular}
%   \end{block}
\end{frame}

\begin{frame}[t]
  \frametitle{\ldots to Subset coercions}
  
  \begin{enumerate}
  \item<1-> A property-irrelevant language (\lng{}) with \alert{decidable} typing ;
  \item<2-> A total traduction to \Coq{} terms with holes ;
  \item<3-> A method to turn the holes into proof obligations.
  \end{enumerate}
  
  \only<1-2>{
  \begin{center}
    \UAX{}{$`G \typea t : \mysubset{x}{T}{P}$}
    {$`G \typea \uncover<2>{\eltpit~}t : T$}
    {}\DP

    \vspace{0.5cm}
    \BAX{}{$`G \typea t : T$}
    {$`G, x : T \type P : \Prop$}
    {$`G \type \uncover<2>{(}t\uncover<2>{, ?)} : \mysubset{x}{T}{P}$}
    {\uncover<2>{$`G \type ? : P[t/x]$}}\DP
  \end{center}
  }

%   \begin{center}
%   \begin{tabular}{lclcl}
%     $t : \mysubset{x}{T}{P}$ & \only<1>{$"<=>"$} \only<2->{$"->"$} & $t : T$
%     & \only<2->{$"~>"$} & \only<2->{$\pi_1~t$ \\
%       $t : T$ & $"->"$ & $t : \mysubset{x}{T}{P}$ 
%       & $"~>"$ & $\sref{elt}~{t}~(\alert<3->{? : P[t/x]})$}
%   \end{tabular}
% \end{center}

\end{frame}

\section{Theoretical development}
\frame{\tableofcontents[currentsection]}

\subsection{\lng{}}

\begin{frame}
  \frametitle{\lng{} syntax}
  
  $\begin{array}{lcl}
    x & `: & \mathcal{V} \\
    \\
    s, t, u, v & \Coloneqq & x \\
    & | & \Set \\
    & | & \Prop \\
    & | & \Type \\
\pause
    & | & \lambda x : s. t \\
    & | & s~t \\
    & | & \Pi x : s. t \\
\pause
    & | & \pair{\Sigma x : s.t}{u}{v} \\
    & | & \pi_1~s `| \pi_2~s \\
    & | & \Sigma x : s. t \\
\pause
    & | & \mysubset{x}{s}{t} 
  \end{array}$  
\end{frame}

\begin{frame}[t,label=typingdecl]
  \frametitle{\lng{} typing $\typed$ and coercion $\subd$}
  
  Calculus of Constructions with
  \typenvd
  \setboolean{displayLabels}{false}
  \begin{center}
    \vspace{0.25cm}
    \only<1>{\Conv\DP}
    \only<2->{\Coerce\DP
      \def\fCenter{\subd}
      \SubConv\DP}
    \uncover<3->{
    \vspace{0.5cm}    
    \SubTrans\DP
    
    \vspace{0.25cm}
    \only<4->{\SubSub\DP
      \vspace{0.25cm}
    \SubProof\DP}

    \vspace{0.25cm}
    \only<5-6>{
      \AXC{$`G \type 0 : \nat$}
      \AXC{$`G \type \nat~\sub \mysubset{x}{\nat}{x \neq 0} : \Set$}
      \BIC{$`G \type 0 : \mysubset{x}{\nat}{x \neq 0}$}
      \only<6>{\UIC{$`G \type \alert{? : 0 \neq 0}$}}
      \DP
    }
    \only<7->{\SubProd\DP}}
  % \SubSigma\DP}
  \end{center}

\end{frame}

\begin{frame}
  \frametitle{Results}

  \begin{theorem}[Decidability of type checking and type inference]
    $`G \type t : T$ is decidable. 
  \end{theorem}  
  
  \uncover<2->{
    \begin{lemma}[Elimination of transitivity]
      If $T \sub U `^ U \sub V$ then $T \sub V$.
    \end{lemma}

  \begin{theorem}[Subject Reduction]
    If $`G \type t : T$ and $t "->"_{\beta\pi} t'$ then $`G \type t' : T$.
  \end{theorem}}
  
  \begin{prooftree}
    \TAX{App}
    {$\tgen{`G}{f}{T} \quad \subgen{`G}{T}{\Pi x : A.B}{s}$}
    {$\tgen{`G}{e}{E}$}
    {$\subgen{`G}{E}{A}{s'}$}
    {$\tgen{`G}{(f~e)}{B [ e / x ]}$}
    {}
  \end{prooftree}
  
\end{frame}

\def\typec{\vdash_{?}}
\renewcommand{\subimpl}[4]{#1 \typec #2 : #3 \sub #4}

\newcommand{\blue}[1]{{\color{blue}#1}}

\subsection{Traduction in \Coq{}}
\frame{\tableofcontents[currentsubsection]}

\setboolean{displayLabels}{false}
\begin{frame}
  \frametitle{The target system}
  
  \begin{block}{\CIC{} with metavariables}
    \begin{center}
      \BAX{}{$`G \typec t : T$}
      {$`G \typec p : P[t/x]$}
      {$`G \typec \elt{T}{P}{t}{p} : \mysubset{x}{T}{P}$}
      {}\DP
      
      \vspace{0.25cm}
      \UAX{}{$`G \typec t : \mysubset{x}{T}{P}$}
      {$`G \typec \eltpit~t : T$}
      {}
      \DP
      \quad
      \UAX{}{$`G \typec t : \mysubset{x}{T}{P}$}
      {$`G \typec \eltpip~t : P[\eltpit~t/x]$}
      {}
      \DP

      \vspace{0.25cm}
      \UAX{}
      {$`G \typec P : \Prop$}
      {$`G \typec ?_{P} : P$}
      {}\DP
    \end{center}
  \end{block}
    
\end{frame}
\begin{frame}
  \frametitle{From \lng{} to \Coq}
%   \frametitle{From \Coq to \lng{}\only<2->{ and back}}
%   \begin{block}{The easy way}
%     \begin{center}
%       $\begin{array}{lcl}
%         (\eltpit~t)^{\circ} & = & t^{\circ} \\
%         (\elt{T}{P}{t}{p})^{\circ} & = & t^{\circ} \\
%         (\eltpip~t)^{\circ} & = & `_ \\
%         (?_P)^{\circ} & = & `_
%       \end{array}$
%     \end{center}

%     If $`G \typec t : T$ then $`G^{\circ} \typea t^{\circ} : T^{\circ}$ if $()^\circ$ is
%     defined on $`G, t, T$.
%   \end{block}
  
  \begin{block}{The interpretation $\ip{\_}{`G}$ }
    We build an interpretation from \Russell to \CICq terms, following 
    the \Russell typing derivation, which puts metavariables where proofs are missing.
  \end{block}
  
  \begin{block}{Our goal}
    \begin{center}
      If $`G \type t : T$ then $\ipG{`G} \typec \ip{t}{`G} : \ip{T}{`G}$.
    \end{center}
  \end{block}
\end{frame}

\begin{frame}[t]
  \frametitle{Deriving explicit coercions}
      
  \begin{block}{Interpretation of coercions}
    \begin{center}
      If $\subgen{`G}{T}{U}{s}$ then $`G \typec c[\ctxdot] : T \sub U$ which implies
      $\ipG{`G}, x : \ip{T}{`G} \typec \blue{c}[x] : \ip{U}{`G}$.
    \end{center}
  \end{block}
  
  \uncover<2->{
    \begin{definition}
      \begin{center}
        \def\fCenter{\sub}    
        \UAX{SubConv}
        {$T \eqbr U$}
        {$\subimpl{`G}{\uncover<3->{\blue{\ctxdot}}}{T}{U}$}
        {}\DP
        
        \vspace{0.25cm}
        \uncover<4->{$\subimpl{`G}{\uncover<5->{\blue{\eltpit~\ctxdot}}}{\mysubset{x}{T}{P}}{T}$}
        
        \vspace{0.25cm}
        \uncover<6->{
          {$\subimpl{`G}
            {\uncover<7->{\blue{\elt{\_}{\_}{\ctxdot}
                {\ex{\ip{P}{`G, x : T}[\ctxdot/x]}}}}}
            {T}{\mysubset{x}{T}{P}}$}}
      \end{center}
    \end{definition}
  
    \uncover<8->{
      \begin{example}      
        \begin{prooftree}
          \AXC{$`G \typec 0 : \nat$}
          \AXC{$`G \typec \elt{\_}{\_}{\ctxdot}{?_{(x \neq 0)[\ctxdot/x]}} : \nat \sub \mysubset{x}{\nat}{x \neq 0}$}
          \BIC{$`G \typec (\elt{\_}{\_}{\ctxdot}{?_{(x \neq 0)[\ctxdot/x]}})[0]
            = \elt{\_}{\_}{0}{?_{\alert{0 \neq 0}}} : \mysubset{x}{\nat}{x \neq 0}$}
        \end{prooftree}
      \end{example}}
  }
\end{frame}

\begin{frame}
  \frametitle{Interpretation of terms}
    
  \begin{example}[Application]
    \setboolean{displayLabels}{false}
    \typenva
    \begin{center}
      \TAX{App}
      {$\tgen{`G}{f}{T} \quad \subgen{`G}{T}{\Pi x : V. W}{s}$}
      {$\tgen{`G}{u}{U}$} % \quad \tgen{#1}{#9, #5}{#7'}$}
      {$\subgen{`G}{U}{V}{s'}$}
      {$\tgen{`G}{(f~u)}{W[u/x]}$}
      {}
      \DP
    \end{center}
    
    \typenvi
    \[\begin{array}{lcll}
      \ip{f~u}{`G} 
      & = & \letml~\pi = \coerce{`G}{T}{(\Pi x : V.W)}~\inml & \\
      & & \letml~c = \coerce{`G}{U}{V}~\inml & \\
      & & (\pi[\ip{f}{`G}])~(c[\ip{u}{`G}]) & \\
    \end{array}\]    
  \end{example}
  \begin{theorem}[Soundness]
    If $`G \typea t : T$ then $\ipG{`G} \typec \ip{t}{`G} : \ip{T}{`G}$.
  \end{theorem}
\end{frame}


\begin{frame}
  \frametitle{Theoretical matters \dots}
  
  $\typec$'s equational theory:
  \[\begin{array}{llcll}
    (\beta) & (\lambda x : X.e)~v & `= & e[v/x] & \\
    (\pi_i) & \pi_i~\pair{T}{e_1}{e_2} & `= & e_i & \\
    (\sigma_i) & \sigma_i~(\elt{E}{P}{e_1}{e_2}) & `= & e_i & \\
    (\eta) & (\lambda x : X.e~x) & `= & e & \text{if $x `; FV(e)$} \\ % et $e : \Pi x : X.Y$} \\
    (\text{\SP}) % & \pair{\Sigma x : X.Y}{\pi_1~e}{\pi_2~e} & `= & e & \\ % \text{if $e : \Sigma x : X. Y$} \\
    & \elt{E}{P}{(\eltpit~e)}{(\eltpip~e)} & `= & e & \\%\text{if $e : \mysubset{x}{E}{P}$} \\
    \uncover<2->{\alert{(\sigma)} & \elt{E}{P}{t}{p} & `= & \elt{E}{P}{t'}{p'} & \text{if $t
        `= t'$}}
  \end{array}\]

  \uncover<2->{$"=>"$ \alert{Proof Irrelevance}}

  \uncover<3->{
  \begin{block}{\dots have practical effects}
    Difficulty to reason on code: $f (\elt{T}{P}{x}{p_1}) \not`= f (\elt{T}{P}{x}{p_2})$.
  \end{block}}
\end{frame}

\subsection{Inductive types}

\def\vector#1{\texttt{vector}~#1}

\begin{frame}
  \frametitle{Pattern-matching}

  \[ \begin{array}{lcl}
    \matchml~\uncover<2->{\mu{}(}v\uncover<2->{)~\asml~t} & \returnml & \uncover<2->{t = \mu{(v)} "->"} T~\withml \\
    `| p_1 & "=>" & \uncover<2->{\funml{}~h : p_1 = \mu{(v)} "=>"} t_1 \\
    & \vdots{} & \\
    `| p_n & "=>" & \uncover<2->{\funml{}~h : p_n = \mu{(v)} "=>"} t_n \\
    \enml & & \\
    \uncover<2->{(\sref{refl\_equal}~\mu{(v)})} & &
  \end{array}\]

\end{frame}

\begin{frame}
  \frametitle{Coercing Dependent Inductives}

  \begin{block}{A natural extension: Reindexing}
    Let $I~\tele{x}$ be an inductive type with \emph{real} arguments
    $\tele{x}$.
    We can coerce any object of this type to an object of
    $I~\tele{y}$ provided $\tele{x} ~= \tele{y}$.
  \end{block}
  
  \cover<1->{
  \indfig}
  \pause

  \begin{center}
    \begin{prooftree}
      \AXC{$`G \typec v : \vector{(m + 0)}$}
      \AXC{$`G \typec \vector{(m + 0)} \suba \vector{m} : \Set$}
      \BIC{$`G \typec v : \vector{m}$}
    \end{prooftree}
  \end{center}
\end{frame}



\section{\Program}
\begin{frame}<beamer>
  \frametitle{Outline}
  \tableofcontents[currentsection]
\end{frame}

\subsection{Architecture}
\begin{frame}[t]
  \frametitle{The \Program vernacular}
  
  \begin{block}{Architecture}
    Wrap around \Coq{}'s vernacular commands (\texttt{Definition},
    \texttt{Fixpoint}, \texttt{Lemma}, \ldots).
    
    \begin{enumerate}
    \item<2-> Use the \Coq{} parser.
    \item<3-> Typecheck $`G^{\circ} \type t : T$ and generate
      $\ipG{`G^{\circ}} \typec \ip{t}{`G^{\circ}} : \ip{T}{`G^{\circ}}$ ;
    \item<4-> Interactive proving of obligations ;
    \item<5-> Final definition.
    \end{enumerate}
  \end{block}
  
  \only<2->{
    \[\uncover<2-4>{\texttt{Program}~}\texttt{Definition}~f~:
    \uncover<3->{\llbracket} T \uncover<3->{\rrbracket_{`G^{\circ}}} := 
    \uncover<3->{\llbracket} t
    \uncover<3->{\rrbracket_{`G^{\circ}}}\uncover<4->{ + \text{ obligations}}.\]    
    \uncover<6->{
      \begin{remark}[Restriction]
        We assume $`G^{\circ} = `G$ and $`G \typecci \ip{T}{`G} : s$.
      \end{remark}}}
  
\end{frame}

\subsection{Hello world}
\begin{frame}
  \frametitle{Hello world: Euclidian division}

  \noindent
  \coqdockw{Program Definition} \coqdocid{lt\_ge\_dec} (\coqdocid{x}
  \coqdocid{y} : \coqdocid{nat}) : \coqdoceol
  \coqdocindent{1.00em}
  \{ \coqdocid{x} < \coqdocid{y} \} + \{ \coqdocid{x} \ensuremath{\geq} \coqdocid{y}\} :=\coqdoceol
  \coqdocindent{1.00em}
  \coqdockw{if} \coqdocid{le\_lt\_dec} \coqdocid{y} \coqdocid{x} \coqdockw{then} \coqdocid{right} \coqdockw{else} \coqdocid{left}.\coqdoceol
  
  \medskip\noindent
  \coqdocid{Extraction} \coqdocid{Inline} \coqdocid{lt\_ge\_dec}.\coqdoceol
  
  \medskip\noindent
  \coqdockw{Notation} " \coqdocid{x} < \coqdocid{y} " := (\coqdocid{lt\_ge\_dec} \coqdocid{x} \coqdocid{y}) : \coqdocid{program\_scope}.\coqdoceol
  
  \coqdockw{Program Fixpoint} \coqdocid{div} (\coqdocid{a} : \coqdocid{nat}) (\coqdocid{b} : \coqdocid{nat} \coqor  \coqdocid{b} \ensuremath{\not=} 0) \{ \coqdocid{wf} \coqdocid{lt} \} :\coqdoceol
  \coqdocindent{1.00em}
  \{ \coqdocid{qr} : \coqdocid{nat} \ensuremath{\times} \coqdocid{nat} \coqor  \coqdockw{let} (\coqdocid{q}, \coqdocid{r}) := \coqdocid{qr} \coqdockw{in} \coqdocid{a} = \coqdocid{b} \ensuremath{\times} \coqdocid{q} + \coqdocid{r} \} :=\coqdoceol
  \coqdocindent{1.00em}
  \coqdockw{if} \coqdocid{a} < \coqdocid{b} \coqdockw{then} (\coqdocid{O}, \coqdocid{a})\coqdoceol
  \coqdocindent{1.00em}
  \coqdockw{else} \coqdockw{dest} \coqdocid{div} (\coqdocid{a} - \coqdocid{b}) \coqdocid{b} \coqdockw{as} (\coqdocid{q'}, \coqdocid{r}) \coqdockw{in} (\coqdocid{S} \coqdocid{q'}, \coqdocid{r}).\coqdoceol

  \pause
  \medskip
  \noindent
  \coqdockw{Solve} \coqdockw{Obligations} \coqdockw{using} \coqdocid{subtac\_simpl} ; \coqdocid{auto} ; \coqdocid{omega}.\coqdoceol

  \pause
  \medskip
  \noindent
  \coqdockw{Extraction} \coqdocid{div}.\coqdoceol
  
  


\end{frame}


% \subsection{Safe lists}
% \begin{frame}[t]
%   \frametitle{\Program: The list example}
%   \vspace{-0.75em}
%   \begin{center}%
%     \only<1>{\pgfuseimage{subtac-syntax}}%
%     \only<2>{\pgfuseimage{myhd-proof}}%
%     \only<3>{\pgfuseimage{myhd-extract}}%
%     \only<4>{\pgfuseimage{mytail-extract}}%
%     \only<5>{\pgfuseimage{mytest-good}}%
%     \only<6>{\pgfuseimage{mytest-bad}}%
%     \only<7>{\pgfuseimage{append-proof}}%
%     \only<8>{\pgfuseimage{append-extract}}%
%     \only<9>{\pgfuseimage{append-app}}%
%   \end{center}
% \end{frame}

\subsection{Finger Trees}
\begin{frame}[t]
  \frametitle{Digits}
  \scriptsize{
  \coqdockw{Section} \coqdocid{Digit}.\coqdoceol
\coqdocindent{1.00em}
\coqdockw{Variable} \coqdocid{A} : \coqdockw{Type}.\coqdoceol


\medskip

\coqdocindent{1.00em}
\coqdockw{Inductive} \coqdocid{digit} : \coqdockw{Type} := \coqdoceol
\coqdocindent{1.00em}
\coqor  \coqdocid{One} : \coqdocid{A} \ensuremath{\to} \coqdocid{digit}\coqdoceol
\coqdocindent{1.00em}
\coqor  \coqdocid{Two} : \coqdocid{A} \ensuremath{\to} \coqdocid{A} \ensuremath{\to} \coqdocid{digit}\coqdoceol
\coqdocindent{1.00em}
\coqor  \coqdocid{Three} : \coqdocid{A} \ensuremath{\to} \coqdocid{A} \ensuremath{\to} \coqdocid{A} \ensuremath{\to} \coqdocid{digit}\coqdoceol
\coqdocindent{1.00em}
\coqor  \coqdocid{Four} : \coqdocid{A} \ensuremath{\to} \coqdocid{A} \ensuremath{\to} \coqdocid{A} \ensuremath{\to} \coqdocid{A} \ensuremath{\to} \coqdocid{digit}.\coqdoceol

\medskip

\coqdocindent{1.00em}
\coqdockw{Definition} \coqdocid{full} \coqdocid{x} := \coqdockw{match} \coqdocid{x} \coqdockw{with} \coqdocid{Four} \coqdocid{\_} \coqdocid{\_} \coqdocid{\_} \coqdocid{\_} \ensuremath{\Rightarrow} \coqdocid{True} \coqor  \coqdocid{\_} \ensuremath{\Rightarrow} \coqdocid{False}  \coqdockw{end}.\coqdoceol
% \coqdocindent{1.00em}
% \coqdockw{Definition} \coqdocid{single} (\coqdocid{x} : \coqdocid{digit}) := \coqdockw{match} \coqdocid{x} \coqdockw{with} \coqdocid{One} \coqdocid{\_} \ensuremath{\Rightarrow} \coqdocid{True} \coqor  \coqdocid{\_} \ensuremath{\Rightarrow} \coqdocid{False} \coqdockw{end}.\coqdoceol
\pause

\medskip
\coqdocindent{1.00em}
\coqdockw{Program Definition} \coqdocid{add\_digit\_left} (\coqdocid{a} : \coqdocid{A}) (\coqdocid{d} : \coqdocid{digit} \coqor  \ensuremath{\lnot} \coqdocid{full} \coqdocid{d}) : \coqdocid{digit} :=\coqdoceol
\coqdocindent{2.00em}
\coqdockw{match} \coqdocid{d} \coqdockw{with}\coqdoceol
\coqdocindent{3.00em}
\coqor  \coqdocid{One} \coqdocid{x} \ensuremath{\Rightarrow} \coqdocid{Two} \coqdocid{a} \coqdocid{x}\coqdoceol
\coqdocindent{3.00em}
\coqor  \coqdocid{Two} \coqdocid{x} \coqdocid{y} \ensuremath{\Rightarrow} \coqdocid{Three} \coqdocid{a} \coqdocid{x} \coqdocid{y}\coqdoceol
\coqdocindent{3.00em}
\coqor  \coqdocid{Three} \coqdocid{x} \coqdocid{y} \coqdocid{z} \ensuremath{\Rightarrow} \coqdocid{Four} \coqdocid{a} \coqdocid{x} \coqdocid{y} \coqdocid{z}\coqdoceol
\coqdocindent{3.00em}
\coqor  \coqdocid{Four} \coqdocid{\_} \coqdocid{\_} \coqdocid{\_} \coqdocid{\_} \ensuremath{\Rightarrow} !\coqdoceol
\coqdocindent{2.00em}
\coqdockw{end}.\coqdoceol
\coqdocindent{1.00em}
\coqdockw{Next} \coqdockw{Obligation}.\coqdoceol
\noindent
\coqdocindent{2.00em}
\coqdocid{intros} ; \coqdocid{simpl} \coqdockw{in} \coqdocid{n} ; \coqdocid{auto}.\coqdoceol
\noindent
\coqdocindent{1.00em}
\coqdockw{Qed}.\coqdoceol

}


\end{frame}

\begin{frame}[t]
  \frametitle{Nodes}
\end{frame}

\begin{frame}[t]
  \frametitle{Dependent Finger Trees}
\end{frame}

\section{Conclusion}
\begin{frame}
  \frametitle{Conclusion}
  
  \begin{block}{Our contribution}
    A more \alert{flexible} programming language, (almost) \alert{conservative} over
    \CIC, \alert{integrated} with the existing environment and a formal \alert{justification} of ``\ps{}''.
  \end{block}
  \pause
  \begin{block}{Future work}
    \vspace{0.2em}
    \begin{itemize}
    \item Application to more constructs ((co-)inductive types) and commands.
    \item Improvements of \Coq{} (existential variables, type inference,
      proof irrelevance).
    \item Complete and useful interpretation of \ML{} languages.
    \end{itemize}
  \end{block}
  
\end{frame}

\begin{frame}[t]
  \frametitle{Addendum: some practical enhancements}
  
  \begin{itemize}
  \item Handling of dependent existential variables (WIP).
  \item<2-> Pattern-matching and equalities.
  \item<3-> Well-founded recursion.
  \end{itemize}

  \only<2>{
    \[\matchml~v~\returnml~T~\withml~p_1 "=>" t_1 \cdots{} p_n "=>" t_n \]
    \[\begin{array}{lcl}
      (\matchml~\mu{v}~\asml~t' & \returnml & t' = \mu{(v)} "->" T)~\withml \\
      p_1 "=>" \funml{}~h & "=>" & t_1 \\
      & \vdots{} & \\
      p_n "=>" \funml{}~h & "=>" & t_n) \\
      (\sref{refl\_equal}~\mu{(v)}) & &
    \end{array}
    \]
  }

  \only<3->{
    \[ \texttt{Program}~\Fixpoint~f~(a : nat)~\{ \mlkw{wf}~lt~a \} : \nat := t \]
  }
  \only<4->{
    \[\begin{array}{lcl}
      a & : & \nat \\
      f & : & \{ x : \nat `| x < a \} "->" \nat \\
      \hline
      t & : & \nat
    \end{array}\]
  }

\end{frame}

\subsection*{}
\begin{frame}
  \frametitle{Why eta rules and proof irrelevance ?}
  
  Let $A,B : \Type$, $c : A \suba B$, $d : B \suba A$. 
  \pause
  
  Let $P : A "->" \Prop$ with $p : \Pi x : A, P~x$ and $q : \Pi x : B,
  P~x$.
  
  \pause
  Consider: $p~x =_{(P~x)} q~x$ in context $`G "=" x : A$. 
  
  By $\ip{\_}{`G}$: $\ip{P}{`G} "=" P$, $\ip{p}{`G} "=" p$ and
  $\ip{q}{`G} "=" q : \alert{\Pi x : B, P~d[x]}$, \pause 
  
  hence: $\ip{p~x =_{(P~x)} q~x}{`G} "=" p~x =_{(P~x)} \alert{q~c[x]}$.

  We have $p~x : P~x$ but $q~c[x] : P~d[c[x]]$, so $x `= d[c[x]]$ is
  necessary.
  This means eta rules for all constructs are needed.
  \pause
  
  Now: $c "=" \elt{A}{P}{\cdot}{?_{P[\cdot/x]}} : A \suba
  \mysubset{x}{A}{P}$ and $d "=" \eltpit{\cdot} : \mysubset{x}{A}{P}
  \suba A$, so $d[c[x]] "=" x$ but what about $c[d[x]]$ ? 
  \pause

  $c[d[x]] "=" \elt{A}{P}{(\eltpit~x)}{?_{P[\eltpit x/x]}} \alert{\not`=}
  x$ except if PI is included in $`=$.
  
\end{frame}

\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "slides"
%%% LaTeX-command: "x=pdf; TEXINPUTS=\"~/research/publication/styles:..:../style:../figures:\" ${pdfx}latex"
%%% TeX-PDF-mode: t
%%% End: 
