\section{Élaboration du système algorithmique et propriétés}
\typenva

Pour pouvoir implanter le typeur, il nous faut un système dirigé par la
syntaxe. Ce n'est pas le cas du système déclaratif, aussi bien pour le
typage que pour la coercion. On va donc raffiner ces systèmes dans
l'optique d'en extraire un algorithme. On note $\typea$ le jugement de
typage algorithmique défini figure \ref{fig:typing-algo-rules} page
\pageref{fig:typing-algo-rules} et
$\suba$ le jugement de coercion algorithmique présenté figure
\ref{fig:subtyping-algo-rules}. Ces deux systèmes sont quelque peu
éloignés des originaux, néanmoins nous allons montrer qu'ils sont
corrects et complets vis-à-vis de leurs géniteurs. La correction (si l'on
a une dérivation d'un jugement dans le système algorithmique, alors
c'est un jugement valide du système déclaratif) est le
sens le plus facile à montrer, nous allons donc commencer par là. On
décrira ensuite la méthode de construction des systèmes algorithmiques
pour aboutir d'une part au théorème de complétude qui montre qu'on peut dériver les
mêmes jugements (à coercion près) dans le système algorithmique que dans
le sytème déclaratif et d'autre part à la décidabilité du jugement de
typage algorithmique.

Il nous a fallu changer quelque peu les règles pour obtenir le système
algorithmique. En particulier, on a utilisé la fonction $\mu_0$ de \PVS{}
\cite{PVS-Semantics:TR} renommée $\mualgo{}$ (figure \ref{fig:mualgo-definition})
ici pour opérer des
\emph{décompréhensions}. Cette fonction efface les constructeurs de type
sous-ensemble en tête d'un type, par exemple: $\mualgo{\mysubset{f}{\nat
"->" \nat}{f~0 = 0}} = \nat "->" \nat$. On verra son utilité dans la suite.

\subsection{Notations}
On note $\hnf{x}$ la mise en forme normale de tête de $x$ selon la
réduction définie précédemment. On note $\eqdef$ l'égalité
définitionelle. On omet le contexte pour le jugement de coercion
lorsqu'il est dérivable du contexte.

\setboolean{displayLabels}{true}
\typenva
\typeaFig
\typemuaFig
\subtaFig

Voici quelques propriétés élémentaires du système:

\begin{lemma}[Bonne formation des contextes]
  \label{wf-contexts-a}
  Si $`G \type t : T$ alors $\typewf `G$.
\end{lemma}
\begin{proof}
  \inductionon{typing-decl}
\end{proof}

\begin{fact}[Inversion du jugement de bonne formation]
  \label{inversion-wf-a}
  Si $\typewf `G, x : U$ alors il existe $s$, $`G \type U : s$ et $s `: \setproptype$.
\end{fact}

\begin{lemma}[Affaiblissement]
  \label{weakening-a}
  Si $`G, `D \type t : T$ alors pour tout $x : S `; `G, `D$ tel que
  $\wf `G, x : S, `D$ on a $`G, x : S, `D \type t : T$
\end{lemma}

\begin{proof}
  \begin{induction}[typing-decl]
    \case{PropSet} Trivial.

    \case{Var}
    On a $x : S `; `G, `D$, donc $`G, x : S, `D \type y : T$ est toujours dérivable.
    
    \case{Prod}
    Par induction $`G, x : S, `D \type T : s1$ et $`G, x : S, `D,
    y : T \type U : s2$. On applique \irule{Prod} pour obtenir 
    $`G, x : S, `D \type \Pi x : T.U : s2$. De même pour le reste des règles.
  \end{induction}
\end{proof}  


\subsection{Correction}
On montre tout d'abord la correction de la coercion algorithmique qui
sera nécessaire pour la correction du typage:

\begin{theorem}[Correction de la coercion]
  \label{correct-coercion}
  Si $\subalgo{`G}{U}{V}$ alors $U \subd V$.
\end{theorem}

\begin{proof}
  Les règles du système algorithmique sont un sous-ensemble des règles
  du système décla\-ratif, excepté pour la règle \irule{SubHnf}.
  On utilise \irule{SubConv} et \irule{SubTrans} pour montrer son
  admissibilité dans dans le système déclaratif.
  \begin{prooftree}
    \AXC{$U \eqbr \hnf{U}$}  
    \UIC{$U~\subd \hnf{U}$}
    \AXC{$\hnf{U}~\subd \hnf{T}$}
    \AXC{$\hnf{T} \eqbr T$}
    \UIC{$\hnf{T}~\subd T$}
    \BIC{$\hnf{U}~\subd T$}
    \BIC{$U \subd T$}
  \end{prooftree}
\end{proof}

On a besoin d'un lemme sur l'opération $\mualgo{}$ définie figure
\ref{fig:mualgo-definition}.

\begin{lemma}[$\mualgo{}$ et coercion]
  \label{mu-coercion}
  Si $\talgo{`G}{T}{s}$ alors $\subalgo{`G}{T}{\mualgo{T}}$.
\end{lemma}

\begin{proof}
  Il suffit de suivre la définition de $\mualgo{}$. La mise en forme
  normale de tête est équivalente à l'utilisation de \irule{SubHnf} dans notre jugement de
  coercion. $\mualgo{}$ est en fait l'application répétée de la règle \irule{SubSub}.
\end{proof}

\begin{lemma}[Conservation des sortes par $\mualgo{}$]
  \label{mu-sorts}
  Si $\talgo{`G}{S}{s}$ alors $\talgo{`G}{\mualgo{S}}{s}$
\end{lemma}

\begin{proof}
  Par le simple fait que si $S = \mysubset{x}{U}{P}$ et
  $\talgo{G}{S}{s}$ alors $S : \Set$ et $U : \Set$ (par \irule{Subset}), sinon $S = \mualgo{S}$.
\end{proof}

\begin{theorem}[Correction du typage]
  \label{correct-typing}
  Si $\talgo{`G}{t}{T}$ alors $\tdecl{`G}{t}{T}$
\end{theorem}

\setboolean{displayLabels}{false}
\begin{proof}
  \begin{induction}[typing-algo]
    \caseother{\irule{WfEmpty},\irule{WfVar},\irule{PropSet},\irule{Var},\irule{Prod},\irule{Abs},
      \irule{Sigma}, \irule{Sum}} règles inchangées.
       
    \case{App} On a
    \def\fCenter{\typea}
    \begin{prooftree}
      \AppA
    \end{prooftree}
    
    Par induction, $`G \typed f : T$, et $T \subd \Pi x : V. W$ par le
    lemme \ref{mu-coercion} et la correction de la coercion.
    On peut donc dériver $`G \typed f : \Pi x : V.W$ à l'aide de la règle
    \irule{Coerce}.
    Par le lemme \ref{correct-coercion} appliqué à $\subalgo{`G}{U}{V}$
    et l'hypothèse $`G \typed u : U$, on obtient $`G \typed u : V$ par \irule{Coerce}.
    Donc, par \irule{App}, on a bien $`G \typed f u : W[u/x]$.
    
    \case{SumDep}
    On a 
    \begin{prooftree}
      \SumDepA
    \end{prooftree}
    
    Par induction et correction de la coercion, on peut dériver:
    $\tdecl{`G}{t}{T}$ et $\tdecl{`G}{u}{U[t/x]}$. On a
    $\tdecl{`G}{\Sigma x : T.U}{s}$, on peut donc appliquer
    \irule{SumDep}

    \case{PiRight} On a
    \begin{prooftree}
      \PiRightA
    \end{prooftree}

    Par induction, $\tdecl{`G}{t}{S}$, et par le lemme \ref{mu-coercion}
    et la correction de la coercion $S \subd \Sigma x : T. U$.
    On peut donc dériver $\tdecl{`G}{t}{\Sigma x : T.U}$ à l'aide de \irule{Coerce}.
    On peut directement appliquer \irule{PiRight} à cette prémisse pour
    obtenir $\tdecl{`G}{\pi_2~t}{U[\pi_1~t/x]}$.
    De même pour \irule{PiLeft}.


  \end{induction}  
\end{proof}

On a prouvé que notre système algorithmique était correct, c'est-à-dire
que ses jugements valides sont bien inclus dans ceux du système
déclaratif, il faut maintenant montrer qu'il les inclut tous (ou presque!).

\begin{subsubsection}{Notations}
On introduit la notation $\talgo{`G}{T, U}{s}$ pour $\talgo{`G}{T}{s} `^
\talgo{`G}{U}{s}$.
\end{subsubsection}

\subsection{Complétude et décidabilité}
On va maintenant repartir des systèmes déclaratifs pour montrer comment
l'on a construit les systèmes algorithmiques. 


On s'intéresse tout d'abord au jugement de coercion.
Pour rendre le jugement de coercion décidable, il faut traiter les règles
\irule{SubConv} et \irule{SubHnf} qu'on peut appliquer à n'importe quel 
moment et la règle \irule{SubTrans} qui n'est pas dirigée par la syntaxe (il faut
``deviner'' un type $T$). Le système de coercion algorithmique (figure
\ref{fig:subtyping-algo-rules}) est le même que le système
déclaratif (figure \ref{fig:subtyping-decl-rules}) mais où l'on n'applique 
\irule{SubConv} seulement si aucune autre règle ne
s'applique après avoir appliqué \irule{SubHnf} 
et sans la règle \irule{SubTrans}.

\subsubsection{Décidabilité et complétude de la coercion}
On va montrer que les deux systèmes de coercion sont équivalents vis-à-vis de la conversion. On montrera plus tard pourquoi on peut éliminer la
règle de transitivité.

Il nous faut tout d'abord des lemmes d'inversion sur la conversion:
\begin{lemma}
  \label{conversion-pi}
  Si $\Pi x : T. U \eqbr S$ alors $\hnf{S} = \Pi x : T'. U'$ avec $T \eqbr T'$ et $U
  \eqbr U'$.
\end{lemma}
\begin{lemma}
  \label{conversion-sigma}
  Si $\Sigma x : T. U \eqbr S$ alors $\hnf{S} = \Sigma x : T'. U'$ avec $T \eqbr T'$ et $U
  \eqbr U'$.
\end{lemma}

L'affaiblissement montre que notre notion de coercion joue un rôle
similaire à la seule conversion vis-à-vis du typage. On peut dériver les mêmes jugements dans des
contextes où les variables ont des types équivalents par la coercion.
Ici la taille des dérivations ne change pas.

\begin{lemma}[Affaiblissement]
  \label{narrowing-a}
  \[ `G \seq S, S' : s, S' \sub S "=>" 
  \left\{ \begin{array}{lcl}
      \typewf `G, x : S, `D & "=>" & \typewf `G, x : S', `D \\
      & `^{} & \\
      `G, x : S, `D \seq t : T & "=>" & `G, x : S', `D \seq t : T \text{ si $T `: \setproptype$} \\
      `G, x : S, `D \seq t : T & "=>" & `G, x : S', `D \seq t : T' \suba T \text{ sinon }
    \end{array}
  \right. \]
\end{lemma}

\begin{proof}
  Par induction sur la taille de la dérivation de typage ou de bonne formation.
    
  \begin{induction}
    \case{WfEmpty} Trivial.
    
    \case{WfVar} 
    La conclusion est $\typewf `G, x : S, `D$
    
    \begin{induction}[text=Par induction sur la taille de $`D$]
      \caseother{$`D = []$}
      La racine de la dérivation est de la forme:
      \begin{prooftree}
        \UAX{WfVar}
        {$`G \type S : s$}
        {$\wf `G, x : S$}
        {$s `: \setproptype$}
      \end{prooftree}
      On a donc $`G \type S' : s$, et par \irule{WfVar}, $\typewf `G, x : S'$.  
      
      \caseother{$`D `= `D', y : U$}
      La racine de la dérivation est de la forme:
      \begin{prooftree}
        \UAX{WfVar}
        {$`G, x : S, `D' \type U : s$}
        {$\wf `G, x : S, `D', y : U$}
        {$s `: \setproptype$}
      \end{prooftree}
      Par induction sur la dérivation de typage $`G, x : S', `D' \seq U : s$,
      on a donc bien $\typewf `G, x : S', `D', y : U$ par \irule{WfVar}.
    \end{induction}
    
    \case{PropSet}
    Par induction, $\typewf `G, x : S', `D$, on applique simplement la règle.
    
    \case{Var}
    Par induction, $\typewf `G, x : S', `D$. La seule différence avec le
    contexte précédent est le type associé à $x$, donc si $t \not= x$, on
    peut simplement réappliquer \irule{Var}. Si $t `= x$ on a la
    dérivation:

    \begin{prooftree}
      \BAX{Var}
      {$\wf `G, x : S', `D$}
      {$x : S' `: `G$}
      {$`G, x : S', `D \seq x : S'$}
      {}
    \end{prooftree}
    
    On a bien $S' \suba S$, la propriété est donc bien vérifiée.
    
    \case{Prod} 
    Par induction, $`G, x : S', `D \type T : s1$ et $`G, x : S', `D
    y : T \seq U : s2$. On applique \irule{Prod} pour obtenir 
    $`G, x : S', `D \type \Pi x : T.U : s3$. De même, direct par induction pour le reste des règles.
  \end{induction}
\end{proof}


On peut maintenant montrer:
\begin{lemma}[Conservation de la conversion par coercion]
  \label{conversion-coercion}
  Si $\talgo{`G}{T, U}{s}$ et $T \eqbr U$ alors $\subalgo{`G}{T}{U}$.
\end{lemma}
\begin{proof}
  Par induction sur le nombre de constructeurs $\Pi, \Sigma, \{|\}$ dans
  la forme normale complète de $T$.
  
  \def\seq{\suba}
  
  \begin{induction}
    \caseother{$\hnf{T} = \Pi x : X.Y$}
    Alors $\hnf{U} = \Pi x : V.W$ et $X \eqbr V$, $Y \eqbr W$
    d'après le lemme \ref{conversion-pi}.
    On a $\talgo{`G, x : X}{Y}{s}$ et $\talgo{`G, x : V}{W}{s}$. 
    Par induction $\subalgo{`G}{V}{X}$.
    On peut donc appliquer le lemme de restriction pour obtenir
    $\talgo{`G, x : V}{Y, W}{s}$.
    On applique l'hypothèse d'induction pour obtenir $\subalgo{`G, x : V}{Y}{W}$. 
    On applique alors \irule{SubProd} à ces deux prémisses.
    
    \caseother{$\hnf{T} = \Sigma x : X.Y$}
    Alors $\hnf{U} = \Sigma x : V.W$, avec $X \eqbr V$ et $Y \eqbr
    W$. Par induction et application de \irule{SubSigma} en utilisant la
    restriction pour la deuxième prémisse.
    
    \caseother{$\hnf{T} `= \mysubset{x}{X}{P}$}
    On a alors $\hnf{U} = \mysubset{x}{X'}{P'}$ avec $X \eqbr X'$, $P \eqbr
    P'$, et la propriété est vraie par \irule{SubLeft} et \irule{SubRight}:
    
    \begin{prooftree}
      \AXC{$X \sub X'$}
      \LeftLabel{\SubLeftRule}
      \UIC{$\mysubset{x}{X}{P} \sub X'$}
      \LeftLabel{\SubRightRule}
      \UIC{$\mysubset{x}{X}{P} \sub \mysubset{x}{X'}{P'}$}
    \end{prooftree}

    \caseother{Sinon}
    On applique obligatoirement \irule{SubConv} et l'on a la prémisse $T
    \eqbr U$, c'est donc direct.
  \end{induction}
\end{proof}

Il n'y a pas de problème d'identification de sortes dans ce système,
contrairement au système $\lambda~C_\leq$ de Gang Chen \cite{ChenPhD},
puisqu'on n'a pas de cumulativité. 

On va maintenant montrer que la règle \irule{SubTrans} est admissible
dans notre système algorithmique. On montre ceci en l'éliminant de toute
dérivation possible la faisant intervenir.

\typenva
Tout d'abord quelques lemmes nécessaires pour la preuve:
\begin{lemma}[Coercion et $\mualgo{}$]
  \label{coercion-mu}
  \quad
  \begin{itemize}
  \item Si $\Pi x : X.Y \sub U$ alors $\mualgo{U} = \Pi x : X'.Y'$ et $X' \sub
    X$, $Y \sub Y'$.
  \item Si $\Sigma x : X.Y \sub U$ alors $\mualgo{U} = \Sigma x : X'.Y'$ et $X \sub
    X'$, $Y \sub Y'$.
  \item Pour tout $S,U$, $S \sub \mualgo{U}$ \ssi~$S \sub U$.
  \end{itemize}
\end{lemma}
\begin{proof}
  Par induction sur les dérivations de $\suba$ et la définition de $\mualgo{}$.

  Dans le dernier cas, de gauche à droite on construit la dérivation en
  ajoutant des applications de \irule{SubProof} et dans l'autre sens on
  est assuré de trouver la preuve dans la dérivation même de $S \sub U$:
  si $U$ n'est pas de la forme sous-ensemble c'est direct. Sinon, on
  peut trouver dans la preuve (en partant de la racine) la première
  utilisation de la règle \irule{SubProof}. A partir de là, on cherche
  la première utilisation d'une règle autre que \irule{SubProof} ou 
  \irule{SubSub}. On a une dérivation de $S' \suba \mualgo{U}$, on
  peut réappliquer les règles \irule{SubSub} oubliées précédemment 
  pour obtenir la preuve de $S \suba \mualgo{U}$.
\end{proof}

\begin{lemma}[Coercion et conversion]
  \label{coercion-conversion}
  Si $\talgo{`G}{S,T,U}{s}$, $S \eqbr T$ et $T \sub U$ alors $\subalgo{`G}{S}{U}$
\end{lemma}

\begin{proof}
  Par simple inspection des règles on voit que le jugement ne peut
  distinguer deux termes $\beta$-équivalents (ils ont forcément les
  mêmes constructeurs de tête appliqués à des termes équivalents).
\end{proof}

\begin{lemma}[Coercion et formes normales de tête]
  \label{coercion-hnf}
  Si $T \suba U$ alors $\hnf{T}~\suba \hnf{U}$ est dérivable par une
  dérivation plus petite ou égale.
\end{lemma}

\begin{proof}
  \begin{induction}[subtyping-algo]

    \case{SubConv} Trivial.
    \case{SubHnf} On prend la dérivation en prémisse.
    \casetwo{SubProd}{SubSigma} $T$ et $U$ sont égaux à leurs formes normales
    de tête, direct.

    \case{SubProof}
    Par induction $\hnf{T}~\suba \hnf{V}$, on applique \irule{SubProof}
    \case{SubSub} idem.
  \end{induction}  
\end{proof}

\begin{lemma}[Transitivité de la coercion]
  \label{transitive-coercion}
  Pour tout $S, T, U$ tel que $`G \type S,T,U : s$ si
  $S \sub T$ et $T \sub U$ alors $S \sub U$.
\end{lemma}

\begin{proof} 
  On procède par élimination de la règle \irule{SubTrans} dans toute
  dérivation de $S \sub U$.
  Par induction sur l'ordre lexicographique $< depth(S \sub T) +
  depth(T \sub U), depth(S \sub U) >$.
  On peut supposer qu'il n'y a pas
  d'applications successive de la règle \irule{SubHnf} dans nos
  dérivations, par idempotence de la mise en forme normale de tête et
  les conditions $T = \hnf{T} `^ U = \hnf{U}$ de cette règle.
  
  \begin{induction}
  \casetwo{SubConv}{*}\quad
  \begin{prooftree}
    \AXC{$S \eqbr T$}
    \UIC{$S \sub T$}
    \AXC{$T \sub U$}
    \BIC{$S \sub U$}
  \end{prooftree}
  
  Par le lemme \ref{coercion-conversion}, on élimine trivialement \irule{SubTrans}.
  
  \casetwo{SubHnf}{*}\quad
  \begin{prooftree}
    \AXC{$\hnf{S}~\sub \hnf{T}$}
    \UIC{$S \sub T$}
    \AXC{$T \sub U$}
    \BIC{$S \sub U$}
  \end{prooftree}
  
  Par le lemme \ref{coercion-hnf}, il existe une dérivation de 
  $\hnf{T} \sub \hnf{U}$ de taille plus petite ou égale à la
  dérivation de $T \sub U$ on peut donc se ramener au cas:
  
  \begin{prooftree}
    \AXC{$\hnf{S}~\sub \hnf{T}$}
    \UIC{$S \sub T$}
    \AXC{$\hnf{T} \sub \hnf{U}$}
    \UIC{$T \sub U$}
    \BIC{$S \sub U$}
  \end{prooftree}
    
  Par application de l'hypothèse d'induction on a une dérivation de 
  $S \sub U$.
  
  On peut faire le même raisonnement si la dérivation de $T \sub U$ se
  termine par une application de \irule{SubHnf}.
  On peut donc se restreindre aux cas où l'on
  n'utilise ni la règle \irule{SubHnf} ni la règle \irule{SubConv}
  dans les prémisses.
  
  \case{SubProd}\quad
  \begin{prooftree}
    \AXC{$C \sub A$}
    \AXC{$B \sub D$}
    \BIC{$\Pi x : A.B \sub \Pi x : C.D$}
    \AXC{$\Pi x : C.D \sub U$}
    \BIC{$\Pi x : A.B \sub U$}
  \end{prooftree}

  On n'a seulement à traiter le cas ou $\Pi x : C.D \sub U$ est dérivé par
  \irule{SubProd} ou \irule{SubProof}.
  \begin{induction}
    \case{SubProd} Alors on a
    \begin{prooftree}
      \AXC{$E \sub C$}
      \AXC{$D \sub F$}
      \BIC{$\Pi x : C.D \sub \Pi x : E.F$}
    \end{prooftree}
    
    On a donc la dérivation:
    \begin{prooftree}
      \AXC{$E \sub C$}\AXC{$C \sub A$}
      \BIC{$E \sub A$}
      
      \AXC{$B \sub D$}\AXC{$D \sub F$}
      \BIC{$B \sub F$}
      \BIC{$S = \Pi x : A.B \sub \Pi x : E.F = U$}
    \end{prooftree}
    
    La taille des dérivations de $E \sub C$, $C \sub A$ et $B \sub
    D$, $D \sub F$ étant plus
    petites que $\Pi x : A.B \sub \Pi x : C.D$ et $\Pi x : C.D \sub
    \Pi x : E.F$, on élimine bien la transitivité dans ce cas.

    \case{SubProof} On a:
    \begin{prooftree}
      \AXC{$\Pi x : C.D \sub E$}
      \UIC{$\Pi x : C.D \sub \mysubset{y}{E}{P}$}
    \end{prooftree}

    Par induction, on a:

    \begin{prooftree}
      \AXC{$\Pi x : A.B \sub \Pi x : C.D$}
      \AXC{$\Pi x : C.D \sub E$}
      \BIC{$\Pi x : A.B \sub E$}          
      \UIC{$S = \Pi x : A.B \sub \mysubset{y}{E}{P} = U$}
    \end{prooftree}
    
    Car $\Pi x : C.D \sub E$ est une dérivation plus petite que $T
    \sub U$.
  \end{induction}
  
  \case{SubSigma} De façon équivalente au produit.
  
  \case{SubProof}
  \begin{prooftree}
    \AXC{$S \sub C$}
    \UIC{$S \sub T = \mysubset{y}{C}{P}$}
    \AXC{$T \sub U$}
    \BIC{$S \sub U$}
  \end{prooftree}
  
  Encore une fois, par cas sur la dérivation de $\mysubset{y}{C}{P}
  = T \sub U$:
  \begin{induction}
    \case{SubConv} Trivial.
    \case{SubSub} On a:
    \begin{prooftree}
      \AXC{$C \sub U$}
      \UIC{$\mysubset{y}{C}{P} = T \sub U$}
    \end{prooftree}
    
    Par induction, on obtient directement $S \sub U$ avec les
    dérivations de $S \sub C$ et $C \sub U$.     
    
    \case{SubProof}
    On a:
    \begin{prooftree}
      \AXC{$T \sub D$}
      \UIC{$\mysubset{y}{C}{P} = T \sub \mysubset{y}{D}{Q} = U$}
    \end{prooftree}
    
    On a donc une dérivation de $S \sub D$ par application de
    l'hypothèse d'induction. On en déduit une dérivation de $S \sub
    \mysubset{y}{D}{Q} = U$ par \irule{SubProof}.
  \end{induction}
  
  \case{SubSub} De même.
\end{induction}
\end{proof}

\begin{corrolary}[Complétude de la coercion]
  \label{complete-coercion}
  Si $\talgo{`G}{U,V}{s}$, $U \subd V$ alors $\subalgo{`G}{U}{V}$.
\end{corrolary}

\begin{proof}
  Les règles des deux systèmes sont les mêmes excepté \irule{SubTrans}
  qui est admissible dans le système algorithmique. De plus
  l'application restreinte de la conversion ne change pas les jugements
  dérivables (lemme \ref{conversion-coercion}). Le fait de forcer les
  types à être bien sortés assure juste que l'on a les mêmes relations.
  \Problem{Que faire pour éviter ça?}
\end{proof}

En conséquence $\subd$ et $\suba$ sont équivalentes. Le système
d'inférence de $\suba$ donne donc un algorithme pour décider de la relation
de coercion. L'indéterminisme entre les règles \irule{SubProof} et
\irule{SubSub} ne pose pas de problème: on peut laisser le choix à 
l'implantation puisque le système est confluent. \irule{SubHnf}
formalise le fait qu'on peut avoir à réduire en tête avant d'appliquer
les autres règles (pour obtenir un produit, une somme ou un sous-ensemble).

\subsubsection{Décidabilité et complétude du typage}
Le système algorithmique correspond au système déclaratif où l'on a enlevé la règle
de coercion \irule{Coerce} et changé certaines règles pour obtenir un système décidable
(voir figure \ref{fig:typing-algo-rules}).
On va procéder de façon similaire à l'élimination de la transitivité
pour montrer que la règle \irule{Coerce} n'est plus nécessaire dans le
système algorithmique. On va montrer en fait que
toute dérivation de typage utilisant \irule{Coerce} peut se réécrire en
une dérivation n'utilisant cette règle qu'à sa racine.

% \paragraph{Sommes dépendantes}
% On veut pouvoir faire le plus d'inférence possible dans notre sytème
% algorithmique, on a donc introduit une règle \irule{SumInf} qui ne force
% pas à annoter les paires. Dans le cas ou le terme n'est pas annoté, on
% considère donc que la somme n'est pas dépendante. En effet on remarque
%  qu'il n'est pas possible d'inférer le type $U$ à partir du seul terme $(t, u)$. Cela
% nécessiterait de résoudre un problème d'unification d'ordre supérieur
% auquel il n'y a pas de solution la plus générale. 
% On a donc dans le système algorithmique deux règles pour les sommes, 
% dont une (\irule{SumDep}) permettant d'annoter le terme avec le type $U$ recherché. 

\paragraph{\'Elimination de la coercion}
\typenva
On veut maintenant montrer la complétude de notre système. Dans un
système à sous-typage, le théorème correspondant est parfois nommé
typage minimal ``\emph{minimal typing}'' puisque son énoncé revient à
dire que tout terme a un type minimal dans les deux systèmes. En effet
notre théorème est le suivant:
$`G \typed t : T "=>" `G \typea t : U \suba T$. Le typage algorithmique
assigne bien un seul type à un terme $t$ mais comme on a des coercions, le
type inféré $U$ peut être un peu différent du type $T$. Dans notre cas
particulier $U$ sera peut-être un type moins riche que $T$ (par
exemple $\nat$ par rapport à $\mysubset{x}{\nat}{P}$). Lorsque l'on
développera des programmes, on donnera une spécification forte et l'on
fera une coercion entre le type inféré et la spécification pour obtenir
au final (après réécriture dans \Coq) un terme du type $T$ le plus riche.
On a besoin de quelques lemmes pour montrer que notre système où
la règle \irule{Coerce} a été éliminée est complet:

\begin{lemma}[$\mualgo{}$ et types produits et sommes]
  \label{beta-mu}
  Si $X \sub Y$ et $\mualgo{Y} = \Sigma x : T.U$ alors $\mualgo{X} = \Sigma x : T'.U'$
  et $T' \sub T$, $U' \sub U$.
  Si $X \sub Y$ et $\mualgo{Y} = \Pi x : T.U$ alors $\mualgo{X} = \Pi x :
  T'.U'$ et $T \sub T'$, $U' \sub U$.
\end{lemma}
\begin{proof}
  Par induction sur la dérivation de coercion, on fait le cas pour $\Sigma$.
  \begin{induction}  
    \case{SubConv} Trivial, puisqu'on aura $\mualgo{X} = \mualgo{Y}$.

    \case{SubHnf} Trivial puisque pour tout $x$, $\mualgo{x} =
    \mualgo{\hnf{x}}$.
    
    \case{SubProd} Impossible, $\mualgo{}$ ne traversant pas les produits.

    \case{SubSigma} Direct, on a une dérivation de $\Sigma x : T'. U'
    \sub \Sigma x : T.U$.
    
    \case{SubProof} Ici, $Y `= \mysubset{x}{V}{P}$, on peut donc déduire que
    $\mualgo{Y} = \mualgo{V} = \Sigma x : T.U$. On 
    applique l'hypothèse de récurrence avec $X \sub V$ et on obtient:
    $\mualgo{X} = \Sigma x : T'.U' `^ T' \sub T `^ U' \sub U$.

    \case{SubSub} Ici, $X `= \mysubset{x}{V}{P}$. Par induction, 
    $\mualgo{V} = \mualgo{X} = \Sigma x : T'.U' `^ T' \sub T `^ U' \sub U$.
  \end{induction}
\end{proof}

Il nous faut montrer des lemmes faisant intervenir la substitution pour
pouvoir prouver la complétude.
\begin{lemma}[Substitutivité de $\mualgo{}$]
  \label{substitutive-mu}
  Si $\mualgo{T} = \Pi y : U.V$ alors $\mualgo{T[u/x]} = \Pi y :
  U[u/x].V[u/x]$.
  Si $\mualgo{T} = \Sigma y : U.V$ alors $\mualgo{T[u/x]} = \Sigma y : U[u/x].V[u/x]$.
\end{lemma}

\begin{proof}
  On montre la propriété pour les produits, la preuve est similaire pour
  les sommes. Par induction sur le nombre de constructeurs $\Pi, \Sigma,
  \{|\}$ dans la forme normale complète de $T$.

  Il suffit de suivre la définition de $\mualgo{}$.
  Si $\hnf{T}$ est de la forme $\mysubset{y}{V}{P}$ alors
  on a $\mualgo{V} = \Pi y : U.V$ et par induction
  $\mualgo{V[u/x]} = \Pi y : U[u/x].V[u/x]$.
  Il s'ensuit directement que $\mualgo{T[u/x]} = \Pi y :
  U[u/x].V[u/x]$.

  Si $\hnf{T}$ est différent d'un type sous-ensemble alors $\mualgo{T} = \hnf{T}$.
  On a alors $\hnf{T} = \Pi y : U.V$ et donc $\hnf{T[u/x]} = \Pi y : U[u/x].V[u/x] =
  \mualgo{T[u/x]}$.
\end{proof}

\begin{lemma}[Substitutivité du typage]
  \label{substitutive-typing}
  Si $`G \typea u : U$ alors
  \[ \left\{ \begin{array}{lcl}
      `G, x : U, `D \typea t : T & "=>" & `G, `D[u/x] \typea t[u/x] : T[u/x] \\
      \wf `G, x : U, `D & "=>" & \wf `G, `D[u/x] \\
      \subalgo{`G, x : U, `D}{U}{T} & "=>" & \subalgo{`G, `D[u/x]}{U[u/x]}{T[u/x]}
    \end{array}\right. \]
\end{lemma}

\begin{proof}
  \typenva
  Par induction mutuelle sur les dérivation de typage, bonne formation
  et coercion.
  
  \begin{induction}
    \case{WfEmpty} Trivial.

    \case{WfVar}
    Par induction sur $`D$.
    \begin{induction}
    \caseother{$`D = []$}
      On a alors $`G \typea U : s$ donc $\wf `G$ et trivialement, $\wf
      `G, `D[u/x]$.

    \caseother{$`D = `D', y : T$}
      On a alors $`G, x : U, `D' \typea T : s$ et par induction
      $`G, `D'[u/x] \typea T[u/x] : s[u/x] = s$. Donc on peut appliquer
      \irule{WfVar} pour obtenir $\wf `G, `D'[u/x], y : T[u/x]$ soit
      $\wf `G, `D[u/x]$
    \end{induction}
    
    \case{PropSet}
    La substitution n'a aucun effet et $`G, `D[u/x]$ est bien
    formé par induction.
    
    \case{Var}
    Par induction, $\wf `G, `D[u/x]$.
    Si $t `= x$ alors on a $T = U$ et $T[u/x] = U$ puisque $x$
    n'apparaît pas dans $U$. On a donc $`G, `D[u/x] \typea t[u/x] = u :
    T[u/x] = U$, qui peut s'obtenir par affaiblissement de $`G \typea u
    : U$. 
    Si $y : T `: `G$ alors on applique simplement \irule{Var}.
    Si $y : T `: `D$ alors $y : T[u/x] `: `D[u/x]$ et on obtient
    $`G, `D[u/x] \typea y[u/x] :  T[u/x]$ par \irule{Var}.
    
    \case{Prod}
    Par induction  $`G, `D[u/x] \typea T[u/x] : s_1[u/x]$ et
    $`G, `D[u/x], y : T[u/x] \typea M[u/x] : s_2[u/x]$. 
    On peut appliquer \irule{Prod} pour obtenir $`G, `D[u/x] \typea \Pi
    y : T[u/x].M[u/x] : s_2$ soit $`G, `D[u/x] \typea (\Pi y :
    T.M)[u/x] : s_2$.
    De façon similaire pour les autres constructeurs de types.

    \case{App}
    On étudie le cas de l'application qui requiert un lemme supplémentaire.
    Par induction, on a $`G, `D[u/x] \typea f[u/x] : T[u/x]$ et
    $`G, `D[u/x] \typea a[u/x] : A[u/x]$. Si $\mualgo{T} = \Pi y :
    V.W$ alors $\mualgo{T[u/x]} = \Pi y : V[u/x].W[u/x]$ (lemme
    \ref{substitutive-mu}). Par induction, on a aussi $`G, `D[u/x] \typea
    A[u/x],V[u/x] : s$. Enfin, par substitutivité de la coercion on a $A[u/x]
    \suba V[u/x]$. On peut donc appliquer \irule{App} pour obtenir 
    $`G, `D[u/x] \typea (f[u/x]~a[u/x]) : W[u/x][a[u/x]/y]$. Or
    $W[u/x][a[u/x]/y] = W[a/y][u/x]$ ($y `; \freevars{u}$). On a donc bien $`G, `D[u/x] \typea (f~a)[u/x] :
    (W[a/y])[u/x]$.

    \case{PiLeft}
    Par induction on a $\talgo{`G, `D[u/x]}{t[u/x]}{S[u/x]}$, et par
    substitutivité de $\mualgo{}$ on a aussi $\mualgo{S[u/x]} = \Sigma y :
    T[u/x].U[u/x]$.
    Il suffit alors d'appliquer \irule{PiLeft}

    \case{PiRight}
    De même on se retrouve avec $\talgo{`G, `D[u/x]}{t[u/x]}{S[u/x]}$,
    et $\mualgo{S[u/x]} = \Sigma y : T[u/x].U[u/x]$.
    Il suffit alors d'appliquer \irule{PiRight} pour obtenir:
    \[\talgo{`G, `D[u/x]}{\pi_2~t[u/x]}{U[u/x][\pi_1~t[u/x]/y] =
      U[\pi_1~t/y][u/x]} \text{ car } y `; \freevars{u}\]

    \case{SumDep} On a:
    \begin{prooftree}
      \SumDepAFull[\GD]{y}{t}{v}{T}{V}{s}{T'}{V'}      
    \end{prooftree}
    
    Par induction et application de \irule{SumDep}:
    \begin{prooftree}
      \SumDepAFullWide[\Gr]{y}{t[u/x]}{v[u/x]}{T[u/x]}{V[u/x]}{s}{T'[u/x]}{V'[u/x]}
    \end{prooftree}
   
    On a bien $V[u/x][t[u/x]/y] = V[t/y][u/x]$ car $y `; \freevars{u}$.

    \case{SubConv}
    Direct par préservation de l'équivalence $\eqbr$ par substitution et
    application de l'hypothèse d'induction pour le typage.
    
    \case{SubHnf}
    Par induction, $(\hnf{U})[u/x] \suba (\hnf{T})[u/x]$. 
    Par le lemme \ref{coercion-hnf}, $\hnf{((\hnf{U})[u/x])} \suba
    \hnf{((\hnf{T})[u/x])}$. 
    Donc $\hnf{U[u/x]}~\suba \hnf{T[u/x]}$ et par \irule{SubHnf}, 
    $U[u/x] \suba T[u/x]$.

    \case{SubProd}
    Par induction $U[u/x] \suba T[u/x]$ et $V[u/x] \suba W[u/x]$, donc
    $\Pi y : T[u/x].V[u/x] \suba \Pi y : U[u/x].W[u/x]$. La propriété
    est donc bien vérifiée.
    
    \case{SubSigma} Direct par induction.
    
    \case{SubSub} Par induction, $U'[u/x] \suba V[u/x]$. On applique
    \irule{SubLeft} pour obtenir $\mysubset{y}{U'[u/x]}{P} \suba V[u/x]$. 
    
    \case{SubRight} Direct par induction.

  \end{induction}
  
\end{proof}

\begin{corrolary}[Substitutivité du typage avec coercion]
  \label{substitutive-typing-coercion}
  Si $`G, x : V \typea t : T \sub U$ et $`G \typea u : V$
  alors $`G \typed t[u/x] : T[u/x] \sub U[u/x]$.
\end{corrolary}

On a maintenant tout les ingrédients pour montrer la complétude de notre
système de typage vis-à-vis du système déclaratif.

\setboolean{displayLabels}{false}
\begin{theorem}[Complétude du typage]
  \label{complete-typing}
  Si $`G \typed T : s$ alors $`G \typea T : s$.
  Si $`G \typed t : T$ alors $`E U, `G \typea t : U$, $`G \typea T, U :
  s$ et $U \sub T$.
  Si $\typewf `G$ dans le système déclaratif alors $\typewf `G$ dans le
  système algorithmique.
\end{theorem}

\begin{proof}
  \typenva
  Par induction mutuelle sur les dérivations de typage et bonne formation.
  \begin{induction}
    \case{WfEmpty} Trivial.
    
    \case{WfVar} \typenvd
    \begin{prooftree}
      \WfVar
    \end{prooftree}
    Par induction $`E s', `G \typea A : s' \sub s$. On a forcément $s' =
    s$ puisque les sortes ne sont en relation qu'avec elles-mêmes.
    On applique \irule{WfVar} pour obtenir $\typewf `G, x : A$.
    
    \case{PropSet} Trivial.

    \case{Var}
    \typenvd
    \begin{prooftree}
      \Var
    \end{prooftree}
    Par induction $\typewf `G$ et $x : A `: `G$ , direct par
    \irule{Var}. On vérifie que si $A$ est une sorte on dérive bien la
    même sorte dans le système algorithmique.
    
    \case{Prod}
    \typenvd
    \begin{prooftree}
      \Prod
    \end{prooftree}
    
    Direct par induction et le fait que $\mathcal{R}$ est fonctionnelle.
            
    \case{Abs}
    \typenvd
    \begin{prooftree}
      \Abs
    \end{prooftree}
    Par induction $`E U', `G, x : T \typea M : U' \suba U$ et $`G, x : T
    \typea U', U : s$. On peut donc dériver
    $`G \typea \Pi x : T.U' : s$. On a bien $`G \typea \lambda x :
    T.M : \Pi x : T.U' \suba \Pi x : T.U$ et les deux types ont la même sorte.
    
    \case{App} On a 
    \typenvd
    \begin{prooftree}
      \App
    \end{prooftree}
    
    \typenva
    Par induction, $`E T, `G \typea f : T \suba \Pi x : V. W$ et
    $`E U, `G \subta u : U \sub V$.
    
    Si $T \suba \Pi x : V.W$ alors $\mualgo{T} = \Pi x : V'.W'$ avec
    $V \suba V'$ et $W' \suba W$ (lemme \ref{beta-mu}).

    Par transitivité de la coercion: $U \suba V'$, on peut donc dériver 
    \begin{prooftree}
      \TAX{App}
      {$`G \seq f : T \quad \mualgo{T} = \Pi x : V'. W'$}
      {$`G \seq u : U \quad `G \seq U, V' : s$}
      {$U \suba V'$}
      {$`G \seq (f u) : W' [ u / x ]$}
      {}
    \end{prooftree}
    
    Par substitutivité de la coercion (lemme
    \ref{substitutive-typing}), $W'[u/x] \suba W[u/x]$, la propriété
    est donc bien vérifiée. Les conditions de sortes sont vérifiées du
    fait que $\mualgo{}$ conserve les sortes, donc $`G \typea T, \Pi x :
    V'.W', \Pi x : V.W : s$ puis par inversion, $`G, x : V \typea W', W
    : s$ et enfin par subtitutivité, $`G \typea W'[u/x], W[u/x] : s$.
    
    \case{Sigma}\quad
    \typenvd
    \begin{prooftree}
      \SigmaR
    \end{prooftree}

    Par induction $`G \typea T : s$ et $`G, x : T \typea U : s$ où $s `:
    \{ \Prop, \Set \}$. C'est direct par \irule{Sigma}.

    \case{SumDep}\quad
    \typenvd
    \begin{prooftree}
      \SumDep
    \end{prooftree}
    \typenva
    
    Ici, l'annotation nous force à utiliser le jugement de coercion.
    Par induction, $\Sigma x : T.U : s$, $`E T', `G
    \type t : T' \suba T$ et $`E U', `G \typea u : U' \suba U[t/x]$.
    On peut montrer $`G \type \Sigma x : T'.U : s$.
    En effet, par inversion de $`G \seq \Sigma x : T.U : s$ on a
    $`G, x : T \seq U : s$ et par restriction ($T' \sub T$), $`G, x : T' \seq
    U : s$.
    Comme $T' \suba T$ on obtient $\Sigma x : T'.U \suba \Sigma x : T.U$.
    On peut donc dériver:
    \begin{prooftree}
      \QAX{SumDep}
      {$`G \seq t : T'$}
      {$`G \seq u : U'$}
      {$`G \seq U[t/x], U' : s \quad U' \suba U[t/x]$}
      {$`G \seq \Sigma x : T'.U : s$}
      {$`G \seq (x \coloneqq~t, u : U) : \Sigma x : T'.U$}
      {}
    \end{prooftree} 
    
    \casetwo{PiLeft}{PiRight} On a
    \typenvd
    \begin{prooftree}
      \PiLeft
    \end{prooftree}
    Par induction, $`E T', \talgosub{`G}{t}{T'}{\Sigma x : T.U}$. On en
    déduit que $\mualgo{T'} = \Sigma x : T'.U'$ avec
    $\subalgo{`G}{T'}{T}$ et $\subalgo{`G, x : T'}{U'}{U}$.
    Clairement, $\talgosub{`G}{\pi_1~t}{T'}{T}$ et
    $\talgosub{`G}{\pi_2~t}{U'[\pi_1~t/x]}{U[\pi_1~t/x]}$ par
    substitutivité de la coercion.
    

    \casetwo{Conv}{Coerce}
    Dans les deux cas on a inductivement $`E T', `G \typea t : T'
    \suba T$. Avec \irule{Conv} on a $T \eqbr S$, donc $T' \suba S$ par
    le lemme \ref{coercion-conversion}. Pour \irule{Coerce} on a $T \subd S$.
    Par complétude de la coercion, $T \suba S$ et par transitivité de la
    coercion, $T' \suba S$. La propriété est donc bien vérifiée dans les
    deux cas.
  \end{induction}
\end{proof}

On combine les théorèmes de correction et de complétude pour obtenir
 la propriété suivante entre les deux systèmes:
\begin{corrolary}[Équivalence des systèmes déclaratif et algorithmique]
  $`G \typed t : T$ \ssi{} il existe $U$ tel que $`G \typea t : U$ et $U \suba T$.
\end{corrolary}

On a maintenant un système raffiné dérivant les mêmes jugements (à
coercion près) que le système déclaratif. On veut en extraire un
algorithme de typage. Pour cela on doit pouvoir résoudre deux problèmes:
\begin{itemize}
\item\textbf{Vérification de type.} On donne $`G$,$t$ et $T$ et l'on doit
  décider si $`G \typea t : T$ ;
\item\textbf{Inférence de type.} On donne $`G$,$t$ et l'on doit trouver $T$ tel
  que $`G \typea t : T$ si c'est dérivable, sinon on échoue.
\end{itemize}
En pratique, la vérification a besoin de l'inférence puisque lorsqu'on
vérifie une application $f u : T$ on doit inférer le type de $f$.
On montre donc les théorèmes suivants:

\begin{theorem}[Décidabilité de l'inférence dans le système algorithmique]
  Le problème d'inférence $`G \typea t :~?$ est décidable.
\end{theorem}

\begin{proof}
  Il suffit d'observer que les règles de typage sont dirigées par la
  syntaxe du deuxième argument et permettent donc d'inférer un type pour
  tout terme. En lisant les prémisses de chaque règle de gauche à
  droite, on voit que l'inférence est décidable.
\end{proof}

\begin{theorem}[Décidabilité de $\typea$]
  La relation de typage $`G \typea t : T$ est décidable.
\end{theorem}
\begin{proof}
  Direct. On utilise le théorème précédent pour le cas de l'application.
\end{proof}

On a désormais un algorithme de typage pour notre système avec
coercions. Ce système est très libéral puisqu'il permet de considérer
des objets comme vérifiant des propriétés arbitraires sans les
montrer. Il nous faut maintenant remettre de la logique dans nos termes
pour s'assurer qu'ils sont corrects.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "subset-typing"
%%% LaTeX-command: "TEXINPUTS=\"style:$TEXINPUTS\" latex"
%%% End: 
 