\subsection{Élaboration du système algorithmique \& propriétés}
\typenva

Pour pouvoir implémenter le typeur, il nous faut un système dirigé par la
syntaxe. 
Pour la coercion, il y a juste la règle
\irule{SubConv} qu'on peut appliquer à n'importe quel moment et la règle
\irule{SubTrans} qui n'est pas dirigée par la syntaxe (il faut
``deviner'' un type $T$). 

\subsubsection*{Conversion}
On note $\suba$ le même système que figure \ref{subtyping-decl-rules} mais
où l'on n'applique \irule{SubConv} seulement si aucune autre règle ne
s'applique et sans la rêgle \irule{SubTrans}.
On va montrer que les deux systèmes de coercion sont équivalents vis à
vis de la conversion. On montrera plus tard pourquoi on peut éliminer la
règle de transitivité.

Il nous faut tout d'abord des lemmes d'inversion sur la conversion:

On note $"->>"_\beta$ la $\beta$-normalisation de tête. On rappelle qu'on
considère qu'on peut appliquer la normalisation de tête avant tout
application d'une règle de typage ou coercion. Ainsi on peut très bien
dériver $((\lambda x : \Set.x)~\nat) \suba \subset{x}{\nat}{P}$ puisque 
$((\lambda x : \Set.x)~\nat) "->>"_\beta \nat$ et $\nat \suba
\subset{x}{\nat}{P}$ par \irule{SubProof} et \irule{SubConv}.
On note $\typea$ le jugement de typage algorithmique. Le système
algorithmique correspond au système déclaratif où l'on a enlevé la règle
de coercion et changé certaines règles pour obtenir un système décidable
(voir figure \ref{fig:typing-algo-rules}).

\begin{lemma}
  \label{conversion-pi}
  Si $\Pi x : T. U \eqbi S$ alors $S "->>"_\beta \Pi x : T'. U'$ avec $T \eqbi T'$ et $U
  \eqbi U'$.
\end{lemma}
\begin{lemma}
  \label{conversion-sigma}
  Si $\Sigma x : T. U \eqbi S$ alors $S "->>"_\beta \Sigma x : T'. U'$ avec $T \eqbi T'$ et $U
  \eqbi U'$.
\end{lemma}

On introduit la notation $`G \typea T, U : s$ pour $`G \typea T : s_1 `^
`G \typea U : s_2 `^ s_1 = s_2 = s$.

On peut maintenant montrer:
\begin{lemma}[Conservation de la conversion par coercion]
  \label{conversion-coercion}
  Si $`G \typea T, U : s$ et $T \eqbi U$ alors $T \suba U$.
\end{lemma}
\begin{proof}
  Par induction sur la forme de $T$.
  
  \def\seq{\suba}.
  
  \begin{itemize}
  \item[$T `= \Pi x : X.Y$:]
    Alors $U "->>"_\beta \Pi y : V.W$ et $X \eqbi V$, $Y \eqbi W$
    d'après le lemme \ref{conversion-pi}.
    Par induction $X \sub Y$ et $V \sub W$. 
    On applique alors \irule{SubProd} à ces deux prémisses.
    
  \item[$T `= \Sigma x : X.Y$:]
    Alors $U "->>"_\beta \Sigma y : V.W$, avec $X \eqbi V$ et $Y \eqbi
    W$. Par induction et application de \irule{SubSigma}.
    
  \item[$T `= \subset{x}{X}{P}$:] 
    On a alors $U "->>"_\beta \subset{x}{X'}{P'}$ avec $X \eqbi X'$, $P \eqbi
    P'$, et la propriété est vraie par \irule{SubLeft} et \irule{SubRight}:
    
    \begin{prooftree}
      \AXC{$X \sub X'$}
      \LeftLabel{\SubLeftRule}
      \UIC{$\subset{x}{X}{P} \sub X'$}
      \LeftLabel{\SubRightRule}
      \UIC{$\subset{x}{X}{P} \sub \subset{x}{X'}{P'}$}
    \end{prooftree}

  \item[Sinon:]
    On applique obligatoirement \irule{SubConv} et l'on a la prémisse $T
    \eqbi U$, c'est donc direct.
  \end{itemize}
\end{proof}

Il faut cependant s'assurer que deux types de sortes
différentes ne peuvent être identifiés. En effet dans notre système
la $\beta$-convertibilité n'assure pas que deux termes ont la même
sorte, par exemple:
$\typed (\lambda x : \Type. x)~(\nat:\Set) : \Type "->"_\beta \nat : \Set$.
\TODO{Dans mon système, on ne peut pas faire la coercion de nat à Set}

Le fait que les arguments sont tous les deux sortés avec la même sorte
avant de dériver le jugement de coercion nous assure que l'on ne fera
pas d'identification erronée dans les autres règles que \irule{SubConv}.

En conséquence $\subd$ et $\suba$ sont équivalentes. Le système
d'inférence de $\suba$ donne donc un algorithme pour décider de la relation
de coercion. L'indéterminisme entre les règles \irule{SubProof} et
\irule{SubSub} ne pose pas de problème: on peut laisser le choix à 
l'implémentation puisque le système est confluent.

Cependant, il reste une source importante d'indécidabilité dans le
système de typage, c'est la règle de coercion. On va l'éliminer du
système algorithmique après avoir montré que
toute dérivation de typage utilisant \irule{Coerce} peut se réécrire en
une dérivation n'utilisant cette règle qu'à sa racine.
\def\subs{\subset{x}{U}{P}}
Il nous faut changer quelque peu les règles pour obtenir le système
algorithmique. En particulier, on va utiliser la fonction $\mu0$ de \PVS{}
\cite{PVS-Semantics:TR} renommée $\mu$ ici pour opèrer des
\emph{décompréhension}. Cette fonction efface les constructeurs de type
sous-ensemble en tête d'un type, par exemple: $\mualgo(\subset{f}{\nat
  "->" \nat}{f~0 = 0}) = \nat "->" \nat$. Cela va nous permettre de
restreindre l'utilisation du jugement de coercion à l'application.

\subsection*{Sommes dépendantes}
En inspectant la règle \irule{Sum}, on remarque qu'il n'est pas possible
d'inférer le type $U$ à partir du seul terme $(t, u)$. Cela
nécessiterait de résoudre un problème d'unification d'ordre supérieur
auquel il n'y a pas de solution la plus générale. On introduit donc dans
le système algorithmique deux nouvelles règles, dont une (\irule{SumDep})
permettant d'annoter le terme avec le type $U$ recherché. On considère
que c'est à l'utilisateur d'annoter suffisament les termes. Par défaut,
si le terme n'est pas annoté on considère l'objet $(u, v)$ comme une
paire non-dépendante (\irule{SumInf}).

\typenva
\typeaFig
\typemuaFig
\subtaFig

\subsection*{Subsumption}
\typenva

% On enlève \irule{Coerce} du système et on change la règle 
% d'application \irule{App} de la figure \ref{typing-decl-rules}.
% On note $\typea$ le système de typage obtenu. 

La technique que nous allons utiliser pour montrer l'équivalence entre
les deux systèmes est la suivante: on considère le système algorithmique
auquel on ajoute la règle de subsumption. On montre que toute dérivation
de ce système se réecrit dans une dérivation du système algorithmique
sans la règle \irule{Coerce} et on montre ensuite que toute dérivation
du système déclaratif a une dérivation correspondante dans le système
algorithmique.

\begin{proposition}[Passage de la subsumption à l'application]
  \label{subsum-elim}
  On peut réecrire toute dérivation $`G \typea t : T$ utilisant la
  subsumption ailleurs qu'à sa racine vers une dérivation $`G \type t :
  U$ avec $U \suba T$.
\end{proposition}

On utilisera l'abbréviation $`G \typea t : S \suba T$ pour $`G \typea t
: S `^{} S \suba T$ dans la suite.
On a besoin de quelques lemmes auparavant:

\begin{lemma}[$\beta$-equivalence et $\mu$]
  \label{beta-mu}
  Si $X \sub Y$ et $\mu~Y \eqbi \Sigma x : T.U$ alors $\mu X \eqbi \Sigma x : T'.U'$
  et $T' \sub T$, $U' \sub U$.
  Si $X \sub Y$ et $\mu~Y \eqbi \Pi x : T.U$ alors $\mu X \eqbi \Pi x :
  T'.U'$ et $T \sub T'$, $U' \sub U$.
\end{lemma}
\begin{proof}
  Par induction sur la dérivation de coercion, on fait le cas pour $\Sigma$.
  \begin{induction}  
    \case{SubConv} Trivial, puisqu'on aura $\mu~X = \mu~Y$.

    \case{SubProd} Impossible, $\mu$ ne traversant pas les produits.

    \case{SubSigma} Direct, on a une dérivation de $\Sigma x : T'. U'
    \sub \Sigma x : T.U$.
    
    \case{SubLeft} Ici, $Y `= \subset{x}{V}{P}$, on peut donc déduire que
    $\mu~Y = \mu~V \eqbi \Sigma x : T.U$. On 
    applique l'hypothèse de récurence avec $X \sub V$ et on obtient:
    $\mu~X \eqbi \Sigma x : T'.U' `^ T' \sub T `^ U' \sub U$.

    \case{SubRight} Ici, $X `= \subset{x}{V}{P}$. Par induction, 
    $\mu~V = \mu~X \eqbi \Sigma x : T'.U' `^ T' \sub T `^ U' \sub U$.
  \end{induction}
\end{proof}

\begin{lemma}[Bonne formation des contextes]
  \label{wf-contexts-a}
  Si $`G \type t : T$ alors $\typewf `G$.
\end{lemma}
\begin{proof}
  \inductionon{typing-decl}
\end{proof}

\begin{fact}[Inversion du jugement de bonne formation]
  \label{inversion-wf-a}
  Si $\typewf `G, x : U$ alors $`G \type U : s$ et $s `: \{ \Set, \Prop, \Type(i) \}$.
\end{fact}

\begin{lemma}[Affaiblissement]
  \label{weakening-a}
  Si $`G, `D \type t : T$ alors pour tout $x : S `; `G, `D$ tel que
  $\wf `G, x : S, `D$, $`G, x : S, `D \type t : T$
\end{lemma}

\begin{proof}
  \begin{induction}[typing-decl]
    \casetwo{PropSet}{Type} Trivial.

    \case{Var}
    On a $x : S `; `G, `D$, donc $`G, x : S, `D \type y : T$ est toujours dérivable.
    
    \case{Prod}
    Par induction $`G, x : S, `D \type T : s1$ et $`G, x : S, `D,
    y : T \seq U : s2$. On applique \irule{Prod} pour obtenir 
    $`G, x : S, `D \type \Pi x : T.U : s2$. De même pour le reste des règles.
  \end{induction}
\end{proof}  

La restriction montre que notre notion de coercion est correcte
vis-à-vis du typage. On peut dériver les mêmes jugements dans des
contextes où les variables ont des types plus précis, on le démontre de
nouveau pour le système algorithmique.

\begin{lemma}[Restriction]
  \label{narrowing-a}
  \[ `G \seq S, S' : s, S' \sub S "=>" 
  \left\{ \begin{array}{lcl}
      \typewf `G, x : S, `D & "=>" & \typewf `G, x : S', `D \\
      & `^{} & \\
      `G, x : S, `D \seq t : T & "=>" & `G, x : S', `D \seq t : T
    \end{array}
  \right. \]
\end{lemma}

\begin{proof}
  Par induction sur la taille de la dérivation de typage ou de bonne formation.
    
  \begin{induction}
    \case{WfEmpty} Trivial.
    
    \case{WfVar} 
    La conclusion est $\typewf `G, x : S, `D$
    
    \begin{induction}[text=Par induction sur la taille de $`D$]
    \item[\protect{$`D = []$}]
      La racine de la dérivation est de la forme:
      \begin{prooftree}
        \UAX{WfVar}
        {$`G \type S : s$}
        {$\wf `G, x : S$}
        {$s `: \{ \Set, \Prop, \Type(i) \}$}
      \end{prooftree}
      On a $`G \type S' : s$, donc par \irule{WfVar}, $\typewf `G, x : S'$.  
      
    \item[\protect{$`D `= `D', y : U$}]
      La racine de la dérivation est de la forme:
      \begin{prooftree}
        \UAX{WfVar}
        {$`G, x : S, `D' \type U : t$}
        {$\wf `G, x : S, `D', y : U$}
        {$s `: \{ \Set, \Prop, \Type(i) \}$}
      \end{prooftree}
      Par induction sur la dérivation de typage $`G, x : S', `D' \seq U : t$,
      on a donc bien $\typewf `G, x : S', `D', y : U$ par \irule{WfVar}.
    \end{induction}
    
    \casetwo{PropSet}{Type} 
    Par induction, $\typewf `G, x : S', `D$, on applique simplement la règle.
    
    \case{Var}
    Par induction, $\typewf `G, x : S', `D$. La seule différence avec le
    contexte précedent est le type associé à $x$, donc si $t \not= x$, on
    peut simplement réappliquer \irule{Var}. Si $t `= x$ on construit la
    dérivation:

    \begin{prooftree}
      \BAX{Var}
      {$\wf `G, x : S', `D$}
      {$x : S' `: `G$}
      {$`G, x : S', `D \seq x : S'$}
      {}
      \AXC{$`G, x : S', `D \type S,S' : s$}
      \AXC{$S' \sub S$} % `G \subt 
      \TIC{$`G, x : S', `D \type x : S$}
    \end{prooftree}
    
    Par l'affaiblissement (lemme \ref{weakening-a}) et $`G \type S,S' : s$,
    on obtient la prémisse $`G, x : S', `D \type S,S' : s$.
    
    \case{Prod} 
    Par induction, $`G, x : S', `D \type T : s1$ et $`G, x : S', `D
    y : T \seq U : s2$. On applique \irule{Prod} pour obtenir 
    $`G, x : S' \type \Pi x : T.U : s2$. De même pour le reste des règles.
  \end{induction}
\end{proof}

On peut maintenant montrer notre proposition:
\begin{proof}
  On inspecte les dérivations possibles utilisant \irule{Coerce} juste avant
  une autre règle.
  
  \typenva
  \begin{induction}
    \case{Var} Par de prémisse de la forme $`G \type t : T$, donc
    pas d'application de \irule{Subsum} possible.
    
    \case{Abs} \quad
    
    \begin{prooftree}
      \AXC{\vdots}
      \UIC{$`G \seq \Pi x : T. U : s $}
      \AXC{\vdots}
      \UIC{$`G, x : T \seq M : U'$}
      \AXC{\vdots}
      \UIC{$`G, x : T \seq U', U : s$}
      \AXC{\vdots}
      \UIC{$U' \sub U$}
      \TIC{$`G, x : T \seq M : U $}
      \BIC{$`G \seq \lambda x : T. M : \Pi x : T.U$}
    \end{prooftree}
    
    Comme $`G, x : T \typed U' : s$ on peut former le produit 
    $`G \typea \Pi x : T. U' : s$.
    On réecrit donc la dérivation en:     
    
    \begin{prooftree}
      \AXC{\vdots}
      \UIC{$`G \seq \Pi x : T. U' : s $}
      \AXC{\vdots}
      \UIC{$`G, x : T \seq M : U'$}
      \BIC{$`G \seq \lambda x : T. M : \Pi x : T.U'$}
      \AXC{$T \eqbi T$}
      \UIC{$T \sub T$}
      \AXC{\vdots}
      \UIC{$U' \sub U$}
      \BIC{$\Pi x : T.U' \sub \Pi X : T.U$}        
      \BIC{$`G \seq \lambda x : T. M : \Pi x : T.U$}
    \end{prooftree}
    
    \case{Sum}\quad
    
    \begin{prooftree}
      \AXC{\vdots}
      \UIC{$`G \seq \Sigma x : T.U : s $}
      \AXC{\vdots}
      \UIC{$`G \seq t : S$}
      \AXC{\vdots}
      \UIC{$S \sub T$}
      \BIC{$`G \seq t : T $}
      \AXC{\vdots}
      \UIC{$`G \seq u : U[t/x]$}
      \TIC{$`G \seq (t,u) : \Sigma x : T.U$}
    \end{prooftree}
    
    Comme $S \sub T$, on a bien $\Sigma x : S.U \sub \Sigma x : T.U$
    par \irule{SubSigma}. On sait de plus que $\Sigma x : S.U$ est bien
    sorté de sorte $s$. En effet, par inversion de $`G \seq \Sigma x :
    T.U : s$ on a $`G, x : T \seq U : s$ et par restriction ($S \sub T$), $`G, x : S \seq
    U : s$. On peut donc dériver:

    \begin{prooftree}
      \AXC{\vdots}
      \UIC{$`G \seq \Sigma x : S.U : s $}
      \AXC{\vdots}
      \UIC{$`G \seq t : S$}
      \AXC{\vdots}
      \UIC{$`G \seq u : U[t/x]$}
      \TIC{$`G \seq (t,u) : \Sigma x : S.U$}
      \AXC{\vdots}
      \UIC{$\Sigma x : S.U \sub \Sigma x : T.U$}
      \BIC{$`G \seq (t,u) : \Sigma x : T.U$}
    \end{prooftree}
    
    \case{LetSum}\quad
    \begin{prooftree}
      \AXC{\vdots}        
      \UIC{$`G \seq t : S $}
      \AXC{\vdots}
      \UIC{$S \sub V$}
      \BIC{$`G \seq t : V$}
      \AXC{$\mu~V \eqbi \Sigma x : T.U$}
      \AXC{\vdots}
      \UIC{$`G, x : T, u : U \seq v : V $}
      \TIC{$`G \seq \letml~(x, u) = t~\inml~v : V$}
    \end{prooftree}
    
    Par le lemme \ref{beta-mu}, on a $\mu~S \eqbi \Sigma x : T'.U'$,
    $T' \suba T$ et $U' \suba U$. Par restriction (lemme
    \ref{narrowing-a}) on a:

    \begin{prooftree}
      \AXC{\vdots}        
      \UIC{$`G \seq t : S $}
      \AXC{$\mu~S \eqbi \Sigma x : T'.U'$}
      \AXC{\vdots}
      \UIC{$`G, x : T', u : U' \seq v : V $}
      \TIC{$`G \seq \letml~(x, u) = t~\inml~v : V$}
    \end{prooftree}

    Si l'on applique la subsumption à droite c'est direct ($V' \sub V$).
    
    \case{LetIn}
    De façon similaire, par restriction on obtient la dérivation sans \irule{Coerce}.
    
    \case{App}\quad    
    \begin{prooftree}
      \AXC{\vdots}
      \UIC{$`G \seq f : T $}
      \AXC{\vdots}
      \UIC{$ T \sub \Pi x : V. W$}
      \BIC{$`G \seq f : \Pi x : V. W $}
      \noLine
      \UIC{$\mualgo(\Pi x : V.W) \eqbi \Pi x : V.W$}
      \AXC{\vdots}
      \UIC{$`G \seq u : U $}
      \AXC{\vdots}
      \UIC{$U \sub V$}
      \TIC{$`G \seq f u : W [ u / x ]$}
    \end{prooftree}
    
    Par le lemme \ref{beta-mu} on a $\mu(T) \eqbi \Pi x : V'.W'$ avec
    $V \suba V'$ et $W' \suba W$. Par la transitivité de la coercion on
    a: $U \suba V `^ V \suba V' "=>" U \suba V'$.
    On peut donc dériver:
    
    \begin{prooftree}
      \AXC{\vdots}
      \UIC{$`G \seq f : T $}
      \noLine
      \UIC{$\mualgo(T) \eqbi \Pi x : V'.W'$}
      \AXC{\vdots}
      \UIC{$`G \seq u : U $}
      \AXC{\vdots}
      \UIC{$U \sub V'$}
      \TIC{$`G \seq f u : W [ u / x ]$}
    \end{prooftree}
    
    \case{Subsum}\quad

    Dans le cas où l'on a un enchainement de règles \irule{Coerce}:
    \begin{prooftree}
      \AXC{\vdots}
      \UIC{$`G \seq t : S$}
      \AXC{\vdots}
      \UIC{$S \sub T$}
      \BIC{$`G \seq t : T$}
      \AXC{\vdots}
      \UIC{$T \sub U$}
      \BIC{$`G \seq t : U$}
    \end{prooftree}
    
    En utilisant la transitivité de la coercion on obtient:
    \begin{prooftree}
      \AXC{\vdots}
      \UIC{$`G \seq t : S$}
      \AXC{\vdots}
      \UIC{$S \sub U$}
      \BIC{$`G \seq t : U$}
    \end{prooftree}

  \end{induction}
  
\end{proof}

Par induction, on a donc montré que l'on peut réduire l'utilisation de la règle de
subsumption à la racine d'une dérivation. On peut ignorer sans perte de généralité 
l'utilisation de la coercion à la racine de la dérivation, 
on fera de toute façon un test de coercion entre le type inféré et le
type spécifié juste avant la réécriture. On considère maintenant le
système algorithmique comme présenté figure \ref{fig:typing-algo-rules}.

\begin{lemma}[Substitutivité de $\mualgo$]
  \label{substitutive-mu}
  Si $\mualgo(T) \eqbi \Pi y : U.V$ alors $\mualgo(T[u/x]) \eqbi \Pi y :
  U[u/x].V[u/x]$.
  Si $\mualgo(T) \eqbi \Sigma y : U.V$ alors $\mualgo(T[u/x]) \eqbi \Sigma y : U[u/x].V[u/x]$.
\end{lemma}

\begin{proof}
  On montre la propriété pour les produits, la preuve est similaire pour
  les sommes.

  Il suffit de suivre la définition de $\mualgo$.
  Si $T$ est de la forme $\subset{y}{V}{P}$ alors
  on a $\mualgo(V) \eqbi \Pi y : U.V$ et par induction
  $\mualgo(V[u/x]) \eqbi \Pi y : U[u/x].V[u/x]$.
  Il s'ensuit directement que $\mualgo(T[u/x]) \eqbi \Pi y :
  U[u/x].V[u/x]$.

  Si $T$ est différent d'un type sous-ensemble alors $\mualgo(T) = T$.
  Donc $T \eqbi \Pi y : U.V$. Il s'ensuit que $T$ est de la forme $\Pi y
  : U'.W'$ et donc $T[u/x] = \Pi y : U'[u/x].V'[u/x] =
  \mualgo(T[u/x])$. Par substitutivité de la conversion, il s'ensuit que 
  $\Pi y : U'[u/x].V'[u/x] \eqbi \Pi y : U[u/x].V[u/x]$.
\end{proof}

\begin{lemma}[Substitutivité de la coercion]
  \label{substitutive-coercion}
  Si $U \suba T$ alors pour tout $u$, $U[u/x] \suba T[u/x]$.
\end{lemma}

\begin{proof}
  \begin{induction}[subtyping-algo]
    \case{SubConv}
    Direct par préservation de l'équivalence $\eqbi$ par substitution.
    
    \case{SubProd}
    Par induction $U[u/x] \suba T[u/x]$ et $V[u/x] \suba W[u/x]$, donc
    $\Pi y : T[u/x].V[u/x] \suba \Pi y : U[u/x].W[u/x]$. La propriété
    est donc bien vérifiée.
    
    \case{SubSigma} Direct par induction.
    
    \case{SubSub} Par induction, $U'[u/x] \suba V[u/x]$. On applique
    \irule{SubLeft} pour obtenir $\subset{y}{U'[u/x]}{P} \suba V[u/x]$. 
    
    \case{SubRight} Direct par induction.
  \end{induction}
\end{proof}

\begin{lemma}[Substitutivité du typage]
  \label{substitutive-typing}
  Si $`G \typea u : U$ alors
  \[ \left\{ \begin{array}{lcl}
      `G, x : U, `D \typea t : T & "=>" & `G, `D[u/x] \typea t[u/x] :
      T[u/x] \\
      \wf `G, x : U, `D & "=>" & \wf `G, `D[u/x]
    \end{array}\right. \]
\end{lemma}

\begin{proof}
  \typenva
  Par induction mutuelle sur la dérivation de typage $`G, x : U, `D
  \typea t : T$ ou $\wf `G, x : U, `D$.
  
  \begin{induction}
    \case{WfEmpty} Trivial.

    \case{WfVar}
    Par induction sur $`D$.
    \begin{itemize}
    \item[\protect{$`D = []$}]
      On a alors $`G \typea U : s$ donc $\wf `G$ et triviallement, $\wf
      `G, `D[u/x]$.

    \item[\protect{$`D = `D', y : T$}]
      On a alors $`G, x : U, `D' \typea T : s$ et par induction
      $`G, `D'[u/x] \typea T[u/x] : s[u/x]$. Donc on peut appliquer
      \irule{WfVar} pour obtenir $\wf `G, `D'[u/x], T[u/x]$ soit
      $\wf `G, `D[u/x]$
    \end{itemize}
    
    \casetwo{PropSet}{Type} 
    La substitution n'a aucun effet et $`G, `D[u/x]$ est bien
    formé par induction.
    
    \case{Var}
    Par induction, $\wf `G, `D[u/x]$.
    Si $t `= x$ alors on a $T = U$ et $T[u/x] = U$ puisque $x$
    n'apparait pas dans $U$. On a donc bien $`G, `D[u/x] \typea t[u/x] = u :
    T[u/x] = U$. 
    Si $y : T `: `G$ alors on applique simplement \irule{Var}.
    Si $y : T `: `G$ alors $y : T[u/x] `: `D[u/x]$ et on obtient
    $`G, `D[u/x] \typea y[u/x] :  T[u/x]$ par \irule{Var}.
    
    \case{Prod}
    Par induction  $`G, `D[u/x] \typea T[u/x] : s_1[u/x]$ et
    $`G, `D[u/x], y : T[u/x] \typea M[u/x] : s_2[u/x]$. 
    On peut appliquer \irule{Prod} pour obtenir $`G, `D[u/x] \typea \Pi
    y : T[u/x].M[u/x] : s_2[u/x]$ soit $`G, `D[u/x] \typea (\Pi y :
    T.M)[u/x] : s_2[u/x]$.
    De façon similaire pour les autres cas.

    \case{App}
    On étudie le cas de l'application qui requiert un lemme supplémentaire.
    Par induction, $`G, `D[u/x] \typea f[u/x] : T[u/x]$ et
    $`G, `D[u/x] \typea a[u/x] : A[u/x]$. Si $\mualgo(T) \eqbi \Pi y :
    V.W$ alors $\mualgo(T[u/x]) \eqbi \Pi y : V[u/x].W[u/x]$ (lemme
    \ref{substitutive-mu}). Par induction, on a aussi $`G, `D[u/x] \typea
    A[u/x],V[u/x] : s$. Enfin, par substitutivité de la coercion on a $A[u/x]
    \suba V[u/x]$. On peut donc appliquer \irule{App} pour obtenir 
    $`G, `D[u/x] \typea (f[u/x] a[u/x]) : W[u/x][a[u/x]/y]$. Or $W[u/x][a[u/x]/y] =
    W[a/y][u/x]$. On a donc bien $`G, `D[u/x] \typea (f a)[u/x] :
    (W[a/y])[u/x]$.
    On a un raisonnement similaire pour \irule{LetSum}.
  \end{induction}
  
\end{proof}

\begin{lemma}[Substitutivité du typage avec coercion]
  \label{substitutive-typing-coercion}
  Si $`G, x : V \typea t : T \sub U$ et $`G \typea u : V$
  alors $`G \typed t[u/x] : T[u/x] \sub U[u/x]$.
\end{lemma}

\begin{proof}
  Par substitutivité du typage (\ref{substitutive-typing}) on a $`G \typed t[u/x] : T[u/x]$.
  Par le lemme précédent $T[u/x] \suba U[u/x]$.
\end{proof}

\begin{fact}[Symétrie de la coercion]
  La relation $\sub$ est symétrique.
\end{fact}

\begin{lemma}[Coercion et $\mu$]
  \label{coercion-mu}
  Si $\Pi x : X.Y \sub U$ alors $\mu(U) \eqbi \Pi x : X'.Y'$ et $X' \sub
  X$, $Y \sub Y'$.
  Si $\Sigma x : X.Y \sub U$ alors $\mu(U) \eqbi \Sigma x : X'.Y'$ et $X \sub
  X'$, $Y \sub Y'$.
  Pour tout $U$, $U \sub \mu(U)$.
\end{lemma}
\begin{proof}
  Par induction sur les dérivations de $\suba$ et la définition de $\mu$.
\end{proof}

\begin{lemma}[Coercion et conversion]
  \label{coercion-conversion}
  Si $S \eqbi T$ et $T \sub U$ alors $S \sub U$
\end{lemma}

\begin{proof}
  Par simple inspection des règles on voit que le jugement ne peut
  distinguer deux termes $\beta$-équivalents (ils ont forcement les
  mêmes formes normales de tête). \TODO{Check}
\end{proof}

\begin{lemma}[Transitivité de la coercion]
  \label{transitive-coercion}
  Pour tout $S, T, U$,  si $S \sub T$ et $T \sub U$ alors $S \sub U$.
\end{lemma}

\begin{proof}  
  \TODO{Dans \cite{Pierce:TypeSystems}, voir p. 420}
  On procède par élimination de la règle \irule{SubTrans} dans toute
  dérivation de $S \sub U$.
  
  \begin{induction}[subtyping-decl]

    \case{SubConv}\quad
    \begin{prooftree}
      \AXC{$S \eqbi T$}
      \UIC{$S \sub T$}
      \AXC{$T \sub U$}
      \BIC{$S \sub U$}
    \end{prooftree}
    
    Par le lemme précédent, on élimine trivialement \irule{SubTrans}.

    \case{SubProd}\quad
    \begin{prooftree}
      \AXC{$X' \sub X$}
      \AXC{$Y \sub Y'$}
      \BIC{$\Pi~X~Y \sub \Pi~X'~Y'$}
      \AXC{$\Pi~X'~Y' \sub U$}
      \BIC{$\Pi~X~Y \sub U$}
    \end{prooftree}
    
    Si $\Pi~X'~Y' \sub U$, alors il existe $S$, $T$, tel que $\mu(U)
    \eqbi \Pi~S~T$ et $S \sub X'$, $Y' \sub T$.
    Par induction, $S \sub X$ et $Y \sub T$ donc $\Pi~X~Y \sub \Pi~S~T$ 
    et enfin $\Pi~X~Y \sub U$.

    De facon équivalente pour le second cas.

    \case{SubSigma}\quad
    \begin{prooftree}
      \AXC{$X \sub X'$}
      \AXC{$Y \sub Y'$}
      \BIC{$\Sigma~X~Y \sub \Sigma~ X'~Y'$}
      \AXC{$\Sigma~X'~Y' \sub U$}
      \BIC{$\Sigma~X~Y \sub U$}
    \end{prooftree}
    
    Si $\Sigma~X'~Y' \sub U$, alors il existe $S$, $T$, tel que $\mu(U)
    \eqbi \Sigma~S~T$ et $X' \sub S$, $Y' \sub T$.
    Par induction, $X \sub S$ et $Y \sub T$ donc $\Sigma~X~Y \sub
    \Sigma~S~T$ et enfin $\Sigma~X~Y \sub U$ (lemme \ref{coercion-mu}).
    
    De façon équivalente pour le second cas.

    \case{SubProof}\quad
    \begin{prooftree}
      \AXC{$S \seq V$}
      \UIC{$S \seq \subset{x}{V}{P}$}
      \AXC{$\subset{x}{V}{P} \sub U$}
      \BIC{$S \sub U$}
    \end{prooftree}
    
    Si $\subset{x}{V}{P} \sub U$ alors $\mu(U) \eqbi V$.
    Comme $S \seq V$, par induction, $S \seq \mu(U)$ donc
    $S \sub U$.
    
    De façon équivalente pour le second cas.

    \case{SubSub}
    Cas identique à \irule{SubProof}
    
  \end{induction}
\end{proof}

\begin{corrolary}[Complétude de la coercion]
  \label{complete-coercion}
  Si $U \subd V$ alors $U \suba V$.
\end{corrolary}

\begin{proof}
  Les règles des deux systèmes sont les mêmes excepté \irule{SubTrans}
  qu'on peut éliminer dans le système algorithmique. De plus
  l'application restreinte de la conversion ne change pas les jugements
  dérivables (lemme \ref{conversion-coercion}).
\end{proof}

\begin{theorem}[Correction de la coercion]
  \label{correct-coercion}
  Si $U \suba V$ alors $U \subd V$.
\end{theorem}

\begin{proof}
  Les règles du système algorithmique sont un sous-ensemble des règles
  du système déclaratif.
\end{proof}

\begin{theorem}[Correction du typage]
  \label{correct-typing}
  Si $`G \typea t : T$ alors $`G \typed t : T$
\end{theorem}

\setboolean{displayLabels}{false}
\begin{proof}
  \begin{induction}[typing-algo]
  \item[\irule{WfEmpty},\irule{WfVar},\irule{PropSet},\irule{Var},\irule{Prod},\irule{Abs},
    \irule{LetIn}, \irule{Sigma}, \irule{Sum}:] règles inchangées.
    
    \case{LetSum}
    On a 
    \begin{prooftree}
      \LetSumA
    \end{prooftree}
    
    Par induction, $`G \typed t : S$, et par correction de la coercion $S \subd \Sigma x : T. U$.
    On peut donc dériver $`G \typed t : \Sigma x : T.U$ à l'aide de \irule{Coerce}.
    On peut directement appliquer \irule{LetSum} à cette prémisse et à
    l'hypothèse d'induction $`G, x : T, y : U \typed v : V$.
    
    \case{App} On a:
    \def\fCenter{\typea}
    \begin{prooftree}
      \AppA
    \end{prooftree}
    
    Par induction, $`G \typed f : T$, et $T \subd \Pi x : V. W$.
    On peut donc dériver $`G \typed f : \Pi x : V.W$ à l'aide de la
    subsumption.
    Par le lemme \ref{correct-coercion}, et l'hypothèse $`G \typed u :
    U$, on obtient $`G \typed u : V$ par \irule{Subsum}.
    Donc, par \irule{App}, on a bien $`G \typed f u : W[u/x]$.
  \end{induction}  
\end{proof}

\setboolean{displayLabels}{true}
\begin{lemma}[Complétude du typage]
  \label{complete-typing}
  $`G \typed t : T "=>" `E U, `G \subta t : U \sub T$
\end{lemma}

\begin{proof}
  \begin{induction}[typing-decl]
  \item[\irule{WfEmpty},\irule{WfVar},\irule{PropSet},\irule{Var},\irule{Prod},\irule{Abs},
    \irule{LetIn}, \irule{Sigma}, \irule{Sum}, \irule{Subset}:] règles inchangées.
    
    \case{App} On a 
    \typenvd
    \begin{prooftree}
      \App
    \end{prooftree}
    
    \typenva
    Par induction, $`E T, `G \typea f : T \suba \Pi x : V. W$ et
    $`E U, `G \subta u : U \sub V$.
    
    Si $T \suba \Pi x : V.W$ alors $\mualgo(T) \eqbi \Pi x : V'.W'$ avec
    $V \suba V'$ et $W' \suba W$.

    Par transivité de la coercion: $U \suba V'$, on peut donc dériver 
    \begin{prooftree}
      \TAX{App}
      {$`G \seq f : T \quad \mualgo(T) \eqbi \Pi x : V'. W'$}
      {$`G \seq u : U \quad `G \seq U, V' : s$}
      {$U \suba V'$}
      {$`G \seq (f u) : W' [ u / x ]$}
      {}
    \end{prooftree}
    
    Par substitutivité de la coercion (lemme
    \ref{substitutive-coercion}), $W'[u/x] \suba W[u/x]$, la propriété
    est donc bien vérifiée.

    \case{LetSum} On a
    \typenvd
    \begin{prooftree}
      \LetSum
    \end{prooftree}
    
    \typenva
    Par induction, $`E S, `G \typea t : S \suba \Sigma x : T.U$ et 
    $`E V', `G, x: T, y : U \typea v : V' \suba V$.
    On a $\mualgo(S) \eqbi \Sigma x : T'.U'$ avec $T' \suba T$ et $U'
    \suba U$. Par restriction on peut donc dériver $`G, x : T', y : U'
    \seq v : V'$.
    
    On a donc la dérivation suivante dans le système algorithmique:
    \begin{prooftree}
      \TAX{LetSum}
      {$`G \seq t : S$}
      {$\mualgo(S) \eqbi `S x : T'. U'$}
      {$`G, x : T', y : U' \seq v : V'$}
      {$`G \seq \letml~(x, u) = t~\inml~v : V'$}
      {}
    \end{prooftree}
    
    Comme $V' \suba V$, la propriété est vraie.

    \casetwo{Conv}{Subsum}
    Dans les deux cas on a inductivement $`E T', `G \typea t : T'
    \suba T$. Avec \irule{Conv} on a $T \eqbi S$, donc $T' \suba S$ par
    le lemme \ref{coercion-conversion}. Pour \irule{Subsum} on a $T \subd S$.
    Par complétude de la coercion, $T \suba S$ et par transitivité de la
    coercion, $T' \suba S$. La propriété est donc bien vérifiée dans les
    deux cas.
    
  \end{induction}
  
\end{proof}

On combine les théorêmes de correction et complétude pour obtenir la propriété suivante entre les deux systèmes:
\begin{corrolary}[Équivalence des systèmes déclaratifs et algorithmiques]
  $`G \typed t : T$ \ssi{} il existe $U$ tel que $`G \typea t : U$ et $U \suba T$.
\end{corrolary}

On a maintenant un système raffiné dérivant les même jugements (à
coercion près) que le système déclaratif. On veut en extraire un
algorithme de typage. Pour cela on doit pouvoir résoudre deux problèmes:
\begin{itemize}
\item\textbf{Vérification de type.} On donne $`G$,$t$ et $T$ et l'on doit
  décider si $`G \typea t : T$ ;
\item\textbf{Inférence de type.} On donne $`G$,$t$ et l'on doit trouver $T$ tel
  que $`G \typea t : T$ si c'est dérivable, sinon on échoue.
\end{itemize}
En pratique, la vérification a besoin de l'inférence puisque lorsqu'on
vérifie une application $f u : T$ on doit inférer le type de $f$.
On montre donc les théorêmes suivants:

\begin{theorem}[Décidabilité de l'inférence dans le système algorithmique]
  Le problème d'inférence $`G \typea t :~?$ est décidable.
\end{theorem}

\begin{proof}
  Il suffit d'observer que les règles de typage sont dirigées par la
  syntaxe du deuxième argument et permettent donc d'inférer un type pour
  tout terme. En lisant les prémisses de chaque règle de gauche à
  droite, on voit que l'inférence est décidable.
\end{proof}

\begin{theorem}[Décidabilité de $\typea$]
  La relation de typage $`G \typea t : T$ est décidable.
\end{theorem}
\begin{proof}
  Direct. On utilise le théorême précédent pour le cas de l'application.
\end{proof}

On a désormais un algorithme de typage pour notre système avec
coercions. Ce système est très libéral puisqu'il permet de considérer
des objets comme vérifiant des propriétés arbitraires sans les
montrer. Il nous faut maintenant remettre de la logique dans nos termes
pour s'assurer qu'ils sont corrects.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "subset-typing"
%%% LaTeX-command: "TEXINPUTS=\"style:$TEXINPUTS\" latex"
%%% End: 
