\section{Élaboration du système algorithmique et propriétés}
\typenva

Pour pouvoir implanter le typeur, il nous faut un système dirigé par la
syntaxe. Ce n'est pas le cas du système déclaratif, aussi bien pour le
typage que pour la coercion. On va donc raffiner ces systèmes dans
l'optique d'en extraire un algorithme. On note $\typea$ le jugement de
typage algorithmique défini figure \ref{fig:typing-algo-rules} page
\pageref{fig:typing-algo-rules} et
$\suba$ le jugement de coercion algorithmique présenté figure
\ref{fig:subtyping-algo-rules}. Ces deux systèmes sont quelque peu
éloignés des originaux, néanmoins nous allons montrer qu'ils sont
corrects et complets vis-à-vis de leurs géniteurs. La correction (si l'on
a une dérivation d'un jugement dans le système algorithmique, alors
c'est un jugement valide du système déclaratif) est le
sens le plus facile à montrer, nous allons donc commencer par là. On
décrira ensuite la méthode de construction des systèmes algorithmiques
pour aboutir d'une part au théorème de complétude qui montre qu'on peut dériver les
mêmes jugements (à coercion près) dans le système algorithmique que dans
le sytème déclaratif et d'autre part à la décidabilité du jugement de
typage algorithmique.

Il nous a fallu changer quelque peu les règles pour obtenir le système
algorithmique. En particulier, on a utilisé la fonction $\mu_0$ de \PVS{}
\cite{PVS-Semantics:TR} renommée $\mualgo$ (figure \ref{fig:mualgo-definition})
ici pour opérer des
\emph{décompréhensions}. Cette fonction efface les constructeurs de type
sous-ensemble en tête d'un type, par exemple: $\mualgo(\mysubset{f}{\nat
"->" \nat}{f~0 = 0}) = \nat "->" \nat$. On verra son utilité dans la suite.

\subsection{Notations}
On note $\hnf{x}$ la mise en forme normale de tête de $x$ selon la
réduction définie précédemment. On note $\hat{=}$ l'égalité
définitionelle.


\setboolean{displayLabels}{true}
\typenva
\typeaFig
\typemuaFig
\subtaFig

\subsection{Correction}
On montre tout d'abord la correction de la coercion algorithmique qui
sera nécessaire pour la correction du typage:

\begin{theorem}[Correction de la coercion]
  \label{correct-coercion}
  Si $U \suba V$ alors $U \subd V$.
\end{theorem}

\begin{proof}
  Les règles du système algorithmique sont un sous-ensemble des règles
  du système décla\-ratif, excepté pour la règle \irule{SubHnf}.
  On utilise \irule{SubConv} et \irule{SubTrans} pour montrer son
  admissibilité dans dans le système déclaratif.
  \begin{prooftree}
    \AXC{$U \eqbr \hnf{U}$}  
    \UIC{$U~\subd \hnf{U}$}
    \AXC{$\hnf{U}~\subd \hnf{T}$}
    \AXC{$\hnf{T} \eqbr T$}
    \UIC{$\hnf{T}~\subd T$}
    \BIC{$\hnf{U}~\subd T$}
    \BIC{$U \subd T$}
  \end{prooftree}
\end{proof}

On a besoin d'un lemme sur l'opération $\mualgo$ définie figure
\ref{fig:mualgo-definition}.

\begin{lemma}[$\mualgo$ et coercion]
  \label{mu-coercion}
  $T \suba \mualgo(T)$.
\end{lemma}

\begin{proof}
  Il suffit de suivre la définition de $\mualgo$. La mise en forme
  normale de tête est équivalente à l'utilisation de \irule{SubHnf} dans notre jugement de
  coercion. $\mualgo$ est en fait l'application répétée de la règle \irule{SubSub}.
\end{proof}

\begin{lemma}[Conservation des sortes par $\mu$]
  \label{mu-sorts}
  Si $`G \type S : s$ alors $`G \type \mu~S : s$
\end{lemma}

\begin{proof}
  Par le simple fait que si $S = \mysubset{x}{U}{P}$ alors $S : \Set$ et
  $U : \Set$ (par \irule{Subset}), sinon $S = \mu~S$.
\end{proof}

\begin{theorem}[Correction du typage]
  \label{correct-typing}
  Si $`G \typea t : T$ alors $`G \typed t : T$
\end{theorem}

\setboolean{displayLabels}{false}
\begin{proof}
  \begin{induction}[typing-algo]
  \item[- \irule{WfEmpty},\irule{WfVar},\irule{PropSet},\irule{Var},\irule{Prod},\irule{Abs},
    \irule{Sigma}, \irule{Sum}:] règles inchangées.
    
    \case{LetSum}
    On a 
    \begin{prooftree}
      \LetSumA
    \end{prooftree}
    
    Par induction, $`G \typed t : S$, et par le lemme \ref{mu-coercion}
    et la correction de la coercion $S \subd \Sigma x : T. U$.
    On peut donc dériver $`G \typed t : \Sigma x : T.U$ à l'aide de \irule{Coerce}.
    On peut directement appliquer \irule{LetSum} à cette prémisse et à
    l'hypothèse d'induction $`G, x : T, y : U \typed v : V$.
    
    \case{App} On a:
    \def\fCenter{\typea}
    \begin{prooftree}
      \AppA
    \end{prooftree}
    
    Par induction, $`G \typed f : T$, et $T \subd \Pi x : V. W$ par le
    lemme \ref{mu-coercion} et la correction de la coercion.
    On peut donc dériver $`G \typed f : \Pi x : V.W$ à l'aide de la règle
    \irule{Coerce}.
    Par le lemme \ref{correct-coercion}, et l'hypothèse $`G \typed u :
    U$, on obtient $`G \typed u : V$ par \irule{Coerce}.
    Donc, par \irule{App}, on a bien $`G \typed f u : W[u/x]$.
  \end{induction}  
\end{proof}

On a prouvé que notre système algorithmique était correct, c'est-à-dire
que ses jugements valides sont bien inclus dans ceux du système
déclaratif, il faut maintenant montrer qu'il les inclut tous (ou presque!).

\begin{subsubsection}{Notations}
On introduit la notation $`G \typea T, U : s$ pour $`G \typea T : s `^
`G \typea U : s$.
\end{subsubsection}

\subsection{Complétude et décidabilité}
On va maintenant repartir des systèmes déclaratifs pour montrer comment
l'on a construit les systèmes algorithmiques. 


On s'intéresse tout d'abord au jugement de coercion.
Pour rendre le jugement de coercion décidable, il faut traiter les règles
\irule{SubConv} et \irule{SubHnf} qu'on peut appliquer à n'importe quel 
moment et la règle \irule{SubTrans} qui n'est pas dirigée par la syntaxe (il faut
``deviner'' un type $T$). Le système de coercion algorithmique (figure
\ref{fig:subtyping-algo-rules}) est le même que le système
déclaratif (figure \ref{fig:subtyping-decl-rules}) mais où l'on n'applique 
\irule{SubConv} seulement si aucune autre règle ne
s'applique après avoir appliqué \irule{SubHnf} 
et sans la règle \irule{SubTrans}.

\subsubsection{Décidabilité et complétude de la coercion}
On va montrer que les deux systèmes de coercion sont équivalents vis-à-vis de la conversion. On montrera plus tard pourquoi on peut éliminer la
règle de transitivité.

On rappelle qu'on considère qu'on peut appliquer la normalisation de
tête \irule{ConvHnf} avant toute
application d'une règle de typage ou coercion. Ainsi on peut très bien
dériver $((\lambda x : \Set.x)~\nat) \suba \mysubset{x}{\nat}{P}$ puisque 
$\hnf{((\lambda x : \Set.x)~\nat)} = \nat$ et $\nat \suba
\mysubset{x}{\nat}{P}$ par \irule{SubProof} et \irule{SubConv}.

Il nous faut tout d'abord des lemmes d'inversion sur la conversion:
\begin{lemma}
  \label{conversion-pi}
  Si $\Pi x : T. U \eqbr S$ alors $\hnf{S} = \Pi x : T'. U'$ avec $T \eqbr T'$ et $U
  \eqbr U'$.
\end{lemma}
\begin{lemma}
  \label{conversion-sigma}
  Si $\Sigma x : T. U \eqbr S$ alors $\hnf{S} = \Sigma x : T'. U'$ avec $T \eqbr T'$ et $U
  \eqbr U'$.
\end{lemma}

On peut maintenant montrer:
\begin{lemma}[Conservation de la conversion par coercion]
  \label{conversion-coercion}
  Si $`G \typea T, U : s$ et $T \eqbr U$ alors $T \suba U$.
\end{lemma}
\begin{proof}
  Par induction sur la forme de $\hnf{T}$.
  
  \def\seq{\suba}.
  
  \begin{itemize}
  \item[$\hnf{T} = \Pi x : X.Y$:]
    Alors $\hnf{U} = \Pi y : V.W$ et $X \eqbr V$, $Y \eqbr W$
    d'après le lemme \ref{conversion-pi}.
    Par induction $X \sub Y$ et $V \sub W$. 
    On applique alors \irule{SubProd} à ces deux prémisses.
    
  \item[$\hnf{T} = \Sigma x : X.Y$:]
    Alors $\hnf{U} = \Sigma y : V.W$, avec $X \eqbr V$ et $Y \eqbr
    W$. Par induction et application de \irule{SubSigma}.
    
  \item[$\hnf{T} `= \mysubset{x}{X}{P}$:] 
    On a alors $\hnf{U} = \mysubset{x}{X'}{P'}$ avec $X \eqbr X'$, $P \eqbr
    P'$, et la propriété est vraie par \irule{SubLeft} et \irule{SubRight}:
    
    \begin{prooftree}
      \AXC{$X \sub X'$}
      \LeftLabel{\SubLeftRule}
      \UIC{$\mysubset{x}{X}{P} \sub X'$}
      \LeftLabel{\SubRightRule}
      \UIC{$\mysubset{x}{X}{P} \sub \mysubset{x}{X'}{P'}$}
    \end{prooftree}

  \item[Sinon:]
    On applique obligatoirement \irule{SubConv} et l'on a la prémisse $T
    \eqbr U$, c'est donc direct.
  \end{itemize}
\end{proof}

Il n'y a pas de problème d'identification de sortes dans ce système,
contrairement au système $\lambda~C_\leq$ de Gang Chen \cite{ChenPhD},
puisqu'on n'a pas de cumulativité. Le seul fait que les arguments sont
tous les deux sortés avec la même sorte
avant de dériver le jugement de coercion nous assure que l'on ne fera
pas d'identification erronée.

On va maintenant montrer que la règle \irule{SubTrans} est admissible
dans notre système algorithmique. On montre ceci en l'éliminant de toute
dérivation possible la faisant intervenir.

\typenva
Tout d'abord quelques lemmes nécessaires pour la preuve:
\begin{lemma}[Coercion et $\mualgo$]
  \label{coercion-mu}
  \quad
  \begin{itemize}
  \item Si $\Pi x : X.Y \sub U$ alors $\mualgo(U) = \Pi x : X'.Y'$ et $X' \sub
    X$, $Y \sub Y'$.
  \item Si $\Sigma x : X.Y \sub U$ alors $\mualgo(U) = \Sigma x : X'.Y'$ et $X \sub
    X'$, $Y \sub Y'$.
  \item Pour tout $S,U$, $S \sub \mualgo(U)$ \ssi~$S \sub U$.
  \end{itemize}
\end{lemma}
\begin{proof}
  Par induction sur les dérivations de $\suba$ et la définition de $\mualgo$.

  Dans le dernier cas, de gauche à droite on construit la dérivation en
  ajoutant des applications de \irule{SubProof} et dans l'autre sens on
  est assuré de trouver la preuve dans la dérivation même de $S \sub U$:
  si $U$ n'est pas de la forme sous-ensemble c'est direct. Sinon, on
  peut trouver dans la preuve (en partant de la racine) la première
  utilisation de la règle \irule{SubProof}. A partir de là, on cherche
  la première utilisation d'une règle autre que \irule{SubProof} ou 
  \irule{SubSub}. On a une dérivation de $S' \suba \mualgo(U)$, on
  peut réappliquer les règles \irule{SubSub} oubliées précédemment 
  pour obtenir la preuve de $S \suba \mualgo(U)$.
\end{proof}

\begin{lemma}[Coercion et conversion]
  \label{coercion-conversion}
  Si $`G \type S,T,U : s$, $S \eqbr T$ et $T \sub U$ alors $S \sub U$
\end{lemma}

\begin{proof}
  Par simple inspection des règles on voit que le jugement ne peut
  distinguer deux termes $\beta$-équivalents (ils ont forcément les
  mêmes formes normales de tête).
\end{proof}

\begin{lemma}[Coercion et formes normales de tête]
  \label{coercion-hnf}
  Si $T \suba U$ alors $\hnf{T}~\suba \hnf{U}$ est dérivable par une
  dérivation plus petite ou égale.
\end{lemma}

\begin{proof}
  \begin{induction}[subtyping-algo]

    \case{SubConv} Trivial.
    \case{SubHnf} On prend la dérivation en prémisse.
    \casetwo{SubProd}{SubSigma} $T$ et $U$ sont égaux à leurs formes normales
    de tête, direct.

    \case{SubProof}
    Par induction $\hnf{T}~\suba \hnf{V}$, on applique \irule{SubProof}
    \case{SubSub} idem.
  \end{induction}  
\end{proof}

\begin{lemma}[Transitivité de la coercion]
  \label{transitive-coercion}
  Pour tout $S, T, U$ tel que $`G \type S,T,U : s$ si
  $S \sub T$ et $T \sub U$ alors $S \sub U$.
\end{lemma}

\begin{proof} 
  %\TODO{Dans \cite{Pierce:TypeSystems}, voir p. 420}
  On procède par élimination de la règle \irule{SubTrans} dans toute
  dérivation de $S \sub U$.
  Par induction sur l'ordre lexicographique $< depth(S \sub T) +
  depth(T \sub U), depth(S \sub U) >$.
  On peut supposer sans perte de généralité qu'il n'y a pas
  d'applications successive de la règle \irule{SubHnf} dans nos
  dérivations, par idempotence de la mise en forme normale de tête.
  
  \begin{induction}

    \casetwo{SubConv}{*}\quad
    \begin{prooftree}
      \AXC{$S \eqbr T$}
      \UIC{$S \sub T$}
      \AXC{$T \sub U$}
      \BIC{$S \sub U$}
    \end{prooftree}
    
    Par le lemme \ref{coercion-conversion}, on élimine trivialement \irule{SubTrans}.

    \casetwo{SubHnf}{*}\quad
    \begin{prooftree}
      \AXC{$\hnf{S}~\sub \hnf{T}$}
      \UIC{$S \sub T$}
      \AXC{$T \sub U$}
      \BIC{$S \sub U$}
    \end{prooftree}

    Par le lemme \ref{coercion-hnf}, il existe une dérivation de 
    $\hnf{T} \sub \hnf{U}$ de taille plus petite ou égale à la
    dérivation de $T \sub U$ on peut donc se ramener au cas:

    \begin{prooftree}
      \AXC{$\hnf{S}~\sub \hnf{T}$}
      \UIC{$S \sub T$}
      \AXC{$\hnf{T} \sub \hnf{U}$}
      \UIC{$T \sub U$}
      \BIC{$S \sub U$}
    \end{prooftree}

    
    Par cas sur la dérivation de $\hnf{S} \sub \hnf{T}$
    \begin{induction}
      \case{SubConv}\quad
      \begin{prooftree}
        \AXC{$\hnf{S} \eqbr \hnf{T}$}
        \UIC{$\hnf{S}~\sub \hnf{T}$}
        \UIC{$S \sub T$}
        \AXC{$\hnf{T} \sub \hnf{U}$}
        \UIC{$T \sub U$}
        \BIC{$S \sub U$}
      \end{prooftree}
      
      Par le lemme \ref{coercion-conversion}.
      
      \case{SubProd}\quad
      \begin{prooftree}
        \AXC{$C \sub A$}
        \AXC{$B \sub D$}
        \BIC{$\hnf{S}=\Pi x : A.B~\sub \Pi x : C.D = \hnf{T}$}
        \UIC{$S \sub T$}
        \AXC{$\hnf{T} = \Pi x : C.D \sub \hnf{U}$}
        \UIC{$T \sub U$}
        \BIC{$S \sub U$}
      \end{prooftree}
    
      Par cas sur la dérivation de $\Pi x : C.D \sub \hnf{U}$.
      \begin{itemize}
        \case{SubConv} Trivial.
        \case{SubProd} Alors on a
        \begin{prooftree}
          \AXC{$E \sub C$}
          \AXC{$D \sub F$}
          \BIC{$\Pi x : C.D \sub \Pi x : E.F$}
        \end{prooftree}
        
        On a donc la dérivation:
        \begin{prooftree}
          \AXC{$E \sub C$}\AXC{$C \sub A$}
          \BIC{$E \sub A$}
          
          \AXC{$B \sub D$}\AXC{$D \sub F$}
          \BIC{$B \sub F$}
          \BIC{$\hnf{S} = \Pi x : A.B \sub \Pi x : E.F = \hnf{U}$}
          \UIC{$S \sub U$}
        \end{prooftree}
        
        La taille des dérivations de $E \sub C$, $C \sub A$ et $B \sub
        D$, $D \sub F$ étant plus
        petites que $S \sub T$ et $T \sub U$, on élimine bien la transitivité dans ce cas.

        \case{SubProof} On a:
        \begin{prooftree}
          \AXC{$\Pi x : C.D \sub E$}
          \UIC{$\Pi x : C.D \sub \mysubset{y}{E}{P}$}
        \end{prooftree}

        Par induction, on a:

        \begin{prooftree}
          \AXC{$\Pi x : A.B \sub \Pi x : C.D$}
          \AXC{$\Pi x : C.D \sub E$}
          \BIC{$\Pi x : A.B \sub E$}          
          \UIC{$\hnf{S} = \Pi x : A.B \sub \mysubset{y}{E}{P} = \hnf{U}$}
          \UIC{$S \sub U$}
        \end{prooftree}
        
        Car $\Pi x : C.D \sub E$ est une dérivation plus petite que $T
        \sub U$.
      \end{itemize}
            
      \case{SubSigma} De façon équivalente au produit.
    
      \case{SubProof}\quad
      \begin{prooftree}
        \AXC{$\hnf{S} \sub C$}
        \UIC{$\hnf{S}~\sub \mysubset{y}{C}{P} = \hnf{T}$}
        \UIC{$S \sub T$}
        \AXC{$\mysubset{y}{C}{P} = \hnf{T} \sub \hnf{U}$}
        \UIC{$T \sub U$}
        \BIC{$S \sub U$}
      \end{prooftree}
      Encore une fois, par cas sur la dérivation de $\mysubset{y}{C}{P}
      = \hnf{T} \sub \hnf{U}$:
      \begin{itemize}
        \case{SubConv} Trivial.
        \case{SubSub} On a:
        \begin{prooftree}
          \AXC{$C \sub \hnf{U}$}
          \UIC{$\mysubset{y}{C}{P} = \hnf{T} \sub \hnf{U}$}
        \end{prooftree}
        
        Par induction, on peut donc dériver:
        \begin{prooftree}
          \AXC{$\hnf{S} \sub C$}
          \AXC{$C \sub \hnf{U}$}
          \BIC{$\hnf{S} \sub \hnf{U}$}
          \UIC{$S \sub U$}
        \end{prooftree}
        
        Les dérivations $\hnf{S} \sub C$ et $C \sub \hnf{U}$ étant bien
        plus petites que $S \sub T$ et $T \sub U$.     
      \end{itemize}
      
      \case{SubSub} De même:
      \begin{prooftree}
        \AXC{$A \sub \hnf{T}$}
        \UIC{$\hnf{S} = \mysubset{y}{A}{P}~\sub \hnf{T}$}
        \UIC{$S \sub T$}
        \AXC{$\hnf{T} \sub \hnf{U}$}
        \UIC{$T \sub U$}
        \BIC{$S \sub U$}
      \end{prooftree}

      Se réecrit en:
      \begin{prooftree}
        \AXC{$A \sub \hnf{T}$}
        \AXC{$\hnf{T} \sub \hnf{U}$}
        \BIC{$A \sub \hnf{U}$}
        \UIC{$\hnf{S} = \mysubset{y}{A}{P}~\sub \hnf{U}$}
        \UIC{$S \sub U$}
      \end{prooftree}
    \end{induction}
  
    On peut faire le même raisonnement par cas sur la dérivation de
    $\hnf{T} \sub \hnf{U}$. On peut donc se restreindre aux cas ou l'on
    n'utilise plus la règle \irule{SubHnf} dans les prémisses de \irule{SubConv}.
        
    Les cas restants se montrent de façon similaire à leurs équivalents
    dans la preuve pour le cas \irule{SubHnf}. Par exemple pour le
    produit:

    
    \case{SubProd}\quad
    \begin{prooftree}
      \AXC{$C \sub A$}
      \AXC{$B \sub D$}
      \BIC{$\Pi x : A.B \sub \Pi x : C.D$}
      \AXC{$\Pi x : C.D \sub U$}
      \BIC{$\Pi x : A.B \sub U$}
    \end{prooftree}

    On n'a seulement à traiter le cas ou $\Pi x : C.D \sub U$ est dérivé par
    \irule{SubProd} ou \irule{SubProof}.
    \begin{itemize}
      \case{SubProd} Alors on a
        \begin{prooftree}
          \AXC{$E \sub C$}
          \AXC{$D \sub F$}
          \BIC{$\Pi x : C.D \sub \Pi x : E.F$}
        \end{prooftree}
        
        On a donc la dérivation:
        \begin{prooftree}
          \AXC{$E \sub C$}\AXC{$C \sub A$}
          \BIC{$E \sub A$}
          
          \AXC{$B \sub D$}\AXC{$D \sub F$}
          \BIC{$B \sub F$}
          \BIC{$S = \Pi x : A.B \sub \Pi x : E.F = U$}
        \end{prooftree}
        
        La taille des dérivations de $E \sub C$, $C \sub A$ et $B \sub
        D$, $D \sub F$ étant plus
        petites que $\Pi x : A.B \sub \Pi x : C.D$ et $\Pi x : C.D \sub
        \Pi x : E.F$, on élimine bien la transitivité dans ce cas.

        \case{SubProof} On a:
        \begin{prooftree}
          \AXC{$\Pi x : C.D \sub E$}
          \UIC{$\Pi x : C.D \sub \mysubset{y}{E}{P}$}
        \end{prooftree}

        Par induction, on a:

        \begin{prooftree}
          \AXC{$\Pi x : A.B \sub \Pi x : C.D$}
          \AXC{$\Pi x : C.D \sub E$}
          \BIC{$\Pi x : A.B \sub E$}          
          \UIC{$S = \Pi x : A.B \sub \mysubset{y}{E}{P} = U$}
        \end{prooftree}
        
        Car $\Pi x : C.D \sub E$ est une dérivation plus petite que $T
        \sub U$.
      \end{itemize}



    
  \end{induction}
\end{proof}

\begin{corrolary}[Complétude de la coercion]
  \label{complete-coercion}
  Si $U \subd V$ alors $U \suba V$.
\end{corrolary}

\begin{proof}
  Les règles des deux systèmes sont les mêmes excepté \irule{SubTrans}
  qui est admissible dans le système algorithmique. De plus
  l'application restreinte de la conversion ne change pas les jugements
  dérivables (lemme \ref{conversion-coercion}).
\end{proof}

En conséquence $\subd$ et $\suba$ sont équivalentes. Le système
d'inférence de $\suba$ donne donc un algorithme pour décider de la relation
de coercion. L'indéterminisme entre les règles \irule{SubProof} et
\irule{SubSub} ne pose pas de problème: on peut laisser le choix à 
l'implantation puisque le système est confluent. \irule{SubHnf}
formalise le fait qu'on peut avoir à réduire en tête avant d'appliquer
les autres règles (pour obtenir un produit, une somme ou un sous-ensemble).

\subsubsection{Décidabilité et complétude du typage}
Le système algorithmique correspond au système déclaratif où l'on a enlevé la règle
de coercion \irule{Coerce} et changé certaines règles pour obtenir un système décidable
(voir figure \ref{fig:typing-algo-rules}).
On va procéder de façon similaire à l'élimination de la transitivité
pour montrer que la règle \irule{Coerce} n'est plus nécessaire dans le
système algorithmique. On va montrer en fait que
toute dérivation de typage utilisant \irule{Coerce} peut se réécrire en
une dérivation n'utilisant cette règle qu'à sa racine.

% \paragraph{Sommes dépendantes}
% On veut pouvoir faire le plus d'inférence possible dans notre sytème
% algorithmique, on a donc introduit une règle \irule{SumInf} qui ne force
% pas à annoter les paires. Dans le cas ou le terme n'est pas annoté, on
% considère donc que la somme n'est pas dépendante. En effet on remarque
%  qu'il n'est pas possible d'inférer le type $U$ à partir du seul terme $(t, u)$. Cela
% nécessiterait de résoudre un problème d'unification d'ordre supérieur
% auquel il n'y a pas de solution la plus générale. 
% On a donc dans le système algorithmique deux règles pour les sommes, 
% dont une (\irule{SumDep}) permettant d'annoter le terme avec le type $U$ recherché. 

\paragraph{\'Elimination de la coercion}
\typenva
On veut maintenant montrer la complétude de notre système. Dans un
système à sous-typage, le théorème correspondant est parfois nommé
typage minimal ``\emph{minimal typing}'' puisque son énoncé revient à
dire que tout terme a un type minimal dans les deux systèmes. En effet
notre théorème est le suivant:
$`G \typed t : T "=>" `G \typea t : U \suba T$. Le typage algorithmique
assigne bien un seul type à un terme $t$ mais comme on a des coercions, le
type inféré $U$ peut être un peu différent du type $T$. Dans notre cas
particulier $U$ sera certainement un type moins riche que $T$ (par
exemple $\nat$ par rapport à $\mysubset{x}{\nat}{P}$). Lorsque l'on
développera des programmes, on donnera une spécification forte et l'on
fera une coercion entre le type inféré et la spécification pour obtenir
au final (après réécriture dans \Coq) un terme du type $T$ le plus riche.
On a besoin de quelques lemmes pour montrer que notre système où
\irule{Coerce} a été éliminé est complet:

\begin{lemma}[$\beta$-equivalence et $\mualgo$]
  \label{beta-mu}
  Si $X \sub Y$ et $\mualgo(Y) = \Sigma x : T.U$ alors $\mualgo(X) = \Sigma x : T'.U'$
  et $T' \sub T$, $U' \sub U$.
  Si $X \sub Y$ et $\mualgo(Y) = \Pi x : T.U$ alors $\mualgo(X) = \Pi x :
  T'.U'$ et $T \sub T'$, $U' \sub U$.
\end{lemma}
\begin{proof}
  Par induction sur la dérivation de coercion, on fait le cas pour $\Sigma$.
  \begin{induction}  
    \case{SubConv} Trivial, puisqu'on aura $\mualgo(X) = \mualgo(Y)$.

    \case{SubHnf} Trivial puisque pour tout $x$, $\mualgo(x) =
    \mualgo(\hnf{x})$.
    
    \case{SubProd} Impossible, $\mualgo$ ne traversant pas les produits.

    \case{SubSigma} Direct, on a une dérivation de $\Sigma x : T'. U'
    \sub \Sigma x : T.U$.
    
    \case{SubLeft} Ici, $Y `= \mysubset{x}{V}{P}$, on peut donc déduire que
    $\mualgo(Y) = \mualgo(V) = \Sigma x : T.U$. On 
    applique l'hypothèse de récurrence avec $X \sub V$ et on obtient:
    $\mualgo(X) = \Sigma x : T'.U' `^ T' \sub T `^ U' \sub U$.

    \case{SubRight} Ici, $X `= \mysubset{x}{V}{P}$. Par induction, 
    $\mualgo(V) = \mualgo(X) = \Sigma x : T'.U' `^ T' \sub T `^ U' \sub U$.
  \end{induction}
\end{proof}

\begin{lemma}[Bonne formation des contextes]
  \label{wf-contexts-a}
  Si $`G \type t : T$ alors $\typewf `G$.
\end{lemma}
\begin{proof}
  \inductionon{typing-decl}
\end{proof}

\begin{fact}[Inversion du jugement de bonne formation]
  \label{inversion-wf-a}
  Si $\typewf `G, x : U$ alors il existe $s$, $`G \type U : s$ et $s `: \setproptype$.
\end{fact}

\begin{lemma}[Affaiblissement]
  \label{weakening-a}
  Si $`G, `D \type t : T$ alors pour tout $x : S `; `G, `D$ tel que
  $\wf `G, x : S, `D$, $`G, x : S, `D \type t : T$
\end{lemma}

\begin{proof}
  \begin{induction}[typing-decl]
    \case{PropSet} Trivial.

    \case{Var}
    On a $x : S `; `G, `D$, donc $`G, x : S, `D \type y : T$ est toujours dérivable.
    
    \case{Prod}
    Par induction $`G, x : S, `D \type T : s1$ et $`G, x : S, `D,
    y : T \type U : s2$. On applique \irule{Prod} pour obtenir 
    $`G, x : S, `D \type \Pi x : T.U : s2$. De même pour le reste des règles.
  \end{induction}
\end{proof}  

La restriction montre que notre notion de coercion est correcte
vis-à-vis du typage. On peut dériver les mêmes jugements dans des
contextes où les variables ont des types équivalents. Ici la taille des
dérivations ne change pas.

\begin{lemma}[Restriction]
  \label{narrowing-a}
  \[ `G \seq S, S' : s, S' \sub S "=>" 
  \left\{ \begin{array}{lcl}
      \typewf `G, x : S, `D & "=>" & \typewf `G, x : S', `D \\
      & `^{} & \\
      `G, x : S, `D \seq t : T & "=>" & `G, x : S', `D \seq t : T' \suba T 
    \end{array}
  \right. \]
\end{lemma}

\begin{proof}
  On peut remarquer que si $T `: \setproptype$ alors $T'$ doit être égal
  à $T$ par définition de la coercion.

  Par induction sur la taille de la dérivation de typage ou de bonne formation.
    
  \begin{induction}
    \case{WfEmpty} Trivial.
    
    \case{WfVar} 
    La conclusion est $\typewf `G, x : S, `D$
    
    \begin{induction}[text=Par induction sur la taille de $`D$]
    \item[\protect{$`D = []$}]
      La racine de la dérivation est de la forme:
      \begin{prooftree}
        \UAX{WfVar}
        {$`G \type S : s$}
        {$\wf `G, x : S$}
        {$s `: \setproptype$}
      \end{prooftree}
      On a donc $`G \type S' : s$, et par \irule{WfVar}, $\typewf `G, x : S'$.  
      
    \item[\protect{$`D `= `D', y : U$}]
      La racine de la dérivation est de la forme:
      \begin{prooftree}
        \UAX{WfVar}
        {$`G, x : S, `D' \type U : s$}
        {$\wf `G, x : S, `D', y : U$}
        {$s `: \setproptype$}
      \end{prooftree}
      Par induction sur la dérivation de typage $`G, x : S', `D' \seq U : s$,
      on a donc bien $\typewf `G, x : S', `D', y : U$ par \irule{WfVar}.
    \end{induction}
    
    \case{PropSet}
    Par induction, $\typewf `G, x : S', `D$, on applique simplement la règle.
    
    \case{Var}
    Par induction, $\typewf `G, x : S', `D$. La seule différence avec le
    contexte précédent est le type associé à $x$, donc si $t \not= x$, on
    peut simplement réappliquer \irule{Var}. Si $t `= x$ on a la
    dérivation:

    \begin{prooftree}
      \BAX{Var}
      {$\wf `G, x : S', `D$}
      {$x : S' `: `G$}
      {$`G, x : S', `D \seq x : S'$}
      {}
    \end{prooftree}
    
    On a bien $S' \suba S$, la propriété est donc bien vérifiée.
    
    \case{Prod} 
    Par induction, $`G, x : S', `D \type T : s1$ et $`G, x : S', `D
    y : T \seq U : s2$. On applique \irule{Prod} pour obtenir 
    $`G, x : S' \type \Pi x : T.U : s2$. De même pour le reste des règles.
  \end{induction}
\end{proof}

Il nous faut montrer des lemmes faisant intervenir la substitution pour
pouvoir prouver la complétude.
\begin{lemma}[Substitutivité de $\mualgo$]
  \label{substitutive-mu}
  Si $\mualgo(T) = \Pi y : U.V$ alors $\mualgo(T[u/x]) = \Pi y :
  U[u/x].V[u/x]$.
  Si $\mualgo(T) = \Sigma y : U.V$ alors $\mualgo(T[u/x]) = \Sigma y : U[u/x].V[u/x]$.
\end{lemma}

\begin{proof}
  On montre la propriété pour les produits, la preuve est similaire pour
  les sommes. Par induction sur la taille de $T$.

  Il suffit de suivre la définition de $\mualgo$.
  Si $T$ est de la forme $\mysubset{y}{V}{P}$ alors
  on a $\mualgo(V) = \Pi y : U.V$ et par induction
  $\mualgo(V[u/x]) = \Pi y : U[u/x].V[u/x]$.
  Il s'ensuit directement que $\mualgo(T[u/x]) = \Pi y :
  U[u/x].V[u/x]$.

  Si $T$ est différent d'un type sous-ensemble alors $\mualgo(T) = T$.
  Donc $T \eqbr \Pi y : U.V$. Il s'ensuit que $T$ est de la forme $\Pi y
  : U'.W'$ et donc $T[u/x] = \Pi y : U'[u/x].V'[u/x] =
  \mualgo(T[u/x])$. Par substitutivité de la conversion, il s'ensuit que 
  $\Pi y : U'[u/x].V'[u/x] \eqbr \Pi y : U[u/x].V[u/x]$.
\end{proof}

\begin{lemma}[Substitutivité de la coercion]
  \label{substitutive-coercion}
  Si $U \suba T$ alors pour tout $u$, $U[u/x] \suba T[u/x]$.
\end{lemma}

\begin{proof}
  \begin{induction}[subtyping-algo]
    \case{SubConv}
    Direct par préservation de l'équivalence $\eqbr$ par substitution.
    
    \case{SubHnf}
    Par induction, $(\hnf{U})[u/x] \suba (\hnf{T})[u/x]$. 
    Par le lemme \ref{coercion-hnf}, $\hnf{((\hnf{U})[u/x])} \suba
    \hnf{((\hnf{T})[u/x])}$. 
    Donc $\hnf{U[u/x]}~\suba \hnf{T[u/x]}$ et par \irule{SubHnf}, 
    $U[u/x] \suba T[u/x]$.

    \case{SubProd}
    Par induction $U[u/x] \suba T[u/x]$ et $V[u/x] \suba W[u/x]$, donc
    $\Pi y : T[u/x].V[u/x] \suba \Pi y : U[u/x].W[u/x]$. La propriété
    est donc bien vérifiée.
    
    \case{SubSigma} Direct par induction.
    
    \case{SubSub} Par induction, $U'[u/x] \suba V[u/x]$. On applique
    \irule{SubLeft} pour obtenir $\mysubset{y}{U'[u/x]}{P} \suba V[u/x]$. 
    
    \case{SubRight} Direct par induction.
  \end{induction}
\end{proof}

\begin{lemma}[Substitutivité du typage]
  \label{substitutive-typing}
  Si $`G \typea u : U$ alors
  \[ \left\{ \begin{array}{lcl}
      `G, x : U, `D \typea t : T & "=>" & `G, `D[u/x] \typea t[u/x] : T[u/x] \\
      \wf `G, x : U, `D & "=>" & \wf `G, `D[u/x]
    \end{array}\right. \]
\end{lemma}

\begin{proof}
  \typenva
  Par induction mutuelle sur la dérivation de typage $`G, x : U, `D
  \typea t : T$ ou $\wf `G, x : U, `D$.
  
  \begin{induction}
    \case{WfEmpty} Trivial.

    \case{WfVar}
    Par induction sur $`D$.
    \begin{itemize}
    \item[\protect{$`D = []$}]
      On a alors $`G \typea U : s$ donc $\wf `G$ et trivialement, $\wf
      `G, `D[u/x]$.

    \item[\protect{$`D = `D', y : T$}]
      On a alors $`G, x : U, `D' \typea T : s$ et par induction
      $`G, `D'[u/x] \typea T[u/x] : s[u/x] = s$. Donc on peut appliquer
      \irule{WfVar} pour obtenir $\wf `G, `D'[u/x], y : T[u/x]$ soit
      $\wf `G, `D[u/x]$
    \end{itemize}
    
    \case{PropSet}
    La substitution n'a aucun effet et $`G, `D[u/x]$ est bien
    formé par induction.
    
    \case{Var}
    Par induction, $\wf `G, `D[u/x]$.
    Si $t `= x$ alors on a $T = U$ et $T[u/x] = U$ puisque $x$
    n'apparaît pas dans $U$. On a donc $`G, `D[u/x] \typea t[u/x] = u :
    T[u/x] = U$, qui peut s'obtenir par affaiblissement de $`G \typea u
    : U$. 
    Si $y : T `: `G$ alors on applique simplement \irule{Var}.
    Si $y : T `: `D$ alors $y : T[u/x] `: `D[u/x]$ et on obtient
    $`G, `D[u/x] \typea y[u/x] :  T[u/x]$ par \irule{Var}.
    
    \case{Prod}
    Par induction  $`G, `D[u/x] \typea T[u/x] : s_1[u/x]$ et
    $`G, `D[u/x], y : T[u/x] \typea M[u/x] : s_2[u/x]$. 
    On peut appliquer \irule{Prod} pour obtenir $`G, `D[u/x] \typea \Pi
    y : T[u/x].M[u/x] : s_2[u/x]$ soit $`G, `D[u/x] \typea (\Pi y :
    T.M)[u/x] : s_2[u/x]$.
    De façon similaire pour les autres cas.

    \case{App}
    On étudie le cas de l'application qui requiert un lemme supplémentaire.
    Par induction, on a $`G, `D[u/x] \typea f[u/x] : T[u/x]$ et
    $`G, `D[u/x] \typea a[u/x] : A[u/x]$. Si $\mualgo(T) = \Pi y :
    V.W$ alors $\mualgo(T[u/x]) = \Pi y : V[u/x].W[u/x]$ (lemme
    \ref{substitutive-mu}). Par induction, on a aussi $`G, `D[u/x] \typea
    A[u/x],V[u/x] : s$. Enfin, par substitutivité de la coercion on a $A[u/x]
    \suba V[u/x]$. On peut donc appliquer \irule{App} pour obtenir 
    $`G, `D[u/x] \typea (f[u/x]~a[u/x]) : W[u/x][a[u/x]/y]$. Or
    $W[u/x][a[u/x]/y] = W[a/y][u/x]$ ($y `; \freevars{u}$). On a donc bien $`G, `D[u/x] \typea (f~a)[u/x] :
    (W[a/y])[u/x]$.
    On a un raisonnement similaire pour \irule{LetSum}.
  \end{induction}
  
\end{proof}

\begin{lemma}[Substitutivité du typage avec coercion]
  \label{substitutive-typing-coercion}
  Si $`G, x : V \typea t : T \sub U$ et $`G \typea u : V$
  alors $`G \typed t[u/x] : T[u/x] \sub U[u/x]$.
\end{lemma}

\begin{proof}
  Par substitutivité du typage (\ref{substitutive-typing}) on a $`G \typed t[u/x] : T[u/x]$.
  Par le lemme précédent $T[u/x] \suba U[u/x]$.
\end{proof}

On a maintenant tout les ingrédients pour montrer la complétude de notre
système de typage vis-à-vis du système déclaratif.

\setboolean{displayLabels}{true}
\begin{theorem}[Complétude du typage]
  \label{complete-typing}
  Si $`G \typed t : T$ alors $`E U, `G \typea t : U \sub T$.
  Si $\typewf `G$ dans le système déclaratif alors $\typewf `G$ dans le
  système algorithmique.
\end{theorem}

\begin{proof}
  \typenva
  Par induction mutuelle sur les dérivations de typage et bonne formation.
  \begin{induction}
    \case{WfEmpty} Trivial.
    
    \case{WfVar}\quad
    \typenvd
    \begin{prooftree}
      \WfVar
    \end{prooftree}
    Par induction $`E s', `G \typea A : s' \sub s$. On a forcément $s' =
    s$ puisque les sortes ne sont en relation qu'avec elles-mêmes.
    On applique \irule{WfVar} pour obtenir $\typewf `G, x : A$.
    
    \case{PropSet} Trivial.

    \case{Var}\quad
    \typenvd
    \begin{prooftree}
      \Var
    \end{prooftree}
    Par induction $\typewf `G$ et $x : A `: `G$ , direct par
    \irule{Var}.
    
    \case{Prod}\quad
    \typenvd
    \begin{prooftree}
      \Prod
    \end{prooftree}
    
    Direct par induction et le fait qu'une sorte ne peut être en relation
    qu'avec elle même.
        
    \case{Abs} \quad
    \typenvd
    \begin{prooftree}
      \Abs
    \end{prooftree}
    Par induction $`E U', `G, x : T \typea M : U' \suba U$.
    Or cela implique $`G, x : T \typea U' : s$, donc on peut dériver
    $`G \typea \Pi x : T.U' : s$. On a donc bien $`G \typea \lambda x :
    T.M : \Pi x : T.U' \suba \Pi x : T.U$.
    
    \case{App} On a 
    \typenvd
    \begin{prooftree}
      \App
    \end{prooftree}
    
    \typenva
    Par induction, $`E T, `G \typea f : T \suba \Pi x : V. W$ et
    $`E U, `G \subta u : U \sub V$.
    
    Si $T \suba \Pi x : V.W$ alors $\mualgo(T) = \Pi x : V'.W'$ avec
    $V \suba V'$ et $W' \suba W$ (lemme \ref{beta-mu}).

    Par transitivité de la coercion: $U \suba V'$, on peut donc dériver 
    \begin{prooftree}
      \TAX{App}
      {$`G \seq f : T \quad \mualgo(T) = \Pi x : V'. W'$}
      {$`G \seq u : U \quad `G \seq U, V' : s$}
      {$U \suba V'$}
      {$`G \seq (f u) : W' [ u / x ]$}
      {}
    \end{prooftree}
    
    Par substitutivité de la coercion (lemme
    \ref{substitutive-coercion}), $W'[u/x] \suba W[u/x]$, la propriété
    est donc bien vérifiée.
    
    \case{Sigma}\quad
    \typenvd
    \begin{prooftree}
      \SigmaR
    \end{prooftree}

    Par induction $`E s', `G \typea T : s' \sub s$ et $`E s'', `G, x : T 
    \typea U : s' \suba s$ où $s `: \{ \Prop, \Set \}$. Encore une fois  
    les sortes $s$, $s'$ et $s''$ doivent être égales. C'est direct
    par \irule{Sigma}.

    \case{Sum}\quad
    \typenvd
    \begin{prooftree}
      \Sum
    \end{prooftree}
    \typenva
    
    Ici, l'annotation nous force à utiliser le jugement de coercion.
    Par induction, $`E s', \Sigma x : T.U : s' \suba s$, $`E T', `G
    \type t : T' \suba T$ et $`E U', `G \typea u : U' \suba U[t/x]$.
    On peut montrer $`G \type \Sigma x : T'.U : s$.
    En effet, par inversion de $`G \seq \Sigma x : T.U : s$ on a
    $`G, x : T \seq U : s$ et par restriction ($T' \sub T$), $`G, x : T' \seq
    U : s$.
    Comme $T' \suba T$ on obtient $\Sigma x : T'.U \suba \Sigma x : T.U$.
    On peut donc dériver:
    \begin{prooftree}
      \QAX{SumDep}
      {$`G \seq t : T'$}
      {$`G \seq u : U'$}
      {$`G \seq U[t/x], U' : s \quad U' \suba U[t/x]$}
      {$`G \seq \Sigma x : T'.U : s$}
      {$`G \seq (x \coloneqq~t, u : U) : \Sigma x : T'.U$}
      {}
    \end{prooftree} 
        
    \case{LetSum} On a
    \typenvd
    \begin{prooftree}
      \LetSum
    \end{prooftree}
    
    \typenva
    Par induction, $`E S, `G \typea t : S \suba \Sigma x : T.U$ et 
    $`E V', `G, x: T, y : U \typea v : V' \suba V$.
    On a $\mualgo(S) = \Sigma x : T'.U'$ avec $T' \suba T$ et $U'
    \suba U$. Par restriction on peut donc dériver $`G, x : T', y : U'
    \seq v : V'' \suba V'$.
    
    On a donc la dérivation suivante dans le système algorithmique:
    \begin{prooftree}
      \TAX{LetSum}
      {$`G \seq t : S$}
      {$\mualgo(S) = `S x : T'. U'$}
      {$`G, x : T', y : U' \seq v : V''$}
      {$`G \seq \letml~(x, u) = t~\inml~v : V''$}
      {}
    \end{prooftree}
    
    Comme $V'' \suba V' \suba V$, la propriété est vraie par
    transitivité de la coercion.

    \casetwo{Conv}{Coerce}
    Dans les deux cas on a inductivement $`E T', `G \typea t : T'
    \suba T$. Avec \irule{Conv} on a $T \eqbr S$, donc $T' \suba S$ par
    le lemme \ref{coercion-conversion}. Pour \irule{Coerce} on a $T \subd S$.
    Par complétude de la coercion, $T \suba S$ et par transitivité de la
    coercion, $T' \suba S$. La propriété est donc bien vérifiée dans les
    deux cas.
  \end{induction}
\end{proof}

On combine les théorèmes de correction et de complétude pour obtenir
 la propriété suivante entre les deux systèmes:
\begin{corrolary}[Équivalence des systèmes déclaratif et algorithmique]
  $`G \typed t : T$ \ssi{} il existe $U$ tel que $`G \typea t : U$ et $U \suba T$.
\end{corrolary}

On a maintenant un système raffiné dérivant les mêmes jugements (à
coercion près) que le système déclaratif. On veut en extraire un
algorithme de typage. Pour cela on doit pouvoir résoudre deux problèmes:
\begin{itemize}
\item\textbf{Vérification de type.} On donne $`G$,$t$ et $T$ et l'on doit
  décider si $`G \typea t : T$ ;
\item\textbf{Inférence de type.} On donne $`G$,$t$ et l'on doit trouver $T$ tel
  que $`G \typea t : T$ si c'est dérivable, sinon on échoue.
\end{itemize}
En pratique, la vérification a besoin de l'inférence puisque lorsqu'on
vérifie une application $f u : T$ on doit inférer le type de $f$.
On montre donc les théorèmes suivants:

\begin{theorem}[Décidabilité de l'inférence dans le système algorithmique]
  Le problème d'inférence $`G \typea t :~?$ est décidable.
\end{theorem}

\begin{proof}
  Il suffit d'observer que les règles de typage sont dirigées par la
  syntaxe du deuxième argument et permettent donc d'inférer un type pour
  tout terme. En lisant les prémisses de chaque règle de gauche à
  droite, on voit que l'inférence est décidable.
\end{proof}

\begin{theorem}[Décidabilité de $\typea$]
  La relation de typage $`G \typea t : T$ est décidable.
\end{theorem}
\begin{proof}
  Direct. On utilise le théorème précédent pour le cas de l'application.
\end{proof}

On a désormais un algorithme de typage pour notre système avec
coercions. Ce système est très libéral puisqu'il permet de considérer
des objets comme vérifiant des propriétés arbitraires sans les
montrer. Il nous faut maintenant remettre de la logique dans nos termes
pour s'assurer qu'ils sont corrects.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "subset-typing"
%%% LaTeX-command: "TEXINPUTS=\"style:$TEXINPUTS\" latex"
%%% End: 
