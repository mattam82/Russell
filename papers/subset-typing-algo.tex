\section{Élaboration du système algorithmique \& propriétés}
\typenva

Pour pouvoir implémenter le typeur, il nous faut un système dirigé par la
syntaxe. Ce n'est pas le cas du système déclaratif, aussi bien pour le
typage que pour la coercion. On va donc rafiner ces systèmes dans
l'optique d'en extraire un algorithme. On note $\typea$ le jugement de
typage algorithmique défini figure \ref{fig:typing-algo-rules} et
$\suba$ le jugement de coercion algorithmique présenté figure
\ref{fig:subtyping-algo-rules}. Ces deux systèmes sont quelque peu
éloignés des originaux, néanmoins nous allons montrer qu'ils sont
corrects et complets vis-à-vis de leur géniteurs. La correction (si l'on
a une dérivation d'un jugement dans le système algorithmique, alors
c'est un jugement valide du système déclaratif) est le
sens le plus facile à montrer, nous allons donc commencer par là. On
décrira ensuite la méthode de construction des systèmes algorithmiques
pour aboutir d'une part au théorème de complétude qui montre qu'on peut dériver les
mêmes jugements (à coercion près) dans le système algorithmique que dans
le sytème déclaratif et d'autre part à la décidabilité du jugement de
typage algorithmique.

\subsection{Notations}
On note $\hnf{x}$ la mise en forme normale de tête de $x$ selon la
réduction définie précédemment. 

\setboolean{displayLabels}{true}
\typenva
\typeaFig
\typemuaFig
\subtaFig

\subsection{Correction}
On montre tout d'abord la correction de la coercion algorithmique qui
sera nécessaire pour la correction du typage:

\begin{theorem}[Correction de la coercion]
  \label{correct-coercion}
  Si $U \suba V$ alors $U \subd V$.
\end{theorem}

\begin{proof}
  Les règles du système algorithmique sont un sous-ensemble des règles
  du système déclaratif.
\end{proof}

On a besoin d'un lemme sur l'opération $\mualgo$ définie figure
\ref{fig:mualgo-definition}.

\begin{lemma}[$\mualgo$ et coercion]
  \label{mu-coercion}
  Si $\mualgo(T) \eqbi U$ alors $T \suba U$.
\end{lemma}

\begin{proof}
  Il suffit de suivre la définition de $\mualgo$. La mise en forme
  normale de tête est implicite dans notre jugement de
  coercion. $\mualgo$ est en fait l'application répétée de la règle \irule{SubSub}.
\end{proof}

\begin{theorem}[Correction du typage]
  \label{correct-typing}
  Si $`G \typea t : T$ alors $`G \typed t : T$
\end{theorem}

\setboolean{displayLabels}{false}
\begin{proof}
  \begin{induction}[typing-algo]
  \item[- \irule{WfEmpty},\irule{WfVar},\irule{PropSet},\irule{Var},\irule{Prod},\irule{Abs},
    \irule{LetIn}, \irule{Sigma}, \irule{Sum}:] règles inchangées.
    
    \case{LetSum}
    On a 
    \begin{prooftree}
      \LetSumA
    \end{prooftree}
    
    Par induction, $`G \typed t : S$, et par le lemme \ref{mu-coercion}
    et la correction de la coercion $S \subd \Sigma x : T. U$.
    On peut donc dériver $`G \typed t : \Sigma x : T.U$ à l'aide de \irule{Coerce}.
    On peut directement appliquer \irule{LetSum} à cette prémisse et à
    l'hypothèse d'induction $`G, x : T, y : U \typed v : V$.
    
    \case{App} On a:
    \def\fCenter{\typea}
    \begin{prooftree}
      \AppA
    \end{prooftree}
    
    Par induction, $`G \typed f : T$, et $T \subd \Pi x : V. W$ par le
    lemme \ref{mu-coercion} et la correction de la coercion.
    On peut donc dériver $`G \typed f : \Pi x : V.W$ à l'aide de la
    \irule{Coerce}.
    Par le lemme \ref{correct-coercion}, et l'hypothèse $`G \typed u :
    U$, on obtient $`G \typed u : V$ par \irule{Coerce}.
    Donc, par \irule{App}, on a bien $`G \typed f u : W[u/x]$.
  \end{induction}  
\end{proof}

On a prouvé que notre système algorithmique était correct, c'est à dire
que ses jugements valides sont bien inclus dans ceux du système
déclaratif, il faut maintenant montrer qu'il les inclus tous (ou presque!).

\begin{subsubsection}{Notations}
On introduit la notation $`G \typea T, U : s$ pour $`G \typea T : s_1 `^
`G \typea U : s_2 `^ s_1 = s_2 = s$.
\end{subsubsection}

\subsection{Complétude et décidabilité}
On va maintenant repartir des systèmes déclaratifs pour montrer comment
l'on a construit les systèmes algorithmiques. 


On s'intéresse tout d'abord au jugement de coercion.
Pour rendre le jugement de coercion décidable, il faut traiter la règle
\irule{SubConv} qu'on peut appliquer à n'importe quel moment et la règle
\irule{SubTrans} qui n'est pas dirigée par la syntaxe (il faut
``deviner'' un type $T$). Le système de coercion algorithmique (figure
\ref{fig:subtyping-algo-rules}) est le même que le système
déclaratif (figure \ref{fig:subtyping-decl-rules}) mais où l'on n'applique 
\irule{SubConv} seulement si aucune autre règle ne
s'applique et sans la rêgle \irule{SubTrans}. 

\subsubsection{Décidabilité et complétude de la coercion}
On va montrer que les deux systèmes de coercion sont équivalents vis à
vis de la conversion. On montrera plus tard pourquoi on peut éliminer la
règle de transitivité.

On rappelle qu'on considère qu'on peut appliquer la normalisation de tête avant tout
application d'une règle de typage ou coercion. Ainsi on peut très bien
dériver $((\lambda x : \Set.x)~\nat) \suba \subset{x}{\nat}{P}$ puisque 
$\hnf{((\lambda x : \Set.x)~\nat)} = \nat$ et $\nat \suba
\subset{x}{\nat}{P}$ par \irule{SubProof} et \irule{SubConv}.

Il nous faut tout d'abord des lemmes d'inversion sur la conversion:
\begin{lemma}
  \label{conversion-pi}
  Si $\Pi x : T. U \eqbi S$ alors $\hnf{S} = \Pi x : T'. U'$ avec $T \eqbi T'$ et $U
  \eqbi U'$.
\end{lemma}
\begin{lemma}
  \label{conversion-sigma}
  Si $\Sigma x : T. U \eqbi S$ alors $\hnf{S} = \Sigma x : T'. U'$ avec $T \eqbi T'$ et $U
  \eqbi U'$.
\end{lemma}

On peut maintenant montrer:
\begin{lemma}[Conservation de la conversion par coercion]
  \label{conversion-coercion}
  Si $`G \typea T, U : s$ et $T \eqbi U$ alors $T \suba U$.
\end{lemma}
\begin{proof}
  Par induction sur la forme de $T$.
  
  \def\seq{\suba}.
  
  \begin{itemize}
  \item[$T `= \Pi x : X.Y$:]
    Alors $\hnf{U} = \Pi y : V.W$ et $X \eqbi V$, $Y \eqbi W$
    d'après le lemme \ref{conversion-pi}.
    Par induction $X \sub Y$ et $V \sub W$. 
    On applique alors \irule{SubProd} à ces deux prémisses.
    
  \item[$T `= \Sigma x : X.Y$:]
    Alors $\hnf{U} = \Sigma y : V.W$, avec $X \eqbi V$ et $Y \eqbi
    W$. Par induction et application de \irule{SubSigma}.
    
  \item[$T `= \subset{x}{X}{P}$:] 
    On a alors $\hnf{U} \subset{x}{X'}{P'}$ avec $X \eqbi X'$, $P \eqbi
    P'$, et la propriété est vraie par \irule{SubLeft} et \irule{SubRight}:
    
    \begin{prooftree}
      \AXC{$X \sub X'$}
      \LeftLabel{\SubLeftRule}
      \UIC{$\subset{x}{X}{P} \sub X'$}
      \LeftLabel{\SubRightRule}
      \UIC{$\subset{x}{X}{P} \sub \subset{x}{X'}{P'}$}
    \end{prooftree}

  \item[Sinon:]
    On applique obligatoirement \irule{SubConv} et l'on a la prémisse $T
    \eqbi U$, c'est donc direct.
  \end{itemize}
\end{proof}

Il n'y a pas de problème d'identification de sortes dans ce système,
contrairement au système $\lambda~C_\leq$ de Gang Chen \cite{ChenPhD},
puisqu'on a pas de cumulativité. Le seul fait que les arguments sont
tous les deux sortés avec la même sorte
avant de dériver le jugement de coercion nous assure que l'on ne fera
pas d'identification erronée.

On va maintenant montrer que la règle \irule{SubTrans} est admissible
dans notre système algorithmique. On montre ceci en l'éliminant de toute
dérivation possible la faisant intervenir.

\typenva
Tout d'abord quelques lemmes nécessaires pour la preuve:
\begin{lemma}[Coercion et $\mualgo$]
  \label{coercion-mu}
  Si $\Pi x : X.Y \sub U$ alors $\mualgo(U) \eqbi \Pi x : X'.Y'$ et $X' \sub
  X$, $Y \sub Y'$.
  Si $\Sigma x : X.Y \sub U$ alors $\mualgo(U) \eqbi \Sigma x : X'.Y'$ et $X \sub
  X'$, $Y \sub Y'$.
  Pour tout $U$, $U \sub \mualgo(U)$.
\end{lemma}
\begin{proof}
  Par induction sur les dérivations de $\suba$ et la définition de $\mualgo$.
\end{proof}

\begin{lemma}[Coercion et conversion]
  \label{coercion-conversion}
  Si $S \eqbi T$ et $T \sub U$ alors $S \sub U$
\end{lemma}

\begin{proof}
  Par simple inspection des règles on voit que le jugement ne peut
  distinguer deux termes $\beta$-équivalents (ils ont forcement les
  mêmes formes normales de tête).
\end{proof}


\begin{lemma}[Transitivité de la coercion]
  \label{transitive-coercion}
  Pour tout $S, T, U$,  si $S \sub T$ et $T \sub U$ alors $S \sub U$.
\end{lemma}

\begin{proof} 
  %\TODO{Dans \cite{Pierce:TypeSystems}, voir p. 420}
  On procède par élimination de la règle \irule{SubTrans} dans toute
  dérivation de $S \sub U$.
  
  \begin{induction}[subtyping-decl]

    \case{SubConv}\quad
    \begin{prooftree}
      \AXC{$S \eqbi T$}
      \UIC{$S \sub T$}
      \AXC{$T \sub U$}
      \BIC{$S \sub U$}
    \end{prooftree}
    
    Par le lemme précédent, on élimine trivialement \irule{SubTrans}.

    \case{SubProd}\quad
    \begin{prooftree}
      \AXC{$X' \sub X$}
      \AXC{$Y \sub Y'$}
      \BIC{$\Pi~X~Y \sub \Pi~X'~Y'$}
      \AXC{$\Pi~X'~Y' \sub U$}
      \BIC{$\Pi~X~Y \sub U$}
    \end{prooftree}
    
    Si $\Pi~X'~Y' \sub U$, alors il existe $S$, $T$, tel que $\mualgo(U)
    \eqbi \Pi~S~T$ et $S \sub X'$, $Y' \sub T$.
    Par induction, $S \sub X$ et $Y \sub T$ donc $\Pi~X~Y \sub \Pi~S~T$ 
    et enfin $\Pi~X~Y \sub U$.

    De facon équivalente pour le second cas.

    \case{SubSigma}\quad
    \begin{prooftree}
      \AXC{$X \sub X'$}
      \AXC{$Y \sub Y'$}
      \BIC{$\Sigma~X~Y \sub \Sigma~ X'~Y'$}
      \AXC{$\Sigma~X'~Y' \sub U$}
      \BIC{$\Sigma~X~Y \sub U$}
    \end{prooftree}
    
    Si $\Sigma~X'~Y' \sub U$, alors il existe $S$, $T$, tel que $\mualgo(U)
    \eqbi \Sigma~S~T$ et $X' \sub S$, $Y' \sub T$.
    Par induction, $X \sub S$ et $Y \sub T$ donc $\Sigma~X~Y \sub
    \Sigma~S~T$ et enfin $\Sigma~X~Y \sub U$ (lemme \ref{coercion-mu}).
    
    De façon équivalente pour le second cas.

    \case{SubProof}\quad
    \begin{prooftree}
      \AXC{$S \sub V$}
      \UIC{$S \sub \subset{x}{V}{P}$}
      \AXC{$\subset{x}{V}{P} \sub U$}
      \BIC{$S \sub U$}
    \end{prooftree}
    
    Si $\subset{x}{V}{P} \sub U$ alors $\mualgo(U) \eqbi V$.
    Comme $S \sub V$, par induction, $S \sub \mualgo(U)$ donc
    $S \sub U$.
    
    De façon équivalente pour le second cas.

    \case{SubSub}
    Cas identique à \irule{SubProof}
    
  \end{induction}
\end{proof}

\begin{corrolary}[Complétude de la coercion]
  \label{complete-coercion}
  Si $U \subd V$ alors $U \suba V$.
\end{corrolary}

\begin{proof}
  Les règles des deux systèmes sont les mêmes excepté \irule{SubTrans}
  qu'on peut éliminer dans le système algorithmique. De plus
  l'application restreinte de la conversion ne change pas les jugements
  dérivables (lemme \ref{conversion-coercion}).
\end{proof}

En conséquence $\subd$ et $\suba$ sont équivalentes. Le système
d'inférence de $\suba$ donne donc un algorithme pour décider de la relation
de coercion. L'indéterminisme entre les règles \irule{SubProof} et
\irule{SubSub} ne pose pas de problème: on peut laisser le choix à 
l'implémentation puisque le système est confluent.

\subsubsection{Décidabilité et complétude du typage}
Le système algorithmique correspond au système déclaratif où l'on a enlevé la règle
de coercion \irule{Coerce} et changé certaines règles pour obtenir un système décidable
(voir figure \ref{fig:typing-algo-rules}).
On va procéder de façon similaire à l'élimination de la transitivité
pour montrer que la règle \irule{Coerce} n'est plus nécessaire dans le
système algorithmique. On va montrer en fait que
toute dérivation de typage utilisant \irule{Coerce} peut se réécrire en
une dérivation n'utilisant cette règle qu'à sa racine.

\def\subs{\subset{x}{U}{P}}
Il nous a fallut changer quelque peu les règles pour obtenir le système
algorithmique. En particulier, on a utilisé la fonction $\mu_0$ de \PVS{}
\cite{PVS-Semantics:TR} renommée $\mualgo$ ici pour opèrer des
\emph{décompréhensions}. Cette fonction efface les constructeurs de type
sous-ensemble en tête d'un type, par exemple: $\mualgo(\subset{f}{\nat
  "->" \nat}{f~0 = 0}) = \nat "->" \nat$. Cela nous permet de
restreindre l'utilisation du jugement de coercion à l'application.

\subsubsection{Sommes dépendantes}
On veut pouvoir faire le plus d'inférence possible dans notre sytème
algorithmique, on a donc introduit une règle \irule{SumInf} qui ne force
pas à annoter les paires. Dans le cas ou le terme n'est pas annoté, on
considère donc que la somme n'est pas dépendante. En effet on remarque
 qu'il n'est pas possible d'inférer le type $U$ à partir du seul terme $(t, u)$. Cela
nécessiterait de résoudre un problème d'unification d'ordre supérieur
auquel il n'y a pas de solution la plus générale. 
On a donc dans le système algorithmique deux règles pour les sommes, 
dont une (\irule{SumDep}) permettant d'annoter le terme avec le type $U$ recherché. 

\subsubsection{\'Elimination de la coercion}
\typenva

% On enlève \irule{Coerce} du système et on change la règle 
% d'application \irule{App} de la figure \ref{typing-decl-rules}.
% On note $\typea$ le système de typage obtenu. 

La technique que nous allons utiliser pour montrer l'équivalence entre
les deux systèmes de typage est la suivante: on considère le système algorithmique
auquel on ajoute la règle de coercion. On montre que toute dérivation
de ce système se réecrit dans une dérivation du système algorithmique
sans la règle \irule{Coerce} et on montre ensuite que toute dérivation
du système déclaratif a une dérivation correspondante dans le système
algorithmique avec \irule{Coerce}. En composant les deux preuves on
obtient que toute dérivation du système déclaratif a une dérivation dans
le système algorithmique (sans \irule{Coerce} donc).

\begin{proposition}[Passage de la coercion à l'application]
  \label{subsum-elim}
  On peut réecrire toute dérivation $`G \typea t : T$ utilisant la
  coercion vers une dérivation $`G \type t : U$ avec $U \suba T$.
\end{proposition}

On utilisera l'abbréviation $`G \typea t : S \suba T$ pour $`G \typea t
: S `^{} S \suba T$ dans la suite.
On a besoin de quelques lemmes auparavant:

\begin{lemma}[$\beta$-equivalence et $\mualgo$]
  \label{beta-mu}
  Si $X \sub Y$ et $\mualgo(Y) \eqbi \Sigma x : T.U$ alors $\mualgo(X) \eqbi \Sigma x : T'.U'$
  et $T' \sub T$, $U' \sub U$.
  Si $X \sub Y$ et $\mualgo(Y) \eqbi \Pi x : T.U$ alors $\mualgo(X) \eqbi \Pi x :
  T'.U'$ et $T \sub T'$, $U' \sub U$.
\end{lemma}
\begin{proof}
  Par induction sur la dérivation de coercion, on fait le cas pour $\Sigma$.
  \begin{induction}  
    \case{SubConv} Trivial, puisqu'on aura $\mualgo(X) = \mualgo(Y)$.

    \case{SubProd} Impossible, $\mualgo$ ne traversant pas les produits.

    \case{SubSigma} Direct, on a une dérivation de $\Sigma x : T'. U'
    \sub \Sigma x : T.U$.
    
    \case{SubLeft} Ici, $Y `= \subset{x}{V}{P}$, on peut donc déduire que
    $\mualgo(Y) = \mualgo(V) \eqbi \Sigma x : T.U$. On 
    applique l'hypothèse de récurence avec $X \sub V$ et on obtient:
    $\mualgo(X) \eqbi \Sigma x : T'.U' `^ T' \sub T `^ U' \sub U$.

    \case{SubRight} Ici, $X `= \subset{x}{V}{P}$. Par induction, 
    $\mualgo(V) = \mualgo(X) \eqbi \Sigma x : T'.U' `^ T' \sub T `^ U' \sub U$.
  \end{induction}
\end{proof}

\begin{lemma}[Bonne formation des contextes]
  \label{wf-contexts-a}
  Si $`G \type t : T$ alors $\typewf `G$.
\end{lemma}
\begin{proof}
  \inductionon{typing-decl}
\end{proof}

\begin{fact}[Inversion du jugement de bonne formation]
  \label{inversion-wf-a}
  Si $\typewf `G, x : U$ alors il existe $s$, $`G \type U : s$ et $s `: \setproptype$.
\end{fact}

\begin{lemma}[Affaiblissement]
  \label{weakening-a}
  Si $`G, `D \type t : T$ alors pour tout $x : S `; `G, `D$ tel que
  $\wf `G, x : S, `D$, $`G, x : S, `D \type t : T$
\end{lemma}

\begin{proof}
  \begin{induction}[typing-decl]
    \case{PropSet} Trivial.

    \case{Var}
    On a $x : S `; `G, `D$, donc $`G, x : S, `D \type y : T$ est toujours dérivable.
    
    \case{Prod}
    Par induction $`G, x : S, `D \type T : s1$ et $`G, x : S, `D,
    y : T \type U : s2$. On applique \irule{Prod} pour obtenir 
    $`G, x : S, `D \type \Pi x : T.U : s2$. De même pour le reste des règles.
  \end{induction}
\end{proof}  

La restriction montre que notre notion de coercion est correcte
vis-à-vis du typage. On peut dériver les mêmes jugements dans des
contextes où les variables ont des types équivalents.

\begin{lemma}[Restriction]
  \label{narrowing-a}
  \[ `G \seq S, S' : s, S' \sub S "=>" 
  \left\{ \begin{array}{lcl}
      \typewf `G, x : S, `D & "=>" & \typewf `G, x : S', `D \\
      & `^{} & \\
      `G, x : S, `D \seq t : T & "=>" & `G, x : S', `D \seq t : T
    \end{array}
  \right. \]
\end{lemma}

\begin{proof}
  Par induction sur la taille de la dérivation de typage ou de bonne formation.
    
  \begin{induction}
    \case{WfEmpty} Trivial.
    
    \case{WfVar} 
    La conclusion est $\typewf `G, x : S, `D$
    
    \begin{induction}[text=Par induction sur la taille de $`D$]
    \item[\protect{$`D = []$}]
      La racine de la dérivation est de la forme:
      \begin{prooftree}
        \UAX{WfVar}
        {$`G \type S : s$}
        {$\wf `G, x : S$}
        {$s `: \setproptype$}
      \end{prooftree}
      On a $`G \type S' : s$, donc par \irule{WfVar}, $\typewf `G, x : S'$.  
      
    \item[\protect{$`D `= `D', y : U$}]
      La racine de la dérivation est de la forme:
      \begin{prooftree}
        \UAX{WfVar}
        {$`G, x : S, `D' \type U : t$}
        {$\wf `G, x : S, `D', y : U$}
        {$s `: \setproptype$}
      \end{prooftree}
      Par induction sur la dérivation de typage $`G, x : S', `D' \seq U : t$,
      on a donc bien $\typewf `G, x : S', `D', y : U$ par \irule{WfVar}.
    \end{induction}
    
    \case{PropSet}
    Par induction, $\typewf `G, x : S', `D$, on applique simplement la règle.
    
    \case{Var}
    Par induction, $\typewf `G, x : S', `D$. La seule différence avec le
    contexte précedent est le type associé à $x$, donc si $t \not= x$, on
    peut simplement réappliquer \irule{Var}. Si $t `= x$ on construit la
    dérivation:

    \begin{prooftree}
      \BAX{Var}
      {$\wf `G, x : S', `D$}
      {$x : S' `: `G$}
      {$`G, x : S', `D \seq x : S'$}
      {}
      \AXC{$`G, x : S', `D \type S,S' : s$}
      \AXC{$S' \sub S$} % `G \subt 
      \TIC{$`G, x : S', `D \type x : S$}
    \end{prooftree}
    
    Par l'affaiblissement (lemme \ref{weakening-a}) et $`G \type S,S' : s$,
    on obtient la prémisse $`G, x : S', `D \type S,S' : s$.
    
    \case{Prod} 
    Par induction, $`G, x : S', `D \type T : s1$ et $`G, x : S', `D
    y : T \seq U : s2$. On applique \irule{Prod} pour obtenir 
    $`G, x : S' \type \Pi x : T.U : s2$. De même pour le reste des règles.
  \end{induction}
\end{proof}

On peut maintenant montrer notre proposition:
\begin{proof}
  On inspecte les dérivations possibles utilisant \irule{Coerce} juste avant
  une autre règle. Si \irule{Coerce} est utilisé juste en racine c'est trivial.
  
  \typenva
  \begin{induction}
    \case{Var} Pas de prémisse de la forme $`G \type t : T$, donc
    pas d'application de \irule{Coerce} possible.
    
    \case{Abs} \quad
    
    \begin{prooftree}
      \AXC{\vdots}
      \UIC{$`G \seq \Pi x : T. U : s $}
      \AXC{\vdots}
      \UIC{$`G, x : T \seq M : U'$}
      \AXC{\vdots}
      \UIC{$`G, x : T \seq U', U : s$}
      \AXC{\vdots}
      \UIC{$U' \sub U$}
      \TIC{$`G, x : T \seq M : U $}
      \BIC{$`G \seq \lambda x : T. M : \Pi x : T.U$}
    \end{prooftree}
    
    Comme $`G, x : T \typed U' : s$ on peut former le produit 
    $`G \typea \Pi x : T. U' : s$.
    On réecrit donc la dérivation en:     
    
    \begin{prooftree}
      \AXC{\vdots}
      \UIC{$`G \seq \Pi x : T. U' : s $}
      \AXC{\vdots}
      \UIC{$`G, x : T \seq M : U'$}
      \BIC{$`G \seq \lambda x : T. M : \Pi x : T.U'$}
      \AXC{$T \eqbi T$}
      \UIC{$T \sub T$}
      \AXC{\vdots}
      \UIC{$U' \sub U$}
      \BIC{$\Pi x : T.U' \sub \Pi X : T.U$}        
      \BIC{$`G \seq \lambda x : T. M : \Pi x : T.U$}
    \end{prooftree}
    
    \case{Sum}\quad
    
    \begin{prooftree}
      \AXC{\vdots}
      \UIC{$`G \seq t : S$}
      \AXC{\vdots}
      \UIC{$S \sub T$}
      \BIC{$`G \seq t : T $}
      \AXC{\vdots}
      \UIC{$`G \seq u : U' \suba U[t/x]$}
      \AXC{\vdots}
      \UIC{$`G \seq \Sigma x : T.U : s $}
      \TIC{$`G \seq (x \coloneqq t, u : U) : \Sigma x : T.U$}
    \end{prooftree}
    
    Comme $S \sub T$, on a bien $\Sigma x : S.U \sub \Sigma x : T.U$
    par \irule{SubSigma}. On sait de plus que $\Sigma x : S.U$ est bien
    sorté de sorte $s$. En effet, par inversion de $`G \seq \Sigma x :
    T.U : s$ on a $`G, x : T \seq U : s$ et par restriction ($S \sub T$), $`G, x : S \seq
    U : s$. On peut donc dériver:

    \begin{prooftree}
      \AXC{\vdots}
      \UIC{$`G \seq t : S$}
      \AXC{\vdots}
      \UIC{$`G \seq u : U' \suba U[t/x]$}
      \AXC{\vdots}
      \UIC{$`G \seq \Sigma x : S.U : s $}
      \TIC{$`G \seq (x \coloneqq t, u : U) : \Sigma x : S.U$}
      \AXC{\vdots}
      \UIC{$\Sigma x : S.U \sub \Sigma x : T.U$}
      \BIC{$`G \seq (x \coloneqq t, u : U) : \Sigma x : T.U$}
    \end{prooftree}

    Si on utilise la coercion pour la prémisse $`G \type u : U'$ alors
    on a $`G \type u : U'' \suba U'$. Or par transitivité de la
    coercion $`G \type u : U'' \suba U[t/x]$, le jugement ne change donc pas.
     
    \case{LetSum}\quad
    \begin{prooftree}
      \AXC{\vdots}        
      \UIC{$`G \seq t : S $}
      \AXC{\vdots}
      \UIC{$S \sub V$}
      \BIC{$`G \seq t : V$}
      \AXC{$\mualgo(V) \eqbi \Sigma x : T.U$}
      \AXC{\vdots}
      \UIC{$`G, x : T, u : U \seq v : V $}
      \TIC{$`G \seq \letml~(x, u) = t~\inml~v : V$}
    \end{prooftree}
    
    Par le lemme \ref{beta-mu}, on a $\mualgo(S) \eqbi \Sigma x : T'.U'$,
    $T' \suba T$ et $U' \suba U$. Par restriction (lemme
    \ref{narrowing-a}) on a:

    \begin{prooftree}
      \AXC{\vdots}        
      \UIC{$`G \seq t : S $}
      \AXC{$\mualgo(S) \eqbi \Sigma x : T'.U'$}
      \AXC{\vdots}
      \UIC{$`G, x : T', u : U' \seq v : V $}
      \TIC{$`G \seq \letml~(x, u) = t~\inml~v : V$}
    \end{prooftree}

    Si l'on applique la coercion à droite c'est direct ($V' \sub V$).
    
    \case{LetIn}
    De façon similaire, par restriction on obtient la dérivation sans \irule{Coerce}.
    
    \case{App}\quad    
    \begin{prooftree}
      \AXC{\vdots}
      \UIC{$`G \seq f : T $}
      \AXC{\vdots}
      \UIC{$ T \sub \Pi x : V. W$}
      \BIC{$`G \seq f : \Pi x : V. W $}
      \noLine
      \UIC{$\mualgo(\Pi x : V.W) \eqbi \Pi x : V.W$}
      \AXC{\vdots}
      \UIC{$`G \seq u : U $}
      \AXC{\vdots}
      \UIC{$U \sub V$}
      \TIC{$`G \seq f u : W [ u / x ]$}
    \end{prooftree}
    
    Par le lemme \ref{beta-mu} on a $\mualgo(T) \eqbi \Pi x : V'.W'$ avec
    $V \suba V'$ et $W' \suba W$. Par la transitivité de la coercion on
    a: $U \suba V `^ V \suba V' "=>" U \suba V'$.
    On peut donc dériver:
    
    \begin{prooftree}
      \AXC{\vdots}
      \UIC{$`G \seq f : T $}
      \noLine
      \UIC{$\mualgo(T) \eqbi \Pi x : V'.W'$}
      \AXC{\vdots}
      \UIC{$`G \seq u : U $}
      \AXC{\vdots}
      \UIC{$U \sub V'$}
      \TIC{$`G \seq f u : W [ u / x ]$}
    \end{prooftree}
    
    \case{Coerce}\quad

    Dans le cas où l'on a un enchainement de règles \irule{Coerce}:
    \begin{prooftree}
      \AXC{\vdots}
      \UIC{$`G \seq t : S$}
      \AXC{\vdots}
      \UIC{$S \sub T$}
      \BIC{$`G \seq t : T$}
      \AXC{\vdots}
      \UIC{$T \sub U$}
      \BIC{$`G \seq t : U$}
    \end{prooftree}
    
    En utilisant la transitivité de la coercion on obtient:
    \begin{prooftree}
      \AXC{\vdots}
      \UIC{$`G \seq t : S$}
      \AXC{\vdots}
      \UIC{$S \sub U$}
      \BIC{$`G \seq t : U$}
    \end{prooftree}

  \end{induction}
  
\end{proof}

Par induction, on a donc montré que l'on peut réduire l'utilisation de la règle de
coercion à la racine d'une dérivation. 
On peut pratiquement ignorer l'utilisation de la coercion à la racine de la dérivation, 
on fera de toute façon un test de coercion entre le type inféré et le
type spécifié juste avant la réécriture. 
On considère maintenant le système algorithmique comme présenté figure \ref{fig:typing-algo-rules}.

Il nous faut montrer des lemmes faisant intervenir la substitution pour
pouvoir prouver la complétude.
\begin{lemma}[Substitutivité de $\mualgo$]
  \label{substitutive-mu}
  Si $\mualgo(T) \eqbi \Pi y : U.V$ alors $\mualgo(T[u/x]) \eqbi \Pi y :
  U[u/x].V[u/x]$.
  Si $\mualgo(T) \eqbi \Sigma y : U.V$ alors $\mualgo(T[u/x]) \eqbi \Sigma y : U[u/x].V[u/x]$.
\end{lemma}

\begin{proof}
  On montre la propriété pour les produits, la preuve est similaire pour
  les sommes. Par induction sur la taille de $T$.

  Il suffit de suivre la définition de $\mualgo$.
  Si $T$ est de la forme $\subset{y}{V}{P}$ alors
  on a $\mualgo(V) \eqbi \Pi y : U.V$ et par induction
  $\mualgo(V[u/x]) \eqbi \Pi y : U[u/x].V[u/x]$.
  Il s'ensuit directement que $\mualgo(T[u/x]) \eqbi \Pi y :
  U[u/x].V[u/x]$.

  Si $T$ est différent d'un type sous-ensemble alors $\mualgo(T) = T$.
  Donc $T \eqbi \Pi y : U.V$. Il s'ensuit que $T$ est de la forme $\Pi y
  : U'.W'$ et donc $T[u/x] = \Pi y : U'[u/x].V'[u/x] =
  \mualgo(T[u/x])$. Par substitutivité de la conversion, il s'ensuit que 
  $\Pi y : U'[u/x].V'[u/x] \eqbi \Pi y : U[u/x].V[u/x]$.
\end{proof}

\begin{lemma}[Substitutivité de la coercion]
  \label{substitutive-coercion}
  Si $U \suba T$ alors pour tout $u$, $U[u/x] \suba T[u/x]$.
\end{lemma}

\begin{proof}
  \begin{induction}[subtyping-algo]
    \case{SubConv}
    Direct par préservation de l'équivalence $\eqbi$ par substitution.
    
    \case{SubProd}
    Par induction $U[u/x] \suba T[u/x]$ et $V[u/x] \suba W[u/x]$, donc
    $\Pi y : T[u/x].V[u/x] \suba \Pi y : U[u/x].W[u/x]$. La propriété
    est donc bien vérifiée.
    
    \case{SubSigma} Direct par induction.
    
    \case{SubSub} Par induction, $U'[u/x] \suba V[u/x]$. On applique
    \irule{SubLeft} pour obtenir $\subset{y}{U'[u/x]}{P} \suba V[u/x]$. 
    
    \case{SubRight} Direct par induction.
  \end{induction}
\end{proof}

\begin{lemma}[Substitutivité du typage]
  \label{substitutive-typing}
  Si $`G \typea u : U$ alors
  \[ \left\{ \begin{array}{lcl}
      `G, x : U, `D \typea t : T & "=>" & `G, `D[u/x] \typea t[u/x] :
      T[u/x] \\
      \wf `G, x : U, `D & "=>" & \wf `G, `D[u/x]
    \end{array}\right. \]
\end{lemma}

\begin{proof}
  \typenva
  Par induction mutuelle sur la dérivation de typage $`G, x : U, `D
  \typea t : T$ ou $\wf `G, x : U, `D$.
  
  \begin{induction}
    \case{WfEmpty} Trivial.

    \case{WfVar}
    Par induction sur $`D$.
    \begin{itemize}
    \item[\protect{$`D = []$}]
      On a alors $`G \typea U : s$ donc $\wf `G$ et trivialement, $\wf
      `G, `D[u/x]$.

    \item[\protect{$`D = `D', y : T$}]
      On a alors $`G, x : U, `D' \typea T : s$ et par induction
      $`G, `D'[u/x] \typea T[u/x] : s[u/x]$. Donc on peut appliquer
      \irule{WfVar} pour obtenir $\wf `G, `D'[u/x], T[u/x]$ soit
      $\wf `G, `D[u/x]$
    \end{itemize}
    
    \casetwo{PropSet} 
    La substitution n'a aucun effet et $`G, `D[u/x]$ est bien
    formé par induction.
    
    \case{Var}
    Par induction, $\wf `G, `D[u/x]$.
    Si $t `= x$ alors on a $T = U$ et $T[u/x] = U$ puisque $x$
    n'apparait pas dans $U$. On a donc bien $`G, `D[u/x] \typea t[u/x] = u :
    T[u/x] = U$. 
    Si $y : T `: `G$ alors on applique simplement \irule{Var}.
    Si $y : T `: `G$ alors $y : T[u/x] `: `D[u/x]$ et on obtient
    $`G, `D[u/x] \typea y[u/x] :  T[u/x]$ par \irule{Var}.
    
    \case{Prod}
    Par induction  $`G, `D[u/x] \typea T[u/x] : s_1[u/x]$ et
    $`G, `D[u/x], y : T[u/x] \typea M[u/x] : s_2[u/x]$. 
    On peut appliquer \irule{Prod} pour obtenir $`G, `D[u/x] \typea \Pi
    y : T[u/x].M[u/x] : s_2[u/x]$ soit $`G, `D[u/x] \typea (\Pi y :
    T.M)[u/x] : s_2[u/x]$.
    De façon similaire pour les autres cas.

    \case{App}
    On étudie le cas de l'application qui requiert un lemme supplémentaire.
    Par induction, $`G, `D[u/x] \typea f[u/x] : T[u/x]$ et
    $`G, `D[u/x] \typea a[u/x] : A[u/x]$. Si $\mualgo(T) \eqbi \Pi y :
    V.W$ alors $\mualgo(T[u/x]) \eqbi \Pi y : V[u/x].W[u/x]$ (lemme
    \ref{substitutive-mu}). Par induction, on a aussi $`G, `D[u/x] \typea
    A[u/x],V[u/x] : s$. Enfin, par substitutivité de la coercion on a $A[u/x]
    \suba V[u/x]$. On peut donc appliquer \irule{App} pour obtenir 
    $`G, `D[u/x] \typea (f[u/x] a[u/x]) : W[u/x][a[u/x]/y]$. Or $W[u/x][a[u/x]/y] =
    W[a/y][u/x]$. On a donc bien $`G, `D[u/x] \typea (f a)[u/x] :
    (W[a/y])[u/x]$.
    On a un raisonnement similaire pour \irule{LetSum}.
  \end{induction}
  
\end{proof}

\begin{lemma}[Substitutivité du typage avec coercion]
  \label{substitutive-typing-coercion}
  Si $`G, x : V \typea t : T \sub U$ et $`G \typea u : V$
  alors $`G \typed t[u/x] : T[u/x] \sub U[u/x]$.
\end{lemma}

\begin{proof}
  Par substitutivité du typage (\ref{substitutive-typing}) on a $`G \typed t[u/x] : T[u/x]$.
  Par le lemme précédent $T[u/x] \suba U[u/x]$.
\end{proof}


On a maintenant tout les ingrédients pour montrer la complétude de notre
système de typage vis-à-vis du système déclaratif.

\setboolean{displayLabels}{true}
\begin{lemma}[Complétude du typage]
  \label{complete-typing}
  $`G \typed t : T "=>" `E U, `G \subta t : U \sub T$
\end{lemma}

\begin{proof}
  \begin{induction}[typing-decl]
  \item[\irule{WfEmpty},\irule{WfVar},\irule{PropSet},\irule{Var},\irule{Prod},\irule{Abs},
    \irule{LetIn}, \irule{Sigma}, \irule{Sum}, \irule{Subset}:] règles inchangées.
    
    \case{App} On a 
    \typenvd
    \begin{prooftree}
      \App
    \end{prooftree}
    
    \typenva
    Par induction, $`E T, `G \typea f : T \suba \Pi x : V. W$ et
    $`E U, `G \subta u : U \sub V$.
    
    Si $T \suba \Pi x : V.W$ alors $\mualgo(T) \eqbi \Pi x : V'.W'$ avec
    $V \suba V'$ et $W' \suba W$.

    Par transivité de la coercion: $U \suba V'$, on peut donc dériver 
    \begin{prooftree}
      \TAX{App}
      {$`G \seq f : T \quad \mualgo(T) \eqbi \Pi x : V'. W'$}
      {$`G \seq u : U \quad `G \seq U, V' : s$}
      {$U \suba V'$}
      {$`G \seq (f u) : W' [ u / x ]$}
      {}
    \end{prooftree}
    
    Par substitutivité de la coercion (lemme
    \ref{substitutive-coercion}), $W'[u/x] \suba W[u/x]$, la propriété
    est donc bien vérifiée.

    \case{LetSum} On a
    \typenvd
    \begin{prooftree}
      \LetSum
    \end{prooftree}
    
    \typenva
    Par induction, $`E S, `G \typea t : S \suba \Sigma x : T.U$ et 
    $`E V', `G, x: T, y : U \typea v : V' \suba V$.
    On a $\mualgo(S) \eqbi \Sigma x : T'.U'$ avec $T' \suba T$ et $U'
    \suba U$. Par restriction on peut donc dériver $`G, x : T', y : U'
    \seq v : V'$.
    
    On a donc la dérivation suivante dans le système algorithmique:
    \begin{prooftree}
      \TAX{LetSum}
      {$`G \seq t : S$}
      {$\mualgo(S) \eqbi `S x : T'. U'$}
      {$`G, x : T', y : U' \seq v : V'$}
      {$`G \seq \letml~(x, u) = t~\inml~v : V'$}
      {}
    \end{prooftree}
    
    Comme $V' \suba V$, la propriété est vraie.

    \casetwo{Conv}{Coerce}
    Dans les deux cas on a inductivement $`E T', `G \typea t : T'
    \suba T$. Avec \irule{Conv} on a $T \eqbi S$, donc $T' \suba S$ par
    le lemme \ref{coercion-conversion}. Pour \irule{Coerce} on a $T \subd S$.
    Par complétude de la coercion, $T \suba S$ et par transitivité de la
    coercion, $T' \suba S$. La propriété est donc bien vérifiée dans les
    deux cas.
    
  \end{induction}
  
\end{proof}

On combine les théorêmes de correction et complétude pour obtenir la propriété suivante entre les deux systèmes:
\begin{corrolary}[Équivalence des systèmes déclaratifs et algorithmiques]
  $`G \typed t : T$ \ssi{} il existe $U$ tel que $`G \typea t : U$ et $U \suba T$.
\end{corrolary}

On a maintenant un système raffiné dérivant les même jugements (à
coercion près) que le système déclaratif. On veut en extraire un
algorithme de typage. Pour cela on doit pouvoir résoudre deux problèmes:
\begin{itemize}
\item\textbf{Vérification de type.} On donne $`G$,$t$ et $T$ et l'on doit
  décider si $`G \typea t : T$ ;
\item\textbf{Inférence de type.} On donne $`G$,$t$ et l'on doit trouver $T$ tel
  que $`G \typea t : T$ si c'est dérivable, sinon on échoue.
\end{itemize}
En pratique, la vérification a besoin de l'inférence puisque lorsqu'on
vérifie une application $f u : T$ on doit inférer le type de $f$.
On montre donc les théorêmes suivants:

\begin{theorem}[Décidabilité de l'inférence dans le système algorithmique]
  Le problème d'inférence $`G \typea t :~?$ est décidable.
\end{theorem}

\begin{proof}
  Il suffit d'observer que les règles de typage sont dirigées par la
  syntaxe du deuxième argument et permettent donc d'inférer un type pour
  tout terme. En lisant les prémisses de chaque règle de gauche à
  droite, on voit que l'inférence est décidable.
\end{proof}

\begin{theorem}[Décidabilité de $\typea$]
  La relation de typage $`G \typea t : T$ est décidable.
\end{theorem}
\begin{proof}
  Direct. On utilise le théorême précédent pour le cas de l'application.
\end{proof}

On a désormais un algorithme de typage pour notre système avec
coercions. Ce système est très libéral puisqu'il permet de considérer
des objets comme vérifiant des propriétés arbitraires sans les
montrer. Il nous faut maintenant remettre de la logique dans nos termes
pour s'assurer qu'ils sont corrects.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "subset-typing"
%%% LaTeX-command: "TEXINPUTS=\"style:$TEXINPUTS\" latex"
%%% End: 
