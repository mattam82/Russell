\documentclass[a4paper,10pt]{article}
\usepackage[francais]{babel} 
\usepackage[latin1]{inputenc}  %% les accents dans le fichier.tex
%\usepackage[T1]{fontenc}       %% Pour la c\'{e}sure des mots accentu\'{e}s
\usepackage{indentfirst}
%\usepackage[dvips]{graphicx}
%\usepackage{coqdoc}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{array}
\usepackage{myabbrevs}
\usepackage{abbrevs}
%\usepackage{bnf}
\usepackage{bussproofs}
\usepackage{hyperref}
\usepackage{fullpage}
\usepackage{concmath}
%\usepackage{cmbright}
\usepackage{fancyhdr}
\usepackage{ifthen}
\usepackage{ifmtarg}
\usepackage{pxfonts}
\usepackage{pgf}
\usepackage{subfigure}

% This is the "centered" symbol
\def\fCenter{\vdash}
\def\seq{\fCenter}
% Optional to turn on the short abbreviations
\EnableBpAbbreviations

\oddsidemargin -1cm
\topmargin -1cm
\headsep 5mm
\textwidth 18cm
\textheight 24cm

\input{mathenv}
\input{typing-macros}

\setboolean{displayLabels}{true}

\input{grammar-macros}

\input{typing-decl}
\input{subtyping-decl}
\input{typing-algo}
\input{subtyping-algo}
\input{typing-impl}
\input{subtyping-impl}

\pgfdeclareimage[height=3cm]{lambda-cube}{pictures/lambda-cube}

\newcommand{\src}[1]{\texttt{#1}}
\newcommand{\srcm}[1]{\text{\texttt{#1}}}

\def\thetitle{Coercion par prédicats en \Coq}

\pagestyle{plain}
\fancyhead[RO,L]{\thetitle}
\fancyfoot[C]{\thepage}

\title{\thetitle}

\author{Matthieu Sozeau \\ sous la direction de Christine Paulin \\
  \'Equipe {\sc Demons}, {\sc LRI}}

\date{\today}

\begin{document}

\maketitle

\begin{abstract}
  \Coq{} est un assistant de preuve d'une grande expressivité pour le
  développement de théories mathématiques et informatiques, ce qui permet
  de traiter un large éventail de problèmes. Le langage de \Coq{},
  constitué d'un noyau fonctionnel de type \ML{} enrichi par des types
  dépendants, permet de spécifier, vérifier puis
  extraire des programmes corrects par construction. En contrepartie, les
  programmes sont plus difficiles à écrire et maintenir que dans un pur
  langage de programmation de type \ML, puisqu'ils mélangent les parties
  logiques et calculatoires. Pour remédier à
  ce problème, on propose un nouveau langage de programmation,
  s'intégrant parfaitement à l'environnement de développement existant,
  qui permet de découpler les parties codage et preuve.
\end{abstract}

\tableofcontents

\newpage
\section{Introduction}

Nous nous plaçons dans le cadre du système d'aide à la preuve \Coq{},
auquel nous souhaitons intégrer un langage de programmation plus souple
que le langage actuellement utilisé.

\subsection{Présentation de \Coq}

\Coq~est un assistant de preuve dont la première version date de 1985,
et qui est aujourd'hui développé dans le projet \PCRI{} \LogiCal{} (INRIA, LIX,
LRI, CNRS). Originellement basé sur le Calcul des Constructions (\CoC),
il a été étendu au \CCIfull~(\CCI) et contient aujourd'hui de
nombreuses améliorations telles qu'un système sophistiqué d'extraction
de programmes ou encore des procédures de décision pour automatiser la
preuve.

Le développement de \Coq~est intimement lié à l'isomorphisme de {\sc
Curry-Howard} qui montre le lien entre logique intuitionniste et calcul. Cet
isomorphisme établit qu'élaborer une preuve du calcul propositionnel
intuitionniste est équivalent à écrire un terme du
\lc~simplement typé (\lcst). Par exemple, montrer que $A "=>" A$ pour un
certain $A$ revient à écrire la fonction identité $\lambda x : A. x$ qui
a bien pour type $A "->" A$. Chaque logique constructive est donc
associée à un \lc{} particulier. Dans \Coq{}, on utilise cet
isomorphisme pour vérifier les preuves. Le noyau est simplement un
typeur pour \CCI{}. Si on peut typer un terme $t$ de type $T$, alors on est
assuré d'avoir trouvé une preuve constructive $t$ de la formule $T$.
Cette dualité se reflète aussi à l'utilisation de \Coq{} où l'on a 
les deux visions: logique (développement mathématique, preuve) et 
calcul (développement informatique, programme).

\subsubsection{Preuve}
\Coq{} est utilisé le plus souvent pour élaborer des théories
mathématiques prouvées mécaniquement. Dans cette optique, l'utilisateur 
modélise un problème par des structures mathématiques et veut prouver
certaines propriétés sur ce modèle (par exemple la preuve du théorème
des quatres couleurs récemment terminée \cite{Gonthier4col} utilisait 
des résultats de géométrie algébrique).

Pour prouver un but sous certaines hypothèses, on utilise des
tactiques qui simulent un raisonnement déductif pour l'utilisateur.
Celles-ci permettent par exemple d'introduire une hypothèse: pour le but
$A "=>" A$ on peut introduire l'hypothèse $H : A$ pour obtenir le but
$A$ ; ou bien d'en appliquer une (ou tout autre résultat déjà établi): 
en appliquant l'hypothèse $H$ on prouve le but directement. 
Ces tactiques peuvent être d'une complexité arbitraire (réécritures,
procédures de décision pour l'arithmétique, etc \ldots).

Les tactiques utilisées pour créer des preuves ne sont en fait qu'une
sorte de sucre au-dessus du noyau de \Coq{} qui se réduit à un typeur
pour \CCI. A la fin d'une preuve, on a en effet construit un terme 
($\lambda x : A. x$ dans notre exemple) que l'on va soumettre au typeur
dont le but est de vérifier qu'il est bien de type $A "->" A$.

\subsubsection{Programmes}
D'un point de vue preuve de programmes, on a donc un environnement qui
permet de vérifier qu'un programme (un terme du calcul) vérifie une
certaine spécification (son type). Les types dépendants permettent de
spécifier fortement les termes. Par exemple, la fonction $\sdef{div} :
\nat "->" \nat "->" \nat$ de \ML{} est plus fortement spécifiée en 
\Coq{} par $\sdef{div} : \nat "->" \subset{x}{\nat}{x \neq 0} "->" \nat$.
Seulement, on ne peut pas écrire simplement un programme \ML{} et
donner sa spécification forte. Comme on a enrichi les types, on doit 
aussi enrichir les termes avec des termes de preuve, inutiles au 
calcul mais nécessaires pour garantir la
correction logique du programme et le fait que la machine puisse
vérifier mécaniquement la correction (annotations,...). Par exemple,
 si l'on veut appeler $\sref{div}$ sur $1$ et $n$ (pour $n : \nat$), il
faut construire un terme $\sref{div}~1~(\sref{elt}~(\lambda x : \nat
"->" x \neq 0)~x~p)$ où $p$ est une preuve de $n \neq 0$. La
fonctionnelle est nécessaire pour la décidabilité du système (on ne peut
pas inférer le type de $P$ à partir de $p$ puisqu'il est de type
$P[n/x]$), et la preuve $p$ pour la correction logique.

A l'inverse, on peut extraire un programme de toute preuve en éliminant les
parties logiques et en ne conservant que la partie calculatoire d'un terme.

% - Lambda calcul avec types dépendants, polymorphisme et ordre supérieur
% (lambda cube)
% - Correspond à la logique intuitionniste
% - Preuve = habitant d'un type.

% => Permet de développer des programmes. Développement informatiques
% (calculatoires)

\subsection{Motivation}

\Coq{} permet de développer des programmes complexes,
de leur donner des spécifications fortes et de les vérifier
automatiquement. On peut même extraire de ces développements des
programmes corrects par construction. Il y a cependant certaines
difficultés à développer en \Coq{} que nous allons étudier maintenant.

\subsubsection{Un langage trop expressif?} 

Le langage de \CCI{} permet de bien spécifier des fonctions non
triviales, par exemple, si l'on définit une fonction de division
euclidienne en \ML{} on aurait: $  \valml~\sdef{div} : \nat "->" \nat "->"
\nat * \nat$. En \Coq, on peut définir:
\[\Definition~\sdef{div} : \forall a : \nat, \forall b : \nat,
b \neq 0 "->" \{~q : \nat~\&~\{~r : \nat `| r < b `^ a = b * q + r~\} \}\]

Les types dépendants permettent de bien relier les entrées aux sorties
et donc de spécifier les programmes aussi fortement que l'on désire, 
mais aussi de façon concise. En revanche, le terme de preuve 
correspondant à \sref{div} est nettement plus long (de l'ordre de 60 lignes), 
et ne peut simplement pas être écrit d'une traite 
sans une expertise approfondie. Pour remédier à ce
problème, on utilise des tactiques qui permettent d'écrire la preuve/programme
incrémentalement (voir figure \ref{fig:euclid-script}
page \pageref{fig:euclid-script}). L'inconvénient de cette
méthode est que l'on n'obtient pas toujours le programme désiré
au départ, puisque les tactiques cachent profondément leur effet sur le
terme de preuve. Certaines techniques de réécriture peuvent aussi
générer des termes de complexité algorithmique bien moins optimale que
ce que l'utilisateur écrirait. Cependant ce mode de fonctionnement est
utile et utilisé par la majorité des utilisateurs de \Coq{} avec succès
(certification d'un compilateur \C, théorème des quatres couleurs
\cite{Gonthier4col}, \ldots).

\subsubsection{Mélange logique et calcul}
Une difficulté essentielle lorsque l'on veut permettre à des
utilisateurs non experts de développer dans \Coq{} est le ``mélange
des genres'' permanent entre logique et calcul. Pour appliquer une
fonction division qui attend un dénominateur différent de $0$ par
exemple, il faut passer à la fois l'argument lui même, mais aussi une
preuve de sa non-nullité. Lorsque l'on a l'habitude de programmer, ça
n'est pas la chose la plus naturelle et l'on aimerait pouvoir découpler
les parties codage et preuve pour simplement diviser le problème. Les
parties logiques pourront souvent être résolues automatiquement par des
tactiques.

\subsubsection{Objectif}
A long terme, on souhaite permettre à un utilisateur de programmer dans
un langage proche de \ML{} et de prouver ses programmes dans un deuxième
temps à l'aide de \Coq{} et ses tactiques. Une fois les preuves
terminées, on peut extraire un programme correct par construction et
essentiellement équivalent à celui de départ ou le réutiliser facilement
dans l'environnement \Coq{}.

\subsection{Travaux Connexes}

La preuve de programmes fonctionnels est un domaine de recherche
actif. L'idée d'étendre les langages \ML{} avec des types dépendants a
été développée dans \DML{} \cite{XiPfenning1999DTP}, \Cayenne{}
\cite{Augustsson99} et \Omegapdx{} \cite{Omega}. Il
s'agit dans ces travaux de faire un langage dont l'inférence est décidable, donc
de restreindre les types dépendants à des domaines où l'on peut faire de
la preuve automatique (\DML{}) ou bien d'affaiblir la puissance du langage
pour rendre l'utilisation des types dépendants plus aisée (\Cayenne{}
n'a pas la récursivité générale par exemple). Nous prenons le
contre-pied de ces travaux en acceptant de générer des obligations de
preuve et en essayant de trouver un langage le plus proche de \ML{}
possible tout en retenant la puissance de \Coq{} et des types
dépendants. Nous présentons maintenant des travaux directement liés à
notre contribution.


\subsubsection{La tactique \Program}
Il existe un travail réalisé dans \Coq{} couvrant une partie de nos objectifs.
Développée par Catherine Parent \cite{conf/mpc/Parent95}, 
la tactique \Program{} permettait de synthétiser des preuves à partir de
programmes. L'idée était de trouver un langage de programmation
suffisamment restrictif pour réaliser une inversion de l'extraction, 
c'est-à-dire, à partir d'un terme essentiellement calculatoire
(des annotations étaient nécessaires), retrouver un terme de preuve
réalisant la spécification donnée. 
A partir de là, on était assuré que le programme extrait serait
identique à celui que l'on écrivait pour sa partie informative. Cette
méthode générale avait l'inconvénient d'être peu intuitive et de ne pas
s'intégrer à l'environnement \Coq. Liée à l'extraction interne qui
a disparu dans les dernières versions de \Coq{} (remplacée par la
contribution de Pierre Letouzey \cite{LetouzeyPhD}), elle n'est plus 
maintenue aujourd'hui.

\subsubsection{Types sous-ensemble}
Plutôt que de continuer dans la même direction, nous avons 
cherché à assouplir le système. L'assistant de preuve \PVS{}
\cite{PVS-Semantics} aux capacités similaires à \Coq{}, intègre un
mécanisme dénommé \ps{} que nous allons présenter maintenant.
Tout d'abord une définition:
\begin{definition}[Type sous-ensemble]
  $\subset{x}{T}{P}$ est le type des termes de type $T$ vérifiant la
  propriété $P$.
\end{definition}

Les types sous-ensembles sont d'une grande utilité pour la spécification
de programmes, par exemple pour les pré-conditions:
$\Definition~\sref{div} : \nat "->" \subset{x}{nat}{x \neq 0} "->" \nat$.

L'idée du \ps{} implémenté dans \PVS{}
\cite{ShankarOwreWADT99} est de considérer tout objet de
type $T$ comme un objet de type $\subset{x}{T}{P}$ pour $P$ vraie et
vice-versa. Comme tout objet $t$ de type $T$ ne vérifie pas forcément la
propriété $P$, on génère des ``Type-checking conditions'' (\TCC), c'est
à dire que l'on demande à l'utilisateur de prouver $P[t/x]$ pour assurer
que le programme est correct.

\subsubsection{Coercions}
\PVS{} n'a pas la même architecture que \Coq{}, en particulier il n'y a
pas de termes de preuve et de noyau pour vérifier ces termes. Il faut
donc faire confiance à la quasi-totalité du code pour croire en la
correction des programmes vérifiés. Le critère de {\sc De Bruijn},
qui dit en substance qu'un petit noyau (et celui de \Coq~a même été
formellement vérifié \cite{Barras96a}) est mieux qu'un gros 
n'est pas respecté.
 
Dans notre cas, il faut générer des termes de preuve et donc le code 
correspondant à ce ``sous-typage''. Une littérature importante
\cite{conf/popl/Chen03,conf/csl/Luo96} existe
autour des systèmes à coercions explicites dont nous nous sommes
inspirés pour réaliser la génération des termes. Dans un système à
coercions explicites, on peut faire des abus de notations tels que
utiliser un objet de type $T$ à la place d'un de type $U$, mais
on applique une coercion qui amène l'objet vers le type $U$ avant 
de retyper dans un système sans coercions. Généralement les coercions
sont très similaires à des identités, c'est-à-dire qu'elles sont calculatoirement
insignifiantes mais leur utilisation facilite le développement. Dans
\Coq{} par exemple le système de coercions \cite{saibi97inheritance} a
permis de développer des théories algébriques réutilisables sur
plusieurs structures instantanément (un théorème sur les corps pouvant s'appliquer aux
anneaux par exemple).

\section{Le calcul de coercion par prédicats}
Nous avons développé un langage supportant le \ps{} utilisable dans
\Coq. L'utilisateur peut définir des programmes dans un langage plus
souple puis prouver certains buts pour obtenir finalement un terme de
\CCI{} complet vérifiable par le noyau. On peut finalement utiliser les types dépendants comme des types
simples et s'en occuper dans un deuxième temps (pour la preuve).
L'architecture est la suivante:
on type le programme dans notre langage, puis l'on réécrit le terme typé
dans \CCI{} en laissant des ``trous'' dans les termes et enfin \Coq{} se
charge de générer les obligations correspondant à ces trous.

\subsection{Langage}
Le langage que nous voulons est très proche de \ML, plus les annotations
nécessaires pour avoir un typage précis et décidable.

\subsubsection{Syntaxe}
La syntaxe (figure \ref{fig:syntax}) est directement inspirée des langages fonctionnels.
On part du \lc{} (variables, abstraction et application) puis l'on
ajoute des constantes (pour les entiers, booléens, etc...) ainsi que les
couples. La syntaxe $(x := `a, t : `t)$ permet de
créer des paires dépendantes, de type $\Sigma x : `t. `t$. 

Du côté des types, on a tout d'abord les types simples (constantes,
flèche, produit cartésien) qui sont des cas particuliers du produit ($\Pi$) et
de la somme ($\Sigma$) dépendants. Les variables introduites par ces
types peuvent être utilisées lors des applications de types. On
peut de plus abstraire sur les types avec le $\lambda$ (polymorphisme). 
Enfin on peut appliquer un type à un terme ($`t~`a$). Dans la suite, les règles sont données avec l'idée
qu'on fait les réductions de tête nécessaires pour obtenir un type
d'une certaine forme (produit, somme, sous-ensemble, etc \ldots).

%impossible d'inférer le type $`t$ désiré car il peut dépendre de
%$`a$. Par exemple $(x \Coloneq 1, f x)$
%\vspace{-0.5cm}
\begin{figure}[ht]
  \begin{center}
    \subfigure[Termes]{\termgrammar}\quad
    \subfigure[Types]{\typegrammarOrig}
  \end{center}
  \label{fig:syntax}
  \caption{Syntaxe}
\end{figure}
%\vspace{-1cm}

\subsubsection{Sémantique}
La sémantique du langage nous est donnée par un système de typage, qu'on
formalise par un ensemble de règles d'inférence. Dans notre cas c'est un
un sous-ensemble des règles de \CCI{} auquel on a ajouté une règle de
coercion (\irule{Coerce}) que l'on trouve classiquement dans les systèmes avec
sous-typage avec le nom de subsumption. Cette règle formalise l'idée que 
l'on peut utiliser un terme de type $T$ à la place d'un terme de type
$U$ si $T$ et $U$ sont dans une certaine relation. 
Le jugement $\Gamma \typed t : T$ se lit: dans l'environnement $\Gamma$,
$t$ est de type $T$.

\typenvd
%\vspace{-0.5cm}
\begin{figure}[htb]
  \begin{center}
    \subfigure {\Coerce\DP} %[\protect{\irule{Subsum}}]
    \quad
    \subfigure{\Conv\DP} %[\protect{\irule{Conv}}]
    \quad
    \App\DP
  \end{center}
  \label{fig:typing-decl}
  \caption{Typage déclaratif}
\end{figure}
%\vspace{-1cm}

\CCI{} contient une règle de typage
similaire, la conversion (\irule{Conv}), qui dit essentiellement que deux types
$`b$-convertibles (on rappelle que l'on peut calculer dans les types
puisqu'on a l'abstraction, l'application, etc...) sont équivalents.
On peut directement intégrer cette relation de $`b$-convertibilité à notre
système de coercion comme montré figure \ref{subtyping-decl-rules}
(\irule{SubConv}), à la condition d'avoir l'inclusion
$`=_\beta~\subseteq~\subd + \text{\irule{SubConv}}$.

Notre système de coercion par prédicats permet à l'utilisateur
d'utiliser une valeur de type $U$ là où l'on attend une valeur de type
$\subset{x}{V}{P}$ (\irule{SubProof}) si $U$ est lui-même coercible en $V$.
A l'inverse, on permet aussi d'utiliser une valeur de type
$\subset{x}{U}{P}$ (\irule{SubSub}) à la place d'une valeur de type
$V$ si $U$ est coercible vers $V$. 

Les règles \irule{SubProd} et \irule{SubSigma} permettent de faire des
coercions dans les types composites. Classiquement, la règle pour le 
produit fonctionnel est contravariante (une fonction sous-type d'une
autre accepte plus d'entrées mais donne une sortie plus fine, voir
\name{Castagna} \cite{journals/toplas/Castagna95}) et la règle pour le 
produit cartésien covariante (une paire est coercible en une autre si 
leurs composantes sont coercibles deux-à-deux). 

\subtdShort

Une première propriété montrée habituellement sur le sous-typage est
qu'il est transitif, c'est-à-dire:
\begin{lemma}[Transitivité de la coercion]
  Si $T \sub U$ et $U \sub V$, alors $T \sub V$.
\end{lemma}

Cette règle assure que l'on a un système compositionel. Il y a ici une
analogie avec l'élimination des coupures dans les systèmes logiques, où
l'on montre que toute dérivation utilisant la règle de modus-ponens ($A "=>" B$ et $B "=>" C$ implique
$A "=>" C$) peut se réécrire en une dérivation ne l'utilisant
jamais. Dans les systèmes à sous-typage, on montre de façon équivalente
que l'on peut éliminer la règle de transitivité ; première étape vers un
système décidable.

\subsubsection{Élaboration du système algorithmique \& propriétés}
Pour pouvoir implémenter le typeur, il nous faut un système dirigé par la
syntaxe. 
C'est presque le cas pour la coercion, il y a juste la règle
\irule{SubConv} qu'on peut appliquer à n'importe quel moment. 
On note $\suba$ le même système que figure \ref{subtyping-decl-rules} mais
où l'on n'applique \irule{SubConv} seulement si aucune autre règle ne
s'applique.
On montre le lemme suivant:
\begin{lemma}[Stabilité modulo $\beta$]
  Pour tout $U$, $V$, $U `=_{\beta} V$ alors $U \suba V$ est dérivable.
\end{lemma}

En conséquence $\subd$ et $\suba$ sont équivalentes. Le système
d'inférence de $\suba$ donne donc un algorithme pour décider de la relation
de coercion. L'indéterminisme entre les règles \irule{SubProof} et
\irule{SubSub} ne pose pas de problème: on peut laisser le choix à 
l'implémentation puisque le système est confluent.


Cependant, il reste une source importante d'indécidabilité dans le
système de typage, c'est la règle de coercion. On peut montrer que
toute dérivation de typage utilisant \irule{Coerce} peut se réécrire en
une dérivation n'utilisant cette règle qu'à sa racine ou au niveau de la
prémisse de l'argument de la règle d'application \irule{App}.
On enlève \irule{Coerce} du système et on remplace la règle 
d'application \irule{App} de la figure \ref{fig:typing-decl} par la
règle suivante. On note $\typea$ le système de typage obtenu.

\typenva

\begin{prooftree}
\AppA
\end{prooftree}

On peut ignorer sans perte de généralité 
l'utilisation de la coercion à la racine de la dérivation, 
on fera de toute façon un test de coercion entre le type inféré et le
type spécifié juste avant la réécriture.

On a la propriété suivante entre les deux systèmes:
\begin{lemma}[Équivalence des systèmes déclaratifs et algorithmiques]
  $`G \typed t : T$ \ssi{} il existe $U$ tel que $`G \typea t : U$ et $U \suba T$.
\end{lemma}

Ici $`=$ est l'équivalence syntaxique.
La nouvelle règle d'application est intéressante pour deux raisons.
Primo, c'est là qu'aura lieu le test de coercion, qui générera une
coercion explicite dans le système final. Secundo, on est forcé de
faire une opération supplémentaire pour la fonctionnelle que l'on
applique puisqu'il est possible qu'elle ait un type sous-ensemble,
auquel cas il faut effacer les types sous-ensemble pour trouver son type
fonctionnel (c'est le rôle de la fonction $\mu$, qui fait une mise en
forme normale de tête en effaçant les types sous-ensemble qu'elle
rencontre).

\begin{lemma}[Décidabilité de $\typea$]
  La relation de typage $`G \typea t : T$ est décidable.
\end{lemma}

\subsection{Génération des obligations de preuve}
On a maintenant un système de typage décidable et l'on veut désormais
traduire ses dérivations dans \CCI{} dont le jugement de typage est $\typec$. 

\subsubsection{Définition de la réécriture vers \Coq}
\typenvi
La traduction transforme une dérivation dans notre système algorithmique
vers une dérivation de \CCI{} valide. Le jugement 
$\timpl{`G}{t}{T}{`G'}{t'}{T'}$ se lit: on transforme le séquent
$`G \typea t : T$ (système algorithmique) en $`G' \typec t' : T'$
(\Coq). Le jugement $\subimpl{`G}{c}{T}{U}$ se lit: la coercion de $T$ à
$U$ est $c$ et on construit le séquent $`G \typec c : T "->" U$.
La traduction est un homomorphisme (elle conserve la structure de la
dérivation et se rappelle récursivement) excepté pour l'application, ce qui
est normal puisque nous avons un système très proche de \CCI{}. Le fait
de traduire aussi les environnements $\Gamma$ est dû au fait que nous
faisons la coercion dans les types,  donc les environnements (listes
de couples $(\text{nom}, \text{type})$) doivent aussi être réécrits. Cela assure aussi la
cohérence avec l'environnement général de \Coq, c'est-à-dire
l'intégration transparente de notre tactique dans les développements
\Coq~et la réutilisabilité des programmes générés. En conséquence, les
types spécifiés ne sont donc pas toujours préservés (on veut pouvoir y
introduire des coercions).

\begin{prooftree}
\AppI
\end{prooftree}

Ici la fonction $\mu$ renvoie à la fois un type (qu'on demande
équivalent à un produit) et une fonction de coercion qui va faire les
projections nécessaires sur l'objet \Coq~$f'$. En effet dans \Coq~les
objets de type sous-ensemble $\subset{x}{T}{P}$ sont codés par un terme 
de la forme $\sref{elt}~t~p$ dont on peut extraire les parties objet 
(un certain $t$ de type $T$, par la projection $\Pi_1$) et preuve
 (de type $P[t/x]$). Il faut donc faire exactement
une projection pour atteindre par exemple la fonction d'un objet de type
 $\subset{f}{\nat "->" \nat}{f~0 \neq 0}$.

Le jugement de coercion $U \suba V$ nous assure qu'il est possible de
dériver le jugement $`G' \typec U' \subi V'$ et donc de créer une coercion de $U'$
à $V'$ soit une fonction de type $U' "->" V'$ dans \CCI.
On trouve ici l'essence du mécanisme de coercion par prédicats. 

\vspace{1.4em}
\begin{itemize}
\item[ \SubConvI\DP:] \quad\\

  Crée une coercion identité puisque \CCI{}~a la règle de conversion. 
  \vspace{1em}

\item[\SubLeftI\DP:] \quad\\
  
  Engendre une projection,
  c'est le cas où l'on ne s'intéresse pas à la preuve accompagnant
  l'objet. 
  \vspace{1em}

\item[\SubRightI\DP:] \quad\\

  Correspond à la génération d'une
  obligation de preuve dans \PVS. On utilise le mécanisme des variables
  existentielles (notées $?:\text{type}$) décrit plus loin pour donner 
  l'information au système qu'il faut compléter le terme à un endroit
  donné avec un nouveau terme de type approprié. On peut aisément créer
  des obligations qui ne seront pas prouvables mais cela relève de la
  responsabilité de l'utilisateur.
  \vspace{1em}

\item[\SubProdI\DP,] \quad\\
  

\item[\SubSigmaI\DP:] \quad\\

  Réalisent respectivement
  les coercions pour les produits fonctionnels et cartésiens.

\end{itemize}
  
\subsubsection{Propriétés}
On veut montrer que si l'on a une dérivation dans notre système
algorithmique, alors son image par la réécriture est une dérivation
valide de \CCI{} (par induction sur la dérivation dans le système
algorithmique). Ce travail est en cours à ce jour, nous nous sommes
plutôt penchés sur l'implémentation du typeur et de la fonction de
réécriture avant de commencer cette dernière preuve.

\subsection{La tactique \Subtac}
Nous avons développé la tactique \Subtac{} disponible dans la version
\CVS{}~courante de \Coq{} (\url{http://coq.inria.fr}). Elle permet de
créer un programme, le typer et générer un terme incomplet
correspondant (voir annexe \ref{fig:euclid-subtac}). 

\subsubsection{Existentielles}
La génération des buts correspondant aux variables existentielles et la
formation du terme final sont laissées à la tactique \Refine~et au
système de gestion des existentielles de \Coq. Certaines limitations 
dans l'implémentation du raffinement (le mécanisme permettant de manipuler
des termes ``à trous'') devront être dépassées pour obtenir
une contribution totalement fonctionnelle. On peut cependant espérer
résoudre ces problèmes de façon satisfaisante dans un futur proche.

\subsubsection{Traitement de la récursion}
Lorsque l'on développe un programme récursif dans un système tel que
\Coq, on est forcé de fournir une preuve de terminaison de son
algorithme. Pour cela, on montre généralement qu'on a un ordre bien
fondé sur le type de l'argument de récursion et que chaque appel respecte
cet ordre. Nous avons ajouté des facilités d'écriture de fonctions
récursives à notre langage ; on ajoute les existentielles
correspondant aux preuves que l'ordre est bien fondé ou qu'il est bien
respecté par les termes. Ainsi lors du raffinement on obtient naturellement
les buts correspondants à prouver.

\subsubsection{Traitement des inductifs}
Notre langage ne prend pas encore en compte les définitions inductives générales.
Au-delà du traitement des types sous-ensemble, on a un support minimal
pour les inductifs à deux constructeurs qui correspondent à des booléens
annotés par des propriétés logiques (voir traitement de la
conditionnelle figure \ref{fig:euclid-subtac}). 

\section{Conclusion}
Nous avons développé un langage de programmation plus souple que le
langage de \Coq{} mais conservant sa richesse d'expression (types
dépendants). Il permet de découpler la description algorithmique de la
vérification. La correction des termes engendrés est
garantie par le système sous-jacent qui offre ensuite la possibilité
d'extraire un programme correct par construction dans un langage de type
\ML. D'autre part, cette méthode s'intègre bien dans l'environnement
\Coq{} et ouvre la voie à la réalisation de travaux plus complexes par
des utilisateurs non-experts. Cela constitue la première étape vers un
environnement de programmation sûre utilisable dans \Coq. 


\bibliographystyle{plain}
\bibliography{../bib/bib-joehurd,../bib/barras,../bib/pvs-bib,../bib/bcp,../bib/Luo,subset-typing,../bib/cparent/cparent}

\renewcommand{\thefootnote}{}
\footnotetext{Ce rapport a été préparé sous \LaTeX~avec la fonte 
  \texttt{Concrete Math}}

\newpage
\appendix
\section{Exemples}
\begin{figure}[h]
\begin{verbatim}
(* Subtac ne gère pas encore les notations de Coq *)
Definition neq (A : Type) (x y : A) : Prop := x <> y.
Definition div_prop (a b q r : nat) := a = (b * q) + r /\ r < b. 
Definition lt_ge_dec (x y : nat) : { x < y } + { x >= y }.
Proof.
  intros ; elim (le_lt_dec y x) ; intros ; auto with arith.
Defined.

Recursive program mydiv (a : nat) { well_founded lt a lt_wf } : { b : nat | neq nat b O } ->
  [ q : nat ] { r : nat | div_prop a b q r } :=
  fun { y : nat | neq nat y O } =>
    if lt_ge_dec a y
    then (q := O, a : { r : nat | div_prop a y q r })
    else let (q', r) = mydiv (minus a y) y in 
        (q := S q', r : { r : nat | div_prop a y q r }).

(* Dans Coq, mydiv aura le type:
forall a : nat, forall b : { b : nat | b <> 0 },
 { q : nat & { r : nat | div_prop a (proj1_sig b) q r } } *)

(* Obligations de preuves engendrées *)
(* Hypothèses communes: *)
a : nat
mydiv : (n : nat) n < a -> forall b : { b : nat | b <> 0 },
 { q : nat & { r : nat | div_prop n (proj1_sig b) q r } }
y : { b : nat | b <> 0 }

(* (q := 0, a ...)
[ H : a < proj1_sig y,
|- div_prop a (proj1_sig y) 0 a]

(* Argument de récursion *)
[H : a >= proj1_sig y |- a - proj1_sig y < a]

(* (q := S q', r) *)
[ H : a >= proj1_sig y
  q' : nat
  r : { r : nat | div_prop (a - proj1_sig y) (proj1_sig y) q' r }
|- div_prop a (proj1_sig y) (S q')  (proj1_sig r)]
\end{verbatim}
  \label{fig:euclid-subtac}
  \caption{La division euclidienne avec \Subtac}
\end{figure}

\begin{figure}[h]
\begin{verbatim}
Definition div : forall a : nat, forall b : nat, 
  b <> 0 -> { q : nat & { r : nat | r < b /\ a = b * q + r } }.
Proof.
intros a ; pattern a ; apply lt_wf_rec ; intros. (* Récursion *)
elim (lt_ge_dec n b). (* If then else *)
intros. (* Première branche *)
(* Structure du terme *)
refine (existS _ 0 _) ; refine (exist _ n _) ; refine (conj _ _) ;
[ assumption | rewrite mult_0_r ; rewrite plus_0_l ; reflexivity ]. (* Preuve *)
(* Seconde branche *)
intros ; assert (n - b < n). (* Preuve pour l'appel *)
apply lt_minus ; [ apply (ge_le _ _ b0) | apply (nat_neq_0_gt_0 b H0) ].
induction (H (n - b) H1 b H0). (* Appel récursif *)
induction p ; induction p. (* Destruction du résultat *)
refine (existS _ (S x) _) ; refine (exist _ x0 _). (* Structure du terme *)
(* Preuve *)
split.
assumption.
pose (eq_plus_eq _ _ H3 b).
assert (n - b + b = n) ; try omega.
rewrite <- H4 ; rewrite e ; rewrite plus_comm ; rewrite plus_assoc.
replace (b + b * x) with (b * S x).
reflexivity.
rewrite mult_comm ; simpl ; pattern (x * b) ; rewrite mult_comm.
reflexivity.
Qed.
\end{verbatim}
  \label{fig:euclid-script}
  \caption{Script de preuve de la division euclidienne}
\end{figure}

\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "subset-typing-short"
%%% LaTeX-command: "x=pdf; TEXINPUTS=\"style:$TEXINPUTS\" ${pdfx}latex"
%%% End: 
