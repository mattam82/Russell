\documentclass[a4paper,10pt]{article}
\usepackage[francais]{babel} 
\usepackage[latin1]{inputenc}  %% les accents dans le fichier.tex
\usepackage[T1]{fontenc}       %% Pour la c\'{e}sure des mots accentu\'{e}s
\usepackage{indentfirst}
%\usepackage[dvips]{graphicx}
%\usepackage{coqdoc}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{array}
\usepackage{myabbrevs}
\usepackage{abbrevs}
%\usepackage{bnf}
\usepackage{bussproofs}
\usepackage{hyperref}
\usepackage{fullpage}
\usepackage{concmath}
%\usepackage{cmbright}
\usepackage{fancyhdr}
\usepackage{ifthen}
\usepackage{ifmtarg}
\usepackage{pxfonts}
\usepackage{pgf}
\usepackage{subfigure}

% This is the "centered" symbol
\def\fCenter{\vdash}
\def\seq{\fCenter}
% Optional to turn on the short abbreviations
\EnableBpAbbreviations

\oddsidemargin -1cm
\topmargin -1cm
\headsep 5mm
\textwidth 18cm
\textheight 24cm

\input{mathenv}
\input{typing-macros}

\setboolean{displayLabels}{true}

\input{grammar-macros}

\input{typing-decl}
\input{subtyping-decl}
\input{typing-algo}
\input{subtyping-algo}
\input{typing-impl}
\input{subtyping-impl}

\pgfdeclareimage[height=3cm]{lambda-cube}{pictures/lambda-cube}

\newcommand{\src}[1]{\texttt{#1}}
\newcommand{\srcm}[1]{\text{\texttt{#1}}}
%\newcommand{\Set}{\ensuremath{\text{\texttt{Set}}}}

\def\thetitle{Sous-typage par prédicats en \Coq}

\pagestyle{plain}
\fancyhead[RO,L]{\thetitle}
\fancyfoot[C]{\thepage}

\title{\thetitle}

\author{Matthieu Sozeau}

\date{\today}

\begin{document}

\maketitle

\begin{abstract}
  Dans un assistant de % à la 
  preuve tel que \Coq, la grande %haute
  expressivité du langage
  de spécification et d'implémentation est nécessaire pour pouvoir
  traiter le plus large éventail de problèmes. En contrepartie, les
  programmes sont plus difficiles à écrire et maintenir que dans un pur
  langage de programmation de type \ML. Pour remédier à
  ce problème, on propose un nouveau langage, moins puissant, mais
  s'intégrant parfaitement à l'environnement de développement existant,
  qui permet l'écriture rapide de programmes et découple les parties codage et
  preuve.
\end{abstract}

\section*{Introduction}

Nous souhaitons intégrer un langage de programmation ...

\subsection*{Présentation de \Coq}

\Coq~est un assistant de preuve dont la première version date de 1985,
et qui est aujourd'hui développé dans le projet \LogiCal{} (INRIA, LIX,
LRI, CNRS). Originellement basé sur le Calculs des Constructions (\CoC),
il a été étendu par le \CCIfull~(\CCI) et contient aujourd'hui de
nombreuses améliorations telles qu'un système sophistiqué d'extraction
de programmes ou encore des procédures de décision pour aider à la
preuve.

Le développement de \Coq~est intimement lié à l'isomorphisme de {\sc
Curry-Howard} qui montre le lien entre certaines logiques et calculs. Il
s'agissait à l'époque de montrer qu'élaborer une preuve en logique
intuitioniste de premier ordre était équivalent à écrire un terme du
\lc~simplement typé (\lcst). Par exemple, montrer que $A "=>" A$ pour un
certain $A$ revient à écrire la fonction identité $\lambda x : A. x$ qui
a bien pour type $A "->" A$. Cette dualité ce reflète aussi à
l'utilisation.

Il existe une classification des \lc{} découverte par Henk Barendregt,
qui montre bien où se situe le calcul sous-jacent à \Coq{} par rapport à
\lcst.
%\vspace{-0.5cm}
\begin{figure}[h]
  \begin{center}
    \pgfuseimage{lambda-cube}
  \end{center}
  \label{Le ``Lambda cube''}
\end{figure}
%\vspace{-1cm}

On voit ici que le \CCIfull{} est un \lc{} très expréssif, puisqu'il
intègre toutes les extensions. Nous allons montrer ce qu'elles
permettent du point de vue des preuves et des programmes.

% \begin{array}[l|c|c]
%   & Preuves Mathématiques & Programmes Informatiques \\
%   Polymorphisme & Quantification universelle sur les ensembles & 
%   Abstractions sur les types \\
%   Ordre supérieur & Quantification sur les prédicats &
%   Abstractions dans les types (rare) \\
%   Types dépendants & Quantification sur les éléments d'un ensemble & 
%   \\
% \end{array}

  
% (PVS, ...)

\subsubsection*{Preuve}
\Coq{} est utilisé le plus souvent pour élaborer des théories
mathématiques prouvées mécaniquement. Dans cette optique, l'utilisateur 
modélise un problème par des structures mathématiques et veut prouver
certaines propriétés sur ce modèle (par exemple la preuve du théorême
des quatres couleurs \cite{Gonthier4col} récemment terminée utilisait des résultats de
géométrie algébrique).

Pour prouver un but sous certaines hypothèses, on utilise des
tactiques qui simulent un raisonement déductif pour l'utilisateur. % LCF-style ?
Celles-ci permettent par exemple d'introduire une hypothèse: pour le but
$A "=>" A$ on peut introduire l'hypothèse $H : A$ ; ou bien d'en appliquer une: en
appliquant l'hypothèse $H$ on prouve le but directement.
% Figure ?
Ces tactiques peuvent être d'une complexité arbitraire mais nous avons
l'assurance de la correction d'une preuve par des propriétés du langage
sous-jacent.

%- Preuve par tactiques, procédurale.
%- Déduction naturelle (exemple ?)

% => Développements mathématiques (logiques).

\subsubsection*{Programmes}
Les tactiques utilisées pour créer des preuves ne sont en fait qu'une
sorte de sucre au-dessus du noyau de \Coq{} qui se réduit à un typeur
pour \CCI. A la fin d'une preuve, on a en effet construit un terme 
($\lambda x : A. x$ dans notre exemple) que l'on va soumettre au typeur
dont le but est de vérifier qu'il est bien de type $A "->" A$.
Si le typage réussi, on obtient une preuve \emph{constructive} de notre
but. 

D'un point de vue preuve de programmes, on a donc un environnement qui
permet de vérifier qu'un programme (un terme du calcul) vérifie une
certaine spécification (son type). Avec un langage aussi expressif, on
peut prouver des propriétés complexes sur des programmes polymorphes à
la \ML. 

A l'inverse, on peut extraire un programme de toute preuve puisque nous
sommes dans une logique constructive.

% - Lambda calcul avec types dépendants, polymorphisme et ordre supérieur
% (lambda cube)
% - Correspond à la logique intuitioniste
% - Preuve = habitant d'un type.

% => Permet de développer des programmes. Développement informatiques
% (calculatoires)

\subsection*{Motivation}

\Coq{} permet de développer des programmes complexes,
de leur donner des spécifications fortes et de les vérifier
automatiquement. On peut même extraire de ces dévelopemments des
programmes corrects par construction. Il y a cependant certaines
difficultés à développer en \Coq{} que nous allons étudier maintenant.

\subsubsection*{Un langage trop expressif?} 
\def\Definition{\text{Definition}}
\def\sref#1{\text{#1}}

Le langage de \CCI{} permet de bien spécifier des fonctions non
triviales, par exemple:
\begin{figure}[h]
  $\Definition~\text{qsort} : (\sref{compare} : (x : A)(y : A)~ \{ x
  < y \} + \{ x \geq y \}) 
  (l : \sref{list}~A) \{ l' : \sref{list}~A~|~\sref{permut}~l~l' `^
  \sref{sorted}~\sref{compare}~l' \}.$
  \caption{Spécification de l'algorithme ``quicksort''}
\end{figure}

En revanche, le terme de preuve correspondant est nettement plus long,
et ne peut simplement pas être écrit d'une traite sans une expertise
approfondie (voir \TODO{Annexe}). Pour remédier à ce problème, on
utilise des tactiques qui permettent d'écrire la preuve/programme
incrémentalement (\TODO{script de preuve}). L'inconvénient de cette
méthode est que l'on obtient pas toujours le programme désiré
au départ, puisque les tactiques cachent profondément leur effet sur le
terme de preuve. Certaines techniques de réecriture peuvent aussi
générer des termes de complexité algorithmique bien moins optimale que
ce que l'utilisateur écrirait. 

\subsubsection*{Mélange logique et calcul}
Une difficulté essentielle lorsque l'on veut permettre à des
utilisateurs non experts de développer dans \Coq{} est le ``mélange
des genres'' permanant entre logique et calcul. Pour appliquer une
fonction division qui attend un dénominateur différent de $0$ par
exemple, il faut passer à la fois l'argument lui même, mais aussi une
preuve de sa non-nullité. Lorsque l'on a l'habitude de programmer, ça
n'est pas la chose la plus naturelle et l'on aimerait pouvoir découpler
les parties codages et preuve pour simplement diviser le problème.

\subsubsection*{Objectif}
A long terme, on souhaite permettre à un utilisateur de programmer dans
un langage proche de \ML{} et de prouver ses programmes dans un deuxième
temps à l'aide de \Coq{}. Une fois les preuves terminées, on peut
extraire un programme correct par construction et essentielement
équivalent à celui de départ.

% - Features
% - Extraction..

% - Utilisation académique et real-world.

% \subsubsection*{Difficultés}

% - Besoin d'expertise pour dev des programmes:
%   - Verbosité
%   - Mélange logique et calcul

\subsection*{Travaux Connexes}

La preuve de programmes fonctionnels est un domaine de recherche actif
(cite?), de mê
Il existe un travail réalisant une partie de nos objectif
qui a été réalisé dans \Coq{}.
\subsubsection*{La tactique \Program}
Développée par Catherine Parent \cite{conf/mpc/Parent95}, 
la tactique \Program{} permettait de synthétiser des preuves à partir de
programmes. L'idée était de trouver un langage de programmation
suffisament restrictif pour réaliser une inversion de l'extraction, 
c'est à dire, à partir d'un terme essentiellement calculatoire
(des annotations étaient nécessaires), retrouver un terme de preuve
réalisant la spécification donnée. 
A partir de là, on était assuré que le programme extrait serait
identique à celui que l'on écrivait pour sa partie informative. Cette
méthode générale avait l'inconvénient de donner des termes difficiles à
prouver et n'a pas été maintenue depuis. 

\subsubsection*{Types sous-ensemble}
Plutôt que de continuer dans la meme direction, nous avons 
cherché à assouplir le système. L'assistant de preuve \PVS{}
\cite{PVS-Semantics} au capacités similaires à \Coq, intègre un
mécanisme dénommé \ps{} que nous allons présenter maintenant.
Tout d'abord une définition:
\begin{definition}[Type sous-ensemble]
  $\subset{x}{T}{P}$ est le type des termes de type $T$ vérifiant la
  propriété $P$.
\end{definition}

Les types sous-ensembles sont d'une grande utilité pour la spécification
de programmes, par exemple pour les pré-conditions:
$\Definition~\sref{div} : \nat "->" \subset{x}{nat}{x \neq 0} "->" \nat$.

L'idée du \ps implémenté dans PVS
(\cite{ShankarOwreWADT99,Rushby98TSE}) est de considérer tout objet de
type $T$ comme un objet de type $\subset{x}{T}{P}$ pour $P$ vraie et
vice-versa. Comme tout objet $t$ de type $T$ ne vérifie pas forcément la
propriété $P$, on génére des ``Type-checking conditions'' (\TCC), c'est
à dire que l'on demande à l'utilisateur de prouver $P[t/x]$ pour assurer
que le programme est correct.

\subsubsection*{Coercions}
\PVS{} n'a pas la même architecture que \Coq{}, en particulier il n'y a
pas de termes de preuve et de noyau pour vérifier ces termes. Il faut
donc faire confiance à la quasi-totalité du code pour croire en la
correction des programmes vérifiés. Le critère de {\sc De Bruijn},
qui dit en substance qu'un petit noyau (et celui de \Coq~a meme été
formellement vérifié \cite{Barras96a}) est mieux qu'un gros 
n'est pas respecté.
 
Dans notre cas, il faut générer des termes de preuve et donc le code 
correspondant à ce ``sous-typage''. Une littérature importante existe
autour des systèmes à coercions explicites dont nous nous sommes
inspirés pour réaliser l'engendrement des termes. Dans un système à
coercions explicites, on peut faire des abus de notations tels que
utiliser un objet de type $T$ à la place d'un de type $U$, mais
on applique une coercion qui amène l'objet vers le type $U$ avant 
de retyper dans un système sans coercions. Généralement les coercions
sont très similaires à des idéntités, c'est-à-dire qu'elles sont calculatoirement
insignifiantes mais leur utilisation facilite le développement. Dans
\Coq{} par exemple le système de coercions a permis de développer un
des théories algébriques réutilisables sur plusieurs structures
instantanément (un théoreme sur les corps pouvant s'appliquer aux
anneaux par exemple).
\cite{conf/popl/Chen03, saibi97inheritance}

\section*{La tactique \Subtac}
Nous avons développé un langage supportant le \ps{} utilisable dans
\Coq. L'utilisateur peut définir des programmes dans un langage plus
souple puis prouver certains buts pour obtenir finalement un terme de
\CCI{} complet vérifiable par le noyau.

\subsection*{Langage}
Le langage que nous voulons est très proche de \ML, plus les annotations
nécessaires pour avoir un typage précis et décidable.

\subsubsection*{Syntaxe}
La syntaxe (figure \ref{fig:syntax}) est directement inspirée des langages fonctionnels.
On part du \lc{} (variables, abstraction et application) puis l'on
ajoute des constantes (pour les entiers, booléens, etc...) ainsi que les
couples. La syntaxe $(x := `a, t : `t)$ permet de
créer des paires dépendantes, de type $`E x : `a. `t$. 

Du côté des types, on a tout d'abord les types simples (constantes,
flèche, produit cartésien) qui sont des cas particuliers du produit ($\Pi$) et
de la somme ($\Sigma$) dépendants. Les variables introduites par ces
types peuvent être utilisées lors des applications de types. On
peut de plus abstraire sur les types eux-mêmes, donc on a une
abstraction dans les types aussi. Enfin on peut appliquer un type à un
terme ($`t~`a$).

%impossible d'inférer le type $`t$ désiré car il peut dépendre de
%$`a$. Par exemple $(x \Coloneq 1, f x)$
\vspace{-0.5cm}
\begin{figure}[thb]
  \begin{center}
    \subfigure[Termes]{\termgrammar}\quad
    \subfigure[Types]{\typegrammarOrig}
  \end{center}
  \label{fig:syntax}
\end{figure}
\vspace{-1cm}

\subsubsection*{Sémantique}
La sémantique du langage nous est donnée par un système de typage, qu'on
formalise par un ensemble de règles d'inférence. Dans notre cas c'est un
un sous-ensemble des règles de \CCI{} auquel on a ajouté une règle de
subsumption que l'on trouve classiquement dans les systèmes avec
sous-typage. Cette règle formalise l'idée que l'on peut utiliser un
terme de type $T$ à la place d'un terme de type $U$ si $T$ et $U$ sont
dans une certaine relation. 

\typenvd
\vspace{-0.5cm}
\begin{figure}[thb]
  \begin{center}
    \subfigure {\Subsum\DP} %[\protect{\irule{Subsum}}]
    \quad
    \subfigure{\Conv\DP} %[\protect{\irule{Conv}}]
  \end{center}
\end{figure}
\vspace{-1cm}

\CCI{} contient une règle de typage
similaire, la conversion, qui dit essentiellement que deux types
$`b$-convertibles (on rappelle que l'on peut calculer dans les types
puisqu'on a l'abstraction, l'application, etc...) sont équivalents.
On peut directement intégrer cette relation de $`b$-convertibilité à notre
système de sous-typage comme montré figure \ref{subtyping-decl-rules}
(\irule{SubConv}), à la condition que les autres règles la conserve bien. 

Notre système de sous-typage par prédicats permet à l'utilisateur
d'utiliser une valeur de type $U$ là où l'on attend une valeur de type
$\subset{x}{V}{P}$ (\irule{SubProof}) si $U$ est un sous-type de $V$.
A l'inverse, on permet aussi d'utiliser une valeur de type
$\subset{x}{U}{P}$ (\irule{SubSub}) à la place d'une valeur de type
$V$ si $U$ est sous-type de $V$. 

Les règles \irule{SubProd} et \irule{SubSigma} permettent de faire du
sous-typage dans les types composites. Classiquement \note{pas vrai dans
  PVS}, la règle pour le 
produit fonctionel est contravariante (une fonction sous-type d'une
autre accepte plus d'entrées mais donne une sortie plus fine, voir
\name{Castagna} \cite{journals/toplas/Castagna95}) et la règle pour le produit cartésien covariante 
(une paire est sous-type d'une autre si leurs composantes sont
sous-types deux-à-deux). La dernière règle formalise la transitivité du
sous-typage, c'est une règle que l'on veut éliminer mais qui assure que
l'on a un système compositionel (il y a ici une analogie avec
l'élimination des coupures dans les systê

\subtdShort

\subsubsection*{Elaboration du système algorithmique \& Propriétés}
Pour pouvoir typer des termes, il nous faut un système décidable, ce qui
n'est déjâ pas le cas pour le sous-typage puisque la règle
\irule{SubTrans} peut être utilisée à l'infini lorsque l'on cherche à
montrer qu'il existe une dérivation de n'importe quel but. Ce problème
est résolu en montrant l'élimination de la transitivité, c'est-à-dire en
prouvant que toute dérivation utilisant \irule{SubTrans} peut-être
transformée en une dérivation ne l'utilisant pas. Pour \irule{SubConv},
on peut n'appliquer le test de conversion que lorsque plus aucune règle
ne s'applique, puisque les règles conservent la convertibilité.

Cependant, il reste une source importante d'indécidabilité dans le
système de typage, c'est la règle de subsumption. On peut montrer que
toute dérivation de typage utilisant \irule{Subsum} peut se réecrire en
une dérivation n'utilisant cette règle qu'à sa racine ou au niveau de la
prémisse de l'argument de la règle d'application \irule{App}.

\typenva

\begin{prooftree}
\AppA
\end{prooftree}

La nouvelle règle d'application est intéressante pour deux raisons.
Primo, c'est là qu'aura lieu le test de subsumption, qui génerera une
coercion explicite dans le système final. Secundo, on est forcés de
faire une opération supplémentaire pour la fonctionelle que l'on
applique puisqu'il est possible qu'elle est un type sous-ensemble,
auquel cas il faut l'``extraire'' pour trouver son type
fonctionnel (c'est le rôle de la fonction $\mu$).

\subsection*{Réécriture vers \Coq}
On a maintenant un système de typage décidable et l'on veut désormais
traduire ses dérivations dans \CCI{}. 

\subsubsection*{Définition}
La traduction est un homomorphisme (elle conserve la structure de la
dérivation et se rappelle récursivement) excepté pour l'application, ce qui
est normal puisque nous avons un système très proche de \CCI{}. 

\typenvi
\begin{prooftree}
\AppI
\end{prooftree}

Ici la fonction $\muterm$ renvoie à la fois un type (qu'on demande
équivalent à un produit) et une fonction de coercion qui va faire les
projections nécessaires sur l'objet \Coq~$f'$. En effet dans \Coq~les
objets de type sous-ensemble $\subset{x}{T}{P}$ sont codés par un terme 
dont on peut extraire les parties objet (un certain $t$ de type $T$) et
preuve (de type $P[t/x]$). Il faut donc faire une projection pour
atteindre par exemple la fonction d'un objet de type $\subset{f}{\nat
  "->" \nat}{f~0 \neq 0}$.

Le jugement de sous-typage $U \sub V$ est utilisé pour construire une
coercion de $U$ à $V$, donc une fonction de type $U "->" V$.

\subtiShort

On trouve ici l'essence du mécanisme de sous-typage par prédicats. La
règle \irule{SubConv} crée une coercion idéntité puisque \CCI{}~a la
règle de conversion. La règle \irule{SubLeft} engendre une projection,
c'est le cas où l'on ne s'intéresse pas à la preuve accompagnant
l'objet. La règle \irule{SubRight} correspond à la génération d'une
obligation de preuve dans \PVS. On utilise le mécanisme des variables
existentielles (notées $?:\text{type}$) décrit plus loin pour donner 
l'information au système qu'il faut completer le terme à un endroit
donné avec un nouveau terme de type approprié. Il est donc possible 
de créer des termes ininstantiables. 
Les règles \irule{SubProd} et \irule{SubSigma} réalisent respectivement
les coercions pour les produits fonctionnels et cartésiens.

\subsubsection*{Propriétés}
On veut montrer que si l'on a une dérivation dans notre système
algorithmique, alors son image par la réecriture est une dérivation
valide de \CCI. Ce travail est en cours à ce jour, nous nous sommes
plutôt penchés sur l'implémentation du typeur et de la fonction de
réecriture avant de commencer cette dernière preuve.

\subsection*{Implémentation}
Nous avons développé la tactique \Subtac{} disponible dans la version
\CVS{} courante de \Coq{} (\url{http://coq.inria.fr}). Elle permet de
créer un programme, le typer et générer un terme incomplet
correspondant. 

\subsubsection*{Existentielles}
La génération des buts correspondants aux variables existentielles et la
formation du terme final sont laissées à la tactique \Refine~et au
système de gestion des existentielles de \Coq. Certaines limitations 
dans l'implémentation du raffinement (le mécanisme permettant de manipuler
des termes ``à trous'') devront être dépassées pour obtenir
une contribution totalement fonctionnelle. On peut cependant espérer
résoudre ces problèmes de façon satisfaisante dans le futur.

\subsubsection*{Traitement de la récursion}
Lorsque l'on développe un programme récursif dans un système tel que
\Coq, on est forcé de fournir une preuve de terminaison de son
algorithme. Pour cela, on montre généralement qu'on a un ordre bien
fondé sur le type de l'argument de récusion et que chaque appel respecte
cet ordre. Nous avons ajouté des facilités d'écriture de fonctions
récursives à notre langage ; on ajoute les existentielles
correspondant aux preuves que l'ordre est bien fondé ou qu'il est bien
respecté aux termes. Ainsi lors du raffinement on obtient naturellement
les buts correspondants à prouver.

\section*{Conclusion}



\bibliographystyle{mybib}
\bibliography{../bib/bib-joehurd,../bib/barras.bib,../bib/pvs-bib,../bib/bcp,../bib/Luo,subset-typing,../bib/cparent/cparent.bib}

\renewcommand{\thefootnote}{}
\footnotetext{Ce rapport a été préparé sous \LaTeX~avec la fonte 
  \texttt{Computer Modern Bright}}

\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "subset-typing-short"
%%% LaTeX-command: "x=pdf; TEXINPUTS=\"style:$TEXINPUTS\" ${pdfx}latex"
%%% End: 
