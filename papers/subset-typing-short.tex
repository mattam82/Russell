\documentclass[a4paper,10pt]{article}
\usepackage[francais]{babel} 
\usepackage[latin1]{inputenc}  %% les accents dans le fichier.tex
\usepackage[T1]{fontenc}       %% Pour la c\'{e}sure des mots accentu\'{e}s
\usepackage{indentfirst}
%\usepackage[dvips]{graphicx}
%\usepackage{coqdoc}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{array}
\usepackage{myabbrevs}
\usepackage{abbrevs}
%\usepackage{bnf}
\usepackage{bussproofs}
\usepackage{hyperref}
\usepackage{fullpage}
\usepackage{concmath}
%\usepackage{cmbright}
\usepackage{fancyhdr}
\usepackage{ifthen}
\usepackage{ifmtarg}
\usepackage{pxfonts}
\usepackage{pgf}
\usepackage{subfigure}

% This is the "centered" symbol
\def\fCenter{\vdash}
\def\seq{\fCenter}
% Optional to turn on the short abbreviations
\EnableBpAbbreviations

\oddsidemargin -1cm
\topmargin -1cm
\headsep 5mm
\textwidth 18cm
\textheight 24cm

\input{mathenv}
\input{typing-macros}

\setboolean{displayLabels}{true}

\input{grammar-macros}

\input{typing-decl}
\input{subtyping-decl}
\input{typing-algo}
\input{subtyping-algo}
\input{typing-impl}
\input{subtyping-impl}

\pgfdeclareimage[height=3cm]{lambda-cube}{pictures/lambda-cube}

\newcommand{\src}[1]{\texttt{#1}}
\newcommand{\srcm}[1]{\text{\texttt{#1}}}

\def\thetitle{Coercion par prédicats en \Coq}

\pagestyle{plain}
\fancyhead[RO,L]{\thetitle}
\fancyfoot[C]{\thepage}

\title{\thetitle}

\author{Matthieu Sozeau \\ sous la direction de Chistrine Paulin}

\date{\today}

\begin{document}

\maketitle

\begin{abstract}
  \Coq{} est un assistant de preuve d'une grande expressivité pour le
  développement de théories mathématiques et informatiques, ce qui permet
  de traiter un large éventail de problèmes. Le langage de \Coq{},
  constitué d'un noyau fonctionnel de type \ML{} enrichi par les types
  dépendants, permet de spécifier, vérifier puis
  extraire des programmes corrects par construction. En contrepartie, les
  programmes sont plus difficiles à écrire et maintenir que dans un pur
  langage de programmation de type \ML, puisqu'ils mélangent les parties
  logiques et calculatoires. Pour remédier à
  ce problème, on propose un nouveau langage de programmation,
  s'intégrant parfaitement à l'environnement de développement existant,
  qui permet de découpler les parties codage et preuve.
\end{abstract}

\tableofcontents

\newpage
\section{Introduction}

Nous nous plaçons dans le cadre du système d'aide à la preuve \Coq{},
auquel nous souhaitons intégrer un langage de programmation plus souple
que le langage actuellement utilisé.

\subsection{Présentation de \Coq}

\Coq~est un assistant de preuve dont la première version date de 1985,
et qui est aujourd'hui développé dans le projet \LogiCal{} (INRIA, LIX,
LRI, CNRS). Originellement basé sur le Calcul des Constructions (\CoC),
il a été étendu au \CCIfull~(\CCI) et contient aujourd'hui de
nombreuses améliorations telles qu'un système sophistiqué d'extraction
de programmes ou encore des procédures de décision pour automatiser la
preuve.

Le développement de \Coq~est intimement lié à l'isomorphisme de {\sc
Curry-Howard} qui montre le lien entre logique intuitionniste et calcul. Cet
isomorphisme établit qu'élaborer une preuve du calcul propositionel
intuitioniste est équivalent à écrire un terme du
\lc~simplement typé (\lcst). Par exemple, montrer que $A "=>" A$ pour un
certain $A$ revient à écrire la fonction identité $\lambda x : A. x$ qui
a bien pour type $A "->" A$. Chaque logique constructive est donc
associée à un \lc{} particulier. Dans \Coq{}, on utilise cet
isomorphisme pour vérifier les preuves. Le noyau est simplement un
typeur pour \CCI{}. Si on peut typer un terme $t$ de type $T$, alors on est
assuré d'avoir trouvé une preuve constructive $t$ de la formule $T$.
Cette dualité ce reflète aussi à l'utilisation de \Coq{} où l'on a 
les deux visions: logique (développement mathématique, preuve) et 
calcul (développement informatique, programme).

\subsubsection{Preuve}
\Coq{} est utilisé le plus souvent pour élaborer des théories
mathématiques prouvées mécaniquement. Dans cette optique, l'utilisateur 
modélise un problème par des structures mathématiques et veut prouver
certaines propriétés sur ce modèle (par exemple la preuve du théorême
des quatres couleurs récemment terminée \cite{Gonthier4col} utilisait 
des résultats de géométrie algébrique).

Pour prouver un but sous certaines hypothèses, on utilise des
tactiques qui simulent un raisonnement déductif pour l'utilisateur.
Celles-ci permettent par exemple d'introduire une hypothèse: pour le but
$A "=>" A$ on peut introduire l'hypothèse $H : A$ ; ou bien d'en appliquer une: en
appliquant l'hypothèse $H$ on prouve le but directement.
Ces tactiques peuvent être d'une complexité arbitraire (réecritures,
procédures de décision pour l'arithmétique, etc \ldots).

Les tactiques utilisées pour créer des preuves ne sont en fait qu'une
sorte de sucre au-dessus du noyau de \Coq{} qui se réduit à un typeur
pour \CCI. A la fin d'une preuve, on a en effet construit un terme 
($\lambda x : A. x$ dans notre exemple) que l'on va soumettre au typeur
dont le but est de vérifier qu'il est bien de type $A "->" A$.

\subsubsection{Programmes}
D'un point de vue preuve de programmes, on a donc un environnement qui
permet de vérifier qu'un programme (un terme du calcul) vérifie une
certaine spécification (son type). Les types dépendants permettent de
spécifier fortement les termes. Par exemple, la fonction $\sdef{div} :
\nat "->" \nat "->" \nat$ de \ML{} est plus fortement spécifiée en 
\Coq{} par $\sdef{div} : \nat "->" \subset{x}{\nat}{x \neq 0} "->" \nat$.
Seulement, on ne peut pas écrire simplement un programme \ML{} et
donner sa spécification forte. Comme on a enrichi les types, on doit 
aussi enrichir les termes avec des termes de preuve, inutiles au 
calcul mais nécessaires pour garantir la
correction logique du programme. Par exemple, si l'on veut appeler
$\sref{div}$ et que l'on a un entier $x$, il faut construire un terme
$\sref{div}~1~(\sref{elt}~x~p)$ où $p$ est une preuve de $x \neq 0$.

A l'inverse, on peut extraire un programme de toute preuve en éliminant les
parties logiques et en ne conservant que la partie calculatoire d'un terme.

% - Lambda calcul avec types dépendants, polymorphisme et ordre supérieur
% (lambda cube)
% - Correspond à la logique intuitioniste
% - Preuve = habitant d'un type.

% => Permet de développer des programmes. Développement informatiques
% (calculatoires)

\subsection{Motivation}

\Coq{} permet de développer des programmes complexes,
de leur donner des spécifications fortes et de les vérifier
automatiquement. On peut même extraire de ces dévelopemments des
programmes corrects par construction. Il y a cependant certaines
difficultés à développer en \Coq{} que nous allons étudier maintenant.

\subsubsection{Un langage trop expressif?} 

Le langage de \CCI{} permet de bien spécifier des fonctions non
triviales, par exemple, si l'on définit une fonction de division
euclidienne:
\[
\begin{array}[h]{l|l}
  \multicolumn{1}{c}{\text{Coq}} & \multicolumn{1}{c}{\text{ML}} \\
  \Definition~\sdef{div} : \forall a : \nat, \forall b : \nat,
  b \neq 0 "->" \{ q : \nat \& \{ r : \nat | r < b `^ a = b * q + r \} \}
  &
  \valml~\sdef{div} : \nat "->" \nat "->" \nat * \nat
\end{array}
\]

Les types dépendants permettent de bien relier les entrées aux sorties
et donc de spécifier les programmes aussi fortement que l'on désire, 
mais aussi de façon concise. En revanche, le terme de preuve 
correspondant à \sref{div} est nettement plus long (de l'ordre de 60 lignes), 
et ne peut simplement pas être écrit d'une traite 
sans une expertise approfondie. Pour remédier à ce
problème, on utilise des tactiques qui permettent d'écrire la preuve/programme
incrémentalement (figure \ref{fig:euclid-script}. L'inconvénient de cette
méthode est que l'on n'obtient pas toujours le programme désiré
au départ, puisque les tactiques cachent profondément leur effet sur le
terme de preuve. Certaines techniques de réecriture peuvent aussi
générer des termes de complexité algorithmique bien moins optimale que
ce que l'utilisateur écrirait. Cependant ce mode de fonctionement est
utile et utilisé par la majorité des utilisateurs de \Coq{} avec succès
(certification d'un compilateur \C, théorême des quatres couleurs
\cite{Gonthier4col}, \ldots).

\subsubsection{Mélange logique et calcul}
Une difficulté essentielle lorsque l'on veut permettre à des
utilisateurs non experts de développer dans \Coq{} est le ``mélange
des genres'' permanent entre logique et calcul. Pour appliquer une
fonction division qui attend un dénominateur différent de $0$ par
exemple, il faut passer à la fois l'argument lui même, mais aussi une
preuve de sa non-nullité. Lorsque l'on a l'habitude de programmer, ça
n'est pas la chose la plus naturelle et l'on aimerait pouvoir découpler
les parties codages et preuve pour simplement diviser le problème.

\subsubsection{Objectif}
A long terme, on souhaite permettre à un utilisateur de programmer dans
un langage proche de \ML{} et de prouver ses programmes dans un deuxième
temps à l'aide de \Coq{} et ses tactiques. Une fois les preuves
terminées, on peut extraire un programme correct par construction et
essentiellement équivalent à celui de départ ou le réutiliser facilement
dans l'environnement \Coq{}.

% - Features
% - Extraction..

% - Utilisation académique et real-world.

% \subsubsection{Difficultés}

% - Besoin d'expertise pour dev des programmes:
%   - Verbosité
%   - Mélange logique et calcul

\subsection{Travaux Connexes}

La preuve de programmes fonctionnels est un domaine de recherche
actif. L'idée d'étendre les langages \ML{} avec des types dépendants a
été développée dans \DML{} \cite{XiPfenning1999DTP}, \Cayenne{}
\cite{Augustsson99} et \TODO{???}. Il
s'agit dans ces travaux de faire un langage dont l'inférence est décidable, donc
de restreindre les types dépendants à des domaines où l'on peut faire de
la preuve automatique (\DML{}) ou bien d'affaiblir la puissance du langage
pour rendre l'utilisation des types dépendants plus aisée (\Cayenne{}
n'a pas la récursivité générale par exemple). Nous prenons le
contre-pied de ces travaux en acceptant de générer des obligations de
preuve et en essayant de trouver un langage le plus proche de \ML{}
possible tout en retenant la puissance de \Coq{} et des types dépendants.
Il existe un travail réalisé dans \Coq{} couvrant une partie de nos objectif.

\subsubsection{La tactique \Program}
Développée par Catherine Parent \cite{conf/mpc/Parent95}, 
la tactique \Program{} permettait de synthétiser des preuves à partir de
programmes. L'idée était de trouver un langage de programmation
suffisament restrictif pour réaliser une inversion de l'extraction, 
c'est à dire, à partir d'un terme essentiellement calculatoire
(des annotations étaient nécessaires), retrouver un terme de preuve
réalisant la spécification donnée. 
A partir de là, on était assuré que le programme extrait serait
identique à celui que l'on écrivait pour sa partie informative. Cette
méthode générale avait l'inconvénient d'etre peu intuitive et de ne pas
s'intégrer à l'environement \Coq. Liée à l'extraction interne qui
a disparu dans les dernières versions de \Coq{} (remplacée par la
contribution de Pierre Letouzey \cite{LetouzeyPhD}), elle n'est plus 
maintenue aujourd'hui.

\subsubsection{Types sous-ensemble}
Plutôt que de continuer dans la même direction, nous avons 
cherché à assouplir le système. L'assistant de preuve \PVS{}
\cite{PVS-Semantics} aux capacités similaires à \Coq{}, intègre un
mécanisme dénommé \ps{} que nous allons présenter maintenant.
Tout d'abord une définition:
\begin{definition}[Type sous-ensemble]
  $\subset{x}{T}{P}$ est le type des termes de type $T$ vérifiant la
  propriété $P$.
\end{definition}

Les types sous-ensembles sont d'une grande utilité pour la spécification
de programmes, par exemple pour les pré-conditions:
$\Definition~\sref{div} : \nat "->" \subset{x}{nat}{x \neq 0} "->" \nat$.

L'idée du \ps{} implémenté dans \PVS{}
\cite{ShankarOwreWADT99} est de considérer tout objet de
type $T$ comme un objet de type $\subset{x}{T}{P}$ pour $P$ vraie et
vice-versa. Comme tout objet $t$ de type $T$ ne vérifie pas forcément la
propriété $P$, on génére des ``Type-checking conditions'' (\TCC), c'est
à dire que l'on demande à l'utilisateur de prouver $P[t/x]$ pour assurer
que le programme est correct.

\subsubsection{Coercions}
\PVS{} n'a pas la même architecture que \Coq{}, en particulier il n'y a
pas de termes de preuve et de noyau pour vérifier ces termes. Il faut
donc faire confiance à la quasi-totalité du code pour croire en la
correction des programmes vérifiés. Le critère de {\sc De Bruijn},
qui dit en substance qu'un petit noyau (et celui de \Coq~a même été
formellement vérifié \cite{Barras96a}) est mieux qu'un gros 
n'est pas respecté.
 
Dans notre cas, il faut générer des termes de preuve et donc le code 
correspondant à ce ``sous-typage''. Une littérature importante
\cite{conf/popl/Chen03,conf/csl/Luo96} existe
autour des systèmes à coercions explicites dont nous nous sommes
inspirés pour réaliser la génération des termes. Dans un système à
coercions explicites, on peut faire des abus de notations tels que
utiliser un objet de type $T$ à la place d'un de type $U$, mais
on applique une coercion qui amène l'objet vers le type $U$ avant 
de retyper dans un système sans coercions. Généralement les coercions
sont très similaires à des idéntités, c'est-à-dire qu'elles sont calculatoirement
insignifiantes mais leur utilisation facilite le développement. Dans
\Coq{} par exemple le système de coercions \cite{saibi97inheritance} a
permis de développer des théories algébriques réutilisables sur
plusieurs structures instantanément (un théorême sur les corps pouvant s'appliquer aux
anneaux par exemple).

\section{La tactique \Subtac}
Nous avons développé un langage supportant le \ps{} utilisable dans
\Coq. L'utilisateur peut définir des programmes dans un langage plus
souple puis prouver certains buts pour obtenir finalement un terme de
\CCI{} complet vérifiable par le noyau. L'architecture est la suivante:
on type le programme dans notre langage, puis l'on réecrit le terme typé
dans \CCI{} en laissant des ``trous'' dans les termes et enfin \Coq{} se
charge de générer les obligations correspondant à ces trous.

\subsection{Langage}
Le langage que nous voulons est très proche de \ML, plus les annotations
nécessaires pour avoir un typage précis et décidable.

\subsubsection{Syntaxe}
La syntaxe (figure \ref{fig:syntax}) est directement inspirée des langages fonctionnels.
On part du \lc{} (variables, abstraction et application) puis l'on
ajoute des constantes (pour les entiers, booléens, etc...) ainsi que les
couples. La syntaxe $(x := `a, t : `t)$ permet de
créer des paires dépendantes, de type $`E x : `a. `t$. 

Du côté des types, on a tout d'abord les types simples (constantes,
flèche, produit cartésien) qui sont des cas particuliers du produit ($\Pi$) et
de la somme ($\Sigma$) dépendants. Les variables introduites par ces
types peuvent être utilisées lors des applications de types. On
peut de plus abstraire sur les types eux-mêmes, donc on a une
abstraction dans les types aussi. Enfin on peut appliquer un type à un
terme ($`t~`a$). Dans la suite, les règles sont données avec l'idée
qu'on fait les réductions de tête nécessaires pour obtenir un type
d'une certaine forme (produit, somme, sous-ensemble, etc \ldots).

%impossible d'inférer le type $`t$ désiré car il peut dépendre de
%$`a$. Par exemple $(x \Coloneq 1, f x)$
%\vspace{-0.5cm}
\begin{figure}[ht]
  \begin{center}
    \subfigure[Termes]{\termgrammar}\quad
    \subfigure[Types]{\typegrammarOrig}
  \end{center}
  \label{fig:syntax}
  \caption{Syntaxe}
\end{figure}
%\vspace{-1cm}

\subsubsection{Sémantique}
La sémantique du langage nous est donnée par un système de typage, qu'on
formalise par un ensemble de règles d'inférence. Dans notre cas c'est un
un sous-ensemble des règles de \CCI{} auquel on a ajouté une règle de
coercion (\irule{Coerce}) que l'on trouve classiquement dans les systèmes avec
sous-typage avec le nom de subsumption. Cette règle formalise l'idée que 
l'on peut utiliser un terme de type $T$ à la place d'un terme de type
$U$ si $T$ et $U$ sont dans une certaine relation. 
Le jugement $\Gamma \typed t : T$ se lit: dans l'environement $\Gamma$,
$t$ est de type $T$.

\typenvd
%\vspace{-0.5cm}
\begin{figure}[htb]
  \begin{center}
    \subfigure {\Coerce\DP} %[\protect{\irule{Subsum}}]
    \quad
    \subfigure{\Conv\DP} %[\protect{\irule{Conv}}]
    \quad
    \App\DP
  \end{center}
  \label{fig:typing-decl}
  \caption{Typage déclaratif}
\end{figure}
%\vspace{-1cm}

\CCI{} contient une règle de typage
similaire, la conversion (\irule{Conv}), qui dit essentiellement que deux types
$`b$-convertibles (on rappelle que l'on peut calculer dans les types
puisqu'on a l'abstraction, l'application, etc...) sont équivalents.
On peut directement intégrer cette relation de $`b$-convertibilité à notre
système de sous-typage comme montré figure \ref{subtyping-decl-rules}
(\irule{SubConv}), à la condition que les autres règles la conserve bien. 

Notre système de coercion par prédicats permet à l'utilisateur
d'utiliser une valeur de type $U$ là où l'on attend une valeur de type
$\subset{x}{V}{P}$ (\irule{SubProof}) si $U$ est lui-même coercible en $V$.
A l'inverse, on permet aussi d'utiliser une valeur de type
$\subset{x}{U}{P}$ (\irule{SubSub}) à la place d'une valeur de type
$V$ si $U$ est coercible vers $V$. 

Les règles \irule{SubProd} et \irule{SubSigma} permettent de faire des
coercions dans les types composites. Classiquement, la règle pour le 
produit fonctionel est contravariante (une fonction sous-type d'une
autre accepte plus d'entrées mais donne une sortie plus fine, voir
\name{Castagna} \cite{journals/toplas/Castagna95}) et la règle pour le 
produit cartésien covariante (une paire est coercible en une autre si 
leurs composantes sont coercibles deux-à-deux). 

\subtdShort

Une première propriété montrée habituellement sur le sous-typage est
qu'il est transitif, c'est à dire:
\begin{lemma}[Transitivité de la coercion]
  Si $T \sub U$ et $U \sub V$, alors $T \sub V$.
\end{lemma}

Cette règle assure que l'on a un système compositionel. Il y a ici une
analogie avec l'élimination des coupures dans les systemes logiques, où
l'on montre que toute dérivation utilisant la règle de modus-ponens ($A "=>" B$ et $B "=>" C$ implique
$A "=>" C$) peut se réecrire en une dérivation ne l'utilisant
jamais. Dans les systèmes à sous-typage, on montre de façon équivalente
que l'on peut éliminer la règle de transitivité ; première étape vers un
système décidable.

\subsubsection{Elaboration du système algorithmique \& propriétés}
Pour pouvoir implémenter le typeur, il nous faut un système dirigé par la
syntaxe. C'est presque le cas pour la coercion, il y a juste la règle
\irule{SubConv} qu'on peut appliquer à n'importe quel moment. On montre
le lemme suivant:
\begin{lemma}[Stabilité modulo $\beta$]
  Les règles de coercion conservent la convertibilité.
\end{lemma}

Cela signifie qu'on peut n'appliquer le test de conversion que lorsque plus aucune règle
ne s'applique et qu'on conserve ainsi tous les types
$\beta$-convertibles dans notre relation de coercion.

Il reste l'indéterminisme entre les règles \irule{SubProof} et
\irule{SubSub}. On peut laisser le choix à l'implémentation puisque
le système est confluent.

Cependant, il reste une source importante d'indécidabilité dans le
système de typage, c'est la règle de coercion. On peut montrer que
toute dérivation de typage utilisant \irule{Coerce} peut se réecrire en
une dérivation n'utilisant cette règle qu'à sa racine ou au niveau de la
prémisse de l'argument de la règle d'application \irule{App}.
On modifie en conséquence la règle d'application et l'on enlève
\irule{Coerce} du système. On peut ignorer sans-perte de généralité 
l'utilisation de la coercion à la racine de la dérivation, 
on fera de toute façon un test de coercion entre le type inféré et le
type spécifié juste avant la réecriture.

On a la propriété suivante entre les deux systèmes:
\begin{lemma}[Equivalence des systèmes déclaratifs et algorithmiques]
  $`G \typed t : T$ \ssi{} $`G \typea t : U$ et $U \subta T$.
\end{lemma}

\typenva

\begin{prooftree}
\AppA
\end{prooftree}

La nouvelle règle d'application est intéressante pour deux raisons.
Primo, c'est là qu'aura lieu le test de coercion, qui génerera une
coercion explicite dans le système final. Secundo, on est forcés de
faire une opération supplémentaire pour la fonctionelle que l'on
applique puisqu'il est possible qu'elle ait un type sous-ensemble,
auquel cas il faut l'``extraire'' pour trouver son type
fonctionnel (c'est le rôle de la fonction $\mu$, qui fait une mise en
forme normale de tête en effaçant les types sous-ensemble qu'elle
rencontre).

\subsection{Génération des obligations de preuve}
On a maintenant un système de typage décidable et l'on veut désormais
traduire ses dérivations dans \CCI{}. 

\subsubsection{Définition de la réecriture vers \Coq}
La traduction transforme une dérivation dans notre système algorithmique
vers une dérivation de \CCI{} valide. Le jugement 
$\timpl{`G}{t}{T}{`G'}{t'}{T'}$ se lit: on transforme le séquent
$`G \typea t : T$ (système algorithmique) en $`G' \typec t' : T'$
(\Coq). Le jugement $\subimpl{`G}{c}{T}{U}$ se lit: la coercion de $T$ à
$U$ est $c$ et $`G \typec c : T "->" U$.
La traduction est un homomorphisme (elle conserve la structure de la
dérivation et se rappelle récursivement) excepté pour l'application, ce qui
est normal puisque nous avons un système très proche de \CCI{}. 

\typenvi
\begin{prooftree}
\AppI
\end{prooftree}

Ici la fonction $\mu$ renvoie à la fois un type (qu'on demande
équivalent à un produit) et une fonction de coercion qui va faire les
projections nécessaires sur l'objet \Coq~$f'$. En effet dans \Coq~les
objets de type sous-ensemble $\subset{x}{T}{P}$ sont codés par un terme 
de la forme $\sref{elt}~t~p$ dont on peut extraire les parties objet 
(un certain $t$ de type $T$, par la projection $\Pi_1$) et preuve
 (de type $P[t/x]$). Il faut donc faire exactement
une projection pour atteindre par exemple la fonction d'un objet de type
 $\subset{f}{\nat "->" \nat}{f~0 \neq 0}$.

Le jugement de sous-typage $U \suba V$ nous assure qu'il est possible de
dériver le jugement $`G' \typec U' \subi V'$ et donc de créer une coercion de $U'$
à $V'$ soit une fonction de type $U' "->" V'$ dans \CCI.
On trouve ici l'essence du mécanisme de coercion par prédicats. 

\vspace{1.4em}
\begin{itemize}
\item[ \SubConvI\DP:] \quad\\

  Crée une coercion idéntité puisque \CCI{}~a la règle de conversion. 
  \vspace{1em}

\item[\SubLeftI\DP:] \quad\\
  
  Engendre une projection,
  c'est le cas où l'on ne s'intéresse pas à la preuve accompagnant
  l'objet. 
  \vspace{1em}

\item[\SubRightI\DP:] \quad\\

  Correspond à la génération d'une
  obligation de preuve dans \PVS. On utilise le mécanisme des variables
  existentielles (notées $?:\text{type}$) décrit plus loin pour donner 
  l'information au système qu'il faut completer le terme à un endroit
  donné avec un nouveau terme de type approprié. Il est donc possible 
  de créer des termes ininstantiables. 
  \vspace{1em}

\item[\SubProdI\DP,] \quad\\
  

\item[\SubSigmaI\DP:] \quad\\

  Réalisent respectivement
  les coercions pour les produits fonctionnels et cartésiens.

\end{itemize}
  
\subsubsection{Propriétés}
On veut montrer que si l'on a une dérivation dans notre système
algorithmique, alors son image par la réecriture est une dérivation
valide de \CCI. Ce travail est en cours à ce jour, nous nous sommes
plutôt penchés sur l'implémentation du typeur et de la fonction de
réecriture avant de commencer cette dernière preuve.

\subsection{Implémentation}
Nous avons développé la tactique \Subtac{} disponible dans la version
\CVS{} courante de \Coq{} (\url{http://coq.inria.fr}). Elle permet de
créer un programme, le typer et générer un terme incomplet
correspondant (voir \ref{fig:euclid-subtac}). 

\subsubsection{Existentielles}
La génération des buts correspondant aux variables existentielles et la
formation du terme final sont laissées à la tactique \Refine~et au
système de gestion des existentielles de \Coq. Certaines limitations 
dans l'implémentation du raffinement (le mécanisme permettant de manipuler
des termes ``à trous'') devront être dépassées pour obtenir
une contribution totalement fonctionnelle. On peut cependant espérer
résoudre ces problèmes de façon satisfaisante dans le futur.

\subsubsection{Traitement de la récursion}
Lorsque l'on développe un programme récursif dans un système tel que
\Coq, on est forcé de fournir une preuve de terminaison de son
algorithme. Pour cela, on montre généralement qu'on a un ordre bien
fondé sur le type de l'argument de récursion et que chaque appel respecte
cet ordre. Nous avons ajouté des facilités d'écriture de fonctions
récursives à notre langage ; on ajoute les existentielles
correspondant aux preuves que l'ordre est bien fondé ou qu'il est bien
respecté aux termes. Ainsi lors du raffinement on obtient naturellement
les buts correspondants à prouver.

\section{Conclusion}

\bibliographystyle{plain}
\bibliography{../bib/bib-joehurd,../bib/barras,../bib/pvs-bib,../bib/bcp,../bib/Luo,subset-typing,../bib/cparent/cparent}

\appendix
\section{Figures}

\begin{figure}[ph]
\begin{verbatim}
Recursive program mydiv (a : nat) using lt proof lt_wf : { b : nat | neq nat b O } ->
  [ q : nat ] { r : nat | and (lt r b) (div_prop a b q r) } :=
  fun { y : nat | neq nat y O } =>
    if lt_ge_dec a y
    then (q := O, a : { r : nat | and (lt r y) (div_prop a y q r) })
    else let (q', r) = mydiv (minus a y) y in 
        (q := S q', r : { r : nat | and (lt r y) (div_prop a y q r) }).
\end{verbatim}
  \label{fig:euclid-subtac}
  \caption{La division euclidienne avec \Subtac}
\end{figure}

\begin{figure}[p]
\begin{verbatim}
Definition div : forall a : nat, forall b : nat, 
  b <> 0 -> { q : nat & { r : nat | r < b /\ a = b * q + r } }.
Proof.
intros a ; pattern a ; apply lt_wf_rec ; intros. (* Récursion *)
elim (lt_ge_dec n b). (* If then else *)
intros. (* Première branche *)
(* Structure du terme *)
refine (existS _ 0 _) ; refine (exist _ n _) ; refine (conj _ _).
(* Preuve *)
assumption.
rewrite mult_0_r ; rewrite plus_0_l ; reflexivity.
(* Seconde branche *)
intros.
assert (n - b < n). (* Preuve pour l'appel *)
apply lt_minus ; [ apply (ge_le _ _ b0) | apply (nat_neq_0_gt_0 b H0) ].
induction (H (n - b) H1 b H0). (* Appel récursif *)
induction p ; induction p. (* Destruction du résultat *)
(* Structure du terme *)
refine (existS _ (S x) _) ; refine (exist _ x0 _).
(* Preuve *)
split.
assumption.
pose (eq_plus_eq _ _ H3 b).
replace (n - b + b) with n in e.  
rewrite e ; rewrite plus_comm ; rewrite plus_assoc.
replace (b + b * x) with (b * S x).
reflexivity.
rewrite mult_comm ; simpl ; pattern (x * b) ; rewrite mult_comm.
reflexivity.
apply ge_minus_plus_simpl.
apply (le_ge _ _ b0).
Qed.
\end{verbatim}
  \label{fig:euclid-script}
  \caption{Script de preuve de la division euclidienne}
\end{figure}

\renewcommand{\thefootnote}{}
\footnotetext{Ce rapport a été préparé sous \LaTeX~avec la fonte 
  \texttt{Computer Modern Bright}}

\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "subset-typing-short"
%%% LaTeX-command: "x=pdf; TEXINPUTS=\"style:$TEXINPUTS\" ${pdfx}latex"
%%% End: 
