\section{Le langage \lng{}}
\label{section:russel}
Le langage que nous voulons est très proche de \ML{}, plus les annotations
nécessaires pour avoir un typage précis et décidable. On étudie ici une
restriction de \ML{}, purement fonctionnelle et sans filtrage, qu'on
étendra dans la suite de notre travail. On n'a donc pas de types
inductifs mais on considère les types $\Sigma$, généralisation des
tuples de \ML{} formés par l'opérateur $*$.

\subsection{Syntaxe}
La syntaxe (figure \ref{fig:syntax}) est directement inspirée des langages fonctionnels.
On part du \lc{} (variables, abstraction et application) puis l'on
ajoute des constantes (pour les entiers, booléens, etc...) ainsi que les
couples. La syntaxe $(x := `a, t : `t)$ permet de
créer des paires dépendantes, de type $\Sigma x : `t. `t$. On peut aussi
appliquer un terme à un type pour instancier une fonction polymorphe par exemple.

Du côté des types, on a tout d'abord les types simples (constantes,
flèche, produit cartésien) qui sont des cas particuliers du produit ($\Pi$) et
de la somme ($\Sigma$) dépendants. Les variables introduites par ces
types peuvent être utilisées lors des applications de types. On
peut de plus abstraire sur les types avec le $\lambda$ (polymorphisme)
et les sortes.
Enfin on peut appliquer un type à un terme ($`t~`a$). 

%\vspace{-0.5cm}
\begin{figure}[ht]
  \begin{center}
    \subfigure[Termes]{\termgrammar}\quad
    \subfigure[Types]{\typegrammar}
  \end{center}
  \caption{Syntaxe}
  \label{fig:syntax}
\end{figure}
% \vspace{-1cm}

\subsection{Sémantique}
\typenvd

\typedFig
\subtdFig

La sémantique du langage nous est donnée par un système de typage
(figure \ref{fig:typing-decl-rules} page \pageref{fig:typing-decl-rules}). Le
jugement de typage est défini inductivement par un ensemble de règles
d'inférence. 
Dans notre cas ce sont les règles du \CCfull{} (\CC{})
étendu avec les $\Sigma$-types auxquelles on a ajouté une règle de
coercion (\irule{Coerce}, figure \ref{fig:typing-decl-rules}) que l'on trouve classiquement dans les systèmes avec
sous-typage avec le nom de subsumption. 
Le jugement $\Gamma \typed t : T$ se lit: dans l'environnement $\Gamma$,
$t$ est de type $T$.

% \begin{remark}
%   En pratique, les types du Calcul des Constructions ne sont pas
%   toujours en forme normale et il peut donc être nécessaire de les
%   réduire (en tête seulement) pour vérifier des jugements du genre: 
%   $`G \seq t : \Pi x : T.V$.
% \end{remark}

La relation $\mathcal{R}$ définissant les produits formables
dans le système est définie par les règles suivantes:
\[\begin{array}{cccll}
  s_1 & s_2 & s_3 & \text{Habitants} & \text{Exemple} \\
  \hline
  \Prop & \Prop & \Prop & \text{Implication logique} & x <= 0 "->" x = 0  \\
  \Set & \Set & \Set & \text{Fonctions} & \Pi x : \nat. \nat \\
  \Type & \Set & \Type & \text{Fonctions polymorphes} & \Pi A : \Set, A
  "->" A \\
  \Set & \Type & \Type & \text{Types dépendants} & \sref{vector} : \nat "->" \Set : \Set "->" \Type \\
  \Set & \Prop & \Prop & \text{Termes dans les propositions} & 
  \Pi n : \nat. \Pi l : \text{list}~n. \text{length}~l = n \\
  \Type & \Prop & \Prop & \text{Imprédicativité de } \Prop & \Pi x : Prop. x `V `! x \\
%  \Type(i) & \Type(j) & \Type(max~i~j)  & \text{Connecteurs logiques,
%    \ldots} & \Pi A : \Prop. \Pi B : \Prop. A `^ B "->" B `^ A
\end{array}\]
On a un système proche du \CCfull{} avec types $\Sigma$, mais
avec \Set{} prédicatif (comme dans \Coq{}).
On n'a pas $(\Prop,\Set,\Set)$ dans notre relation $\mathcal{R}$ pour
une bonne raison. Cela permet de créer des fonctions dépendant de
propositions, par exemple $\Pi n : \nat, n > 0 "->" \Pi l :
\text{list}~A~n "->" A$. Or on veut à tout prix éviter d'introduire des
termes de preuve dans notre langage, et l'on voit que
cette fonction pourrait naturellement s'écrire $\Pi n : \mysubset{n}{\nat}{n > 0} "->" \Pi l :
\text{list}~A~n "->" A$. Encore une fois le type sous-ensemble nous
permet d'éviter d'avoir à passer des termes de preuve directement. 

Les sommes formables dans le système sont réduites au couples d'objets de
types de même sorte $s `: \{ \Prop, \Set \}$.
Dans le premier cas les habitants sont les couples de propositions
(codage du $`^$), dans le second ce sont les couples d'objets, soit les
paires de \ML.
Intuitivement, c'est le type sous-ensemble $\mysubset{x}{T}{P}$ qui permet
de faire des couples $\Set,\Prop$ habitant $\Set$. Les types $\Sigma x : U.V$ où $U
: \Prop$ et $V : \Set$ n'ont pas d'intérêt dans notre cas puisqu'ils
représentent des objets de type $U `^ V$ mais on ne peut
pas utiliser $U$ dans notre système. On préfère coder ces objets par des
objets de type $\mysubset{x}{V}{U}$ (on n'est pas intéressé par la preuve
de $U$ pour programmer).


La règle \irule{Coerce} formalise l'idée que 
l'on peut utiliser un terme de type $T$ à la place d'un terme de type
$U$ si $T$ et $U$ sont dans une certaine relation. C'est là
qu'interviendront les types sous-ensemble. \CC{} contient une règle de typage
similaire à \irule{Coerce}, la règle de conversion (\irule{Conv}), qui
dit essentiellement que deux types
$`b$-convertibles (on rappelle que l'on peut calculer dans les types
puisqu'on a l'abstraction, l'application, etc...) sont équivalents.
On peut directement intégrer cette relation de $`b$-convertibilité à notre
système de coercion comme montré figure \ref{fig:subtyping-decl-rules}
(\irule{SubConv}), à condition d'avoir l'inclusion
$`=_\beta~\subseteq~\subd + \text{\irule{SubConv}}$.
En fait notre notion de réduction est un peu plus large que $\beta$
puisqu'on peut réduire les $\sref{let}$:
$\letml~(x,y) = (u, v)~\inml~t$ se réduit en $t[u/x][v/y]$. En
pratique cette constructions est du sucre syntaxique pratique au niveau
du typage (on peut inférer le type de $t$), mais elle est inessentielle au
niveau du calcul.
On peut aisément rajouter un $\letml~x=t~\inml~v$ à notre langage de
façon similaire: c'est équivalent à $(\lambda x : T.v)~t$, mais $T$ peut
est inféré plutôt que donné par l'utilisateur.

On considère les constantes comme des variables prédéfinies 
dans nos contextes, par exemple on a la constante $\sref{list} : \Pi x :
nat. \Set$. 
L'ajout d'une constante à un contexte ne doit pas altérer sa
bonne formation comme pour le cas des variables, donc son type doit être
bien formé (en général, toute définition de \Coq~donne lieu à une
constante dans notre système si elle est bien typée).

\subsubsection{Jugement de coercion}
Notre système de coercion par prédicats permet à l'utilisateur
d'utiliser une valeur de type $U$ là où l'on attend une valeur de type
$\mysubset{x}{V}{P}$ (\irule{SubProof}) si $U$ est lui-même coercible en $V$.
A l'inverse, on permet aussi d'utiliser une valeur de type
$\mysubset{x}{U}{P}$ (\irule{SubSub}) à la place d'une valeur de type
$V$ si $U$ est coercible vers $V$. Notre jugement de coercion est donc
symétrique et laisse beaucoup de liberté à l'utilisateur au moment du
codage. Par exemple on peut dériver $u : \nat \type u : \mysubset{x}{\nat}{`_}$
Seulement, lors de la traduction de la dérivation de coercion $\nat
\subd \mysubset{x}{\nat}{`_}$ (nécessaire pour traduire l'abus de notation
$x : \mysubset{x}{\nat}{`_}$), l'utilisateur aura à résoudre une obligation
de preuve de $`_$. On repose donc toujours sur la cohérence du Calcul
des Constructions. 
Les règles \irule{SubProd} et \irule{SubSigma} permettent de faire des
coercions dans les types composites. Classiquement, la règle pour le 
produit fonctionnel est contravariante (une fonction sous-type d'une
autre accepte plus d'entrées mais donne une sortie plus fine, voir
 \cite{journals/toplas/Castagna95}) et la règle pour le 
produit cartésien covariante (une paire est coercible en une autre si 
leurs composantes sont coercibles deux-à-deux). Le sens des coercions
n'a pas d'importance dans le système déclaratif puisqu'il est symétrique
mais il est essentiel lors de la création des coercions que nous
décrirons plus tard.

La règle \irule{SubTrans} assure que l'on a un système compositionnel. Il y a ici une
analogie avec l'élimination des coupures dans les systèmes logiques, où
l'on montre que toute dérivation utilisant la règle de \emph{modus ponens} ($A "=>" B$ et $B "=>" C$ implique
$A "=>" C$) peut se réécrire en une dérivation ne l'utilisant
jamais. Dans les systèmes à sous-typage, on montre de façon équivalente
que l'on peut éliminer la règle de transitivité ; première étape vers un
système décidable.


Notre jugement de coercion identifie les types $U$ et $\mysubset{x}{U}{P}$
mais notre système de typage ne permet pas d'éliminer (prendre la partie
preuve) ou d'introduire (créer un couple témoin,preuve) des objets de
type sous-ensemble. Cela nous assure une certaine cohérence, puisque
même si l'on ne vérifie pas qu'un objet de type $U$ a bien la propriété
$P$, on ne peut pas raisonner sur le fait que $U$ a la propriété dans le
langage.


On ne fera pas la métathéorie du système déclaratif ici, puisque
c'est une extension conservative du Calcul des Constructions et l'on
étudiera en détail le système algorithmique. Notre preuve de conservativité
est simple: si l'on oublie les utilisations des types sous-ensemble de
notre système de typage (\irule{Subset}) et de coercion
(\irule{SubProof} et \irule{SubSub}), alors le jugement de coercion est 
juste la $\beta$-convertibilité et donc \irule{Coerce} et \irule{Conv} 
sont équivalentes. Comme les autres règles de notre système déclaratif
proviennent directement de \CC{}, on arrive à un système strictement
égal au système du calcul des constructions. On peut donc s'appuyer sur
les résultats connus pour \CC{} pour une partie de notre système.

Pour une étude complète du \CCfull{}, se référer à
\cite{Barras99,Luo90}.
On va plutôt s'intéresser à la construction d'un algorithme de typage
correspondant à notre système déclaratif.

% \section*{Propriétés élementaires}

% \begin{fact}[Inversion du typage]
%   \label{inversion-typing-d}
%   On a les propriétés suivantes sur le jugement de typage:
%   \begin{enumerate}
%   \item Si $`G \type \lambda x : T.v : \Pi x : T.U : s$ alors $`G, x : T \type
%     v : U : s$.
%   \item Si $`G \type (t, v) : \Sigma x : T.U$ alors $`G, x : T \type U
%     : s1$ et $`G \type v : U[t/x]$.
%   \item Si $`G \type t : \mysubset{x}{U}{P}$ alors $`G \type t : U$ et
%     $`G, x : U \type P : \Prop$.
%   \end{enumerate}
% \end{fact}

% \begin{fact}[Convertibilité]
%   \label{type-convertibility}
%   Si $`G \type T : s$ et $s `=_\beta s'$ alors $`G \type T : s'$.
% \end{fact}

% \begin{lemma}[Inversion pour le produit]
%   \label{inversion-prod-d}
%   Si $`G \type \Pi x : T.U : s$ alors $s `: \setproptype$, $`G \type T : t$ et 
%   $`G, x : T \type U : s$.
% \end{lemma}
% \begin{proof}
%   Par induction sur la taille de la dérivation.
%   Les seules règles ayant pour conclusion possible un jugement de la
%   forme $\Pi x : T.U : s$ sont \irule{Prod} et \irule{Subsum}
%   (\irule{App} se termine par une application). Pour \irule{Prod} la
%   propriété est directe. Supposons que la dernière règle appliquée fut
%   \irule{Subsum}. Alors il existe $s'$ tel que $`G \type \Pi x : T.U :
%   s'$ et par induction, $s' `: \setproptype$. Une
%   inspection des règles de sous-typage révèle que seules les
%   règles \irule{SubConv} et \irule{SubTrans} ont pu s'appliquer dans
%   la dérivation $`G \type s' \sub s$. On en déduit que $s `=_\beta s'$,
%   et il s'ensuit que $`G \type T : s'$ (par application de
%   \irule{Conv}). % \ref{type-convertibility}
%   On peut appliquer \irule{Subsum} à la fin de la dérivation 
%   $`G, x : T \type U : s'$ pour obtenir le résultat $`G, x : T \type U :
%   s$.
  
  % La dérivation est donc de la forme:
%   \begin{prooftree}
%     \AXC{$t `=_\beta s'$}
%     \UIC{$t \sub s'$}
%     \AXC{$\ldots$}
%     \AXC{$s `=_\beta t$}
%     \UIC{$s \sub t$}
%     \TIC{$s \sub s'$}
%   \end{prooftree}


%   Comme les classes de
%   $\beta$-équivalence des éléments de $\setproptype$ sont réduites à un
%   élément,

% \end{proof}

% \TODO{Pas utilisé!}

% On montre tout d'abord qu'il existe des types principaux dans notre système.

% \begin{lemma}[Principalité du typage]
%   Pour tout $`G, t$, il existe $T$ tel que si $`G \typed t : T$ alors 
%   pour tout $S$ tel que $`G \typed t : S$ alors $T \subd S$.
% \end{lemma}

% \begin{proof}
%   Ce résultat découle du fait qu'il existe des sous-types principaux et
%   des sortes principales dans notre système.
% \end{proof}

% \begin{lemma}[Unicité du sortage]
%   Si $`G \typed T : s_1$ et $`G \typed T : s_2$ alors $s_1 = s_2$.
% \end{lemma}

% \begin{proof}
%   \begin{induction}{typing-decl}
%     \casetwo{PropSet}{Type}
%     Aucune autre règle ne peut typer $T$, donc $s_1 = s_2$
    
%     \case{Var} 
%     Les règles de conversion et de subsumption ne permettent pas de
%     typer $s1$...
    
%     \case{Prod}
%     \case{Abs}
%     \case{App}
%     \case{LetIn}
%     \case{Sigma}
%     \case{Sum}
%     \case{LetSum}
%     \case{Subset}
%     \case{Subsum}
%   \end{induction}
% \end{proof}


% \begin{lemma}[Sous-typage bien sorté]
%   \label{subtyping-sorts-d}
%   Si $S \subd T$, $`G \typed S : s_1$ et $`G \typed T : s_2$ alors $s_1 =
%   s_2$.
% \end{lemma}

% \begin{proof}
%   \begin{induction}[subtyping-decl]
%     \case{SubEq} Par unicité du typage.

%     \case{SubTrans} Trivial.
    
%     \casetwo{SubProd}{SubSigma} Par induction les composantes
%     correspondantes sont dans la même sorte, donc les composés aussi.
    
%     \casetwo{SubProof}{SubSub} Comme le constructeur de types subset
%     est de type $\Set "->" \Prop "->" \Set$, on conserve bien les mêmes
%     sortes de part et d'autre.
%   \end{induction}
% \end{proof}

% \begin{lemma}[Bonne formation des contextes]
%   \label{wf-contexts-d}
%   Si $`G \type t : T$ alors $\typewf `G$.
% \end{lemma}
% \begin{proof}
%   \inductionon{typing-decl}
% \end{proof}

% \begin{fact}[Inversion du jugement de bonne formation]
%   \label{inversion-wf-d}
%   Si $\typewf `G, x : U$ alors $`G \type U : s$ et $s `: \{ \Set, \Prop, \Type(i) \}$.
% \end{fact}

% L'affaiblissement est nécessaire pour montre le lemme de
% renforcement. Il établit que tout jugement peut être dérivé dans un
% contexte étendu par de nouvelles déclarations.

% \begin{lemma}[Affaiblissement]
%   \label{weakening-d}
%   Si $`G, `D \type t : T$ alors pour tout $x : S `; `G, `D$ tel que
%   $\wf `G, x : S, `D$, $`G, x : S, `D \type t : T$
% \end{lemma}

% \begin{proof}
%   \begin{induction}[typing-decl]
%     \casetwo{PropSet}{Type} Trivial.

%     \case{Var}
%     On a $x : S `; `G, `D$, donc $`G, x : S, `D \type y : T$ est toujours dérivable.
    
%     \case{Prod}
%     Par induction $`G, x : S, `D \type T : s1$ et $`G, x : S, `D,
%     y : T \seq U : s2$. On applique \irule{Prod} pour obtenir 
%     $`G, x : S, `D \type \Pi x : T.U : s2$. De même pour le reste des règles.

% %     \case{Abs}
% %     \case{App}
% %     \case{LetIn}
% %     \case{Sigma}
% %     \case{Sum}
% %     \case{LetSum}
% %     \case{Subset}
% %     \case{Subsum}
    

%   \end{induction}
% \end{proof}  

% Le renforcement montre que notre notion de sous-typage est correcte
% vis-à-vis du typage. On peut dériver les mêmes jugements dans des
% contextes où les variables ont des types plus précis.

% \begin{lemma}[Renforcement]
%   \label{narrowing-d}
%   \[ `G \seq S, S' : s, S' \sub S "=>" 
%   \left\{ \begin{array}{lcl}
%       \typewf `G, x : S, `D & "=>" & \typewf `G, x : S', `D \\
%       & `^{} & \\
%       `G, x : S, `D \seq t : T & "=>" & `G, x : S', `D \seq t : T
%     \end{array}
%   \right. \]
% \end{lemma}

% \begin{proof}
%   Par induction sur la taille de la dérivation de typage ou de bonne formation.
    
%   \begin{induction}
%     \case{WfEmpty} Trivial.
    
%     \case{WfVar} 
%     La conclusion est $\typewf `G, x : S, `D$
    
%     \begin{induction}[text=Par induction sur la taille de $`D$]
%     \item[\protect{$`D = []$}]
%       La racine de la dérivation est de la forme:
%       \begin{prooftree}
%         \UAX{WfVar}
%         {$`G \type S : s$}
%         {$\wf `G, x : S$}
%         {$s `: \{ \Set, \Prop, \Type(i) \}$}
%       \end{prooftree}
%       On a $`G \type S' : s$, donc par \irule{WfVar}, $\typewf `G, x : S'$.  

%     \item[\protect{$`D `= `D', y : U$}]
%       La racine de la dérivation est de la forme:
%       \begin{prooftree}
%         \UAX{WfVar}
%         {$`G, x : S, `D' \type U : t$}
%         {$\wf `G, x : S, `D', y : U$}
%         {$s `: \{ \Set, \Prop, \Type(i) \}$}
%       \end{prooftree}
%       Par induction sur la dérivation de typage $`G, x : S', `D' \seq U : t$,
%       on a donc bien $\typewf `G, x : S', `D', y : U$ par \irule{WfVar}.
%     \end{induction}
    
%     \casetwo{PropSet}{Type} 
%     Par induction, $\typewf `G, x : S', `D$, on applique simplement la règle.
    
%     \case{Var}
%     Par induction, $\typewf `G, x : S', `D$. La seule différence avec le
%     contexte précedent est le type associé à $x$, donc si $t \not= x$, on
%     peut simplement réappliquer \irule{Var}. Si $t `= x$ on construit la
%     dérivation:

%     \begin{prooftree}
%       \BAX{Var}
%       {$\wf `G, x : S', `D$}
%       {$x : S' `: `G$}
%       {$`G, x : S', `D \seq x : S'$}
%       {}
%       \AXC{$`G, x : S', `D \type S : s$}
%       \AXC{$S' \sub S$} % `G \subt 
%       \TIC{$`G, x : S', `D \type x : S$}
%     \end{prooftree}
    
%     Par l'affaiblissement (lemme \ref{weakening-d}) et $`G \type S : s$,
%     on obtient la prémisse $`G, x : S', `D \type S : s$.
    
%     \case{Prod} 
%     Par induction, $`G, x : S', `D \type T : s1$ et $`G, x : S', `D
%     y : T \seq U : s2$. On applique \irule{Prod} pour obtenir 
%     $`G, x : S' \type \Pi x : T.U : s2$. De même pour le reste des règles.
%   \end{induction}
% \end{proof}

% Maintenant que nous avons montré que ce système a bien les
% propriétés que l'ont veut pour la coercion par prédicats, on va le
% raffiner pour obtenir un algorithme de typage.


%$list nat \sub list {n:nat|n \neq 0}$ ?
%$list : Set -> Set$


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "subset-typing"
%%% LaTeX-command: "TEXINPUTS=\"style:$TEXINPUTS\" latex"
%%% End: 
