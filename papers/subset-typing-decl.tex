\subsection{Sémantique}
\typenvd

\TODO{Figures plus compactes ?}
\typedFig
\subtdFig

La sémantique du langage nous est donnée par un système de typage, qu'on
formalise par un ensemble de règles d'inférence. Dans notre cas ce
sont les règles de \CCI{} auquelles on a ajouté une règle de
coercion (\irule{Coerce}) que l'on trouve classiquement dans les systèmes avec
sous-typage avec le nom de subsumption. Cette règle formalise l'idée que 
l'on peut utiliser un terme de type $T$ à la place d'un terme de type
$U$ si $T$ et $U$ sont dans une certaine relation. 
Le jugement $\Gamma \typed t : T$ se lit: dans l'environnement $\Gamma$,
$t$ est de type $T$.

\CCI{} contient une règle de typage
similaire, la conversion (\irule{Conv}), qui dit essentiellement que deux types
$`b$-convertibles (on rappelle que l'on peut calculer dans les types
puisqu'on a l'abstraction, l'application, etc...) sont équivalents.
On peut directement intégrer cette relation de $`b$-convertibilité à notre
système de coercion comme montré figure \ref{subtyping-decl-rules}
(\irule{SubConv}), à condition d'avoir l'inclusion
$`=_\beta~\subseteq~\subd + \text{\irule{SubConv}}$.

Notre système de coercion par prédicats permet à l'utilisateur
d'utiliser une valeur de type $U$ là où l'on attend une valeur de type
$\subset{x}{V}{P}$ (\irule{SubProof}) si $U$ est lui-même coercible en $V$.
A l'inverse, on permet aussi d'utiliser une valeur de type
$\subset{x}{U}{P}$ (\irule{SubSub}) à la place d'une valeur de type
$V$ si $U$ est coercible vers $V$. 

Les règles \irule{SubProd} et \irule{SubSigma} permettent de faire des
coercions dans les types composites. Classiquement, la règle pour le 
produit fonctionnel est contravariante (une fonction sous-type d'une
autre accepte plus d'entrées mais donne une sortie plus fine, voir
 \cite{journals/toplas/Castagna95}) et la règle pour le 
produit cartésien covariante (une paire est coercible en une autre si 
leurs composantes sont coercibles deux-à-deux). 

Une première propriété montrée habituellement sur le sous-typage est
qu'il est transitif, c'est-à-dire:
\begin{lemma}[Transitivité de la coercion]
  Si $T \sub U$ et $U \sub V$, alors $T \sub V$.
\end{lemma}

Cette règle assure que l'on a un système compositionel. Il y a ici une
analogie avec l'élimination des coupures dans les systèmes logiques, où
l'on montre que toute dérivation utilisant la règle de \emph{modus ponens} ($A "=>" B$ et $B "=>" C$ implique
$A "=>" C$) peut se réécrire en une dérivation ne l'utilisant
jamais. Dans les systèmes à sous-typage, on montre de façon équivalente
que l'on peut éliminer la règle de transitivité ; première étape vers un
système décidable.

\section*{Propriétés élementaires}

\begin{fact}[Inversion du typage]
  \label{inversion-typing-d}
  On a les propriétés suivantes sur le jugement de typage:
  \begin{enumerate}
  \item Si $`G \type \lambda x : T.v : \Pi x : T.U : s$ alors $`G, x : T \type
    v : U : s$.
  \item Si $`G \type (t, v) : \Sigma x : T.U$ alors $`G, x : T \type U
    : s1$ et $`G \type v : U[t/x]$.
  \item Si $`G \type t : \subset{x}{U}{P}$ alors $`G \type t : U$ et
    $`G, x : U \type P : \Prop$.
  \end{enumerate}
\end{fact}

% \begin{fact}[Convertibilité]
%   \label{type-convertibility}
%   Si $`G \type T : s$ et $s `=_\beta s'$ alors $`G \type T : s'$.
% \end{fact}

% \begin{lemma}[Inversion pour le produit]
%   \label{inversion-prod-d}
%   Si $`G \type \Pi x : T.U : s$ alors $s `: \setproptype$, $`G \type T : t$ et 
%   $`G, x : T \type U : s$.
% \end{lemma}
% \begin{proof}
%   Par induction sur la taille de la dérivation.
%   Les seules règles ayant pour conclusion possible un jugement de la
%   forme $\Pi x : T.U : s$ sont \irule{Prod} et \irule{Subsum}
%   (\irule{App} se termine par une application). Pour \irule{Prod} la
%   propriété est directe. Supposons que la dernière règle appliquée fut
%   \irule{Subsum}. Alors il existe $s'$ tel que $`G \type \Pi x : T.U :
%   s'$ et par induction, $s' `: \setproptype$. Une
%   inspection des règles de sous-typage révèle que seules les
%   règles \irule{SubConv} et \irule{SubTrans} ont pu s'appliquer dans
%   la dérivation $`G \type s' \sub s$. On en déduit que $s `=_\beta s'$,
%   et il s'ensuit que $`G \type T : s'$ (par application de
%   \irule{Conv}). % \ref{type-convertibility}
%   On peut appliquer \irule{Subsum} à la fin de la dérivation 
%   $`G, x : T \type U : s'$ pour obtenir le résultat $`G, x : T \type U :
%   s$.
  
  % La dérivation est donc de la forme:
%   \begin{prooftree}
%     \AXC{$t `=_\beta s'$}
%     \UIC{$t \sub s'$}
%     \AXC{$\ldots$}
%     \AXC{$s `=_\beta t$}
%     \UIC{$s \sub t$}
%     \TIC{$s \sub s'$}
%   \end{prooftree}


%   Comme les classes de
%   $\beta$-équivalence des éléments de $\setproptype$ sont réduites à un
%   élément,

% \end{proof}

% \TODO{Pas utilisé!}

% On montre tout d'abord qu'il existe des types principaux dans notre système.

% \begin{lemma}[Principalité du typage]
%   Pour tout $`G, t$, il existe $T$ tel que si $`G \typed t : T$ alors 
%   pour tout $S$ tel que $`G \typed t : S$ alors $T \subd S$.
% \end{lemma}

% \begin{proof}
%   Ce résultat découle du fait qu'il existe des sous-types principaux et
%   des sortes principales dans notre système.
% \end{proof}

\begin{lemma}[Unicité du sortage]
  Si $`G \typed T : s_1$ et $`G \typed T : s_2$ alors $s_1 = s_2$.
\end{lemma}

\begin{proof}
  \begin{induction}{typing-decl}
    \casetwo{PropSet}{Type}
    Aucune autre règle ne peut typer $T$, donc $s_1 = s_2$
    
    \case{Var} 
    Les règles de conversion et de subsumption ne permettent pas de
    typer $s1$...

    \case{Prod}
    \case{Abs}
    \case{App}
    \case{LetIn}
    \case{Sigma}
    \case{Sum}
    \case{LetSum}
    \case{Subset}
    \case{Subsum}
  \end{induction} 


\end{proof}

% \begin{lemma}[Sous-typage bien sorté]
%   \label{subtyping-sorts-d}
%   Si $S \subd T$, $`G \typed S : s_1$ et $`G \typed T : s_2$ alors $s_1 =
%   s_2$.
% \end{lemma}

% \begin{proof}
%   \begin{induction}[subtyping-decl]
%     \case{SubEq} Par unicité du typage.

%     \case{SubTrans} Trivial.
    
%     \casetwo{SubProd}{SubSigma} Par induction les composantes
%     correspondantes sont dans la même sorte, donc les composés aussi.
    
%     \casetwo{SubProof}{SubSub} Comme le constructeur de types subset
%     est de type $\Set "->" \Prop "->" \Set$, on conserve bien les mêmes
%     sortes de part et d'autre.
%   \end{induction}
% \end{proof}

\begin{lemma}[Bonne formation des contextes]
  \label{wf-contexts-d}
  Si $`G \type t : T$ alors $\typewf `G$.
\end{lemma}
\begin{proof}
  \inductionon{typing-decl}
\end{proof}

\begin{fact}[Inversion du jugement de bonne formation]
  \label{inversion-wf-d}
  Si $\typewf `G, x : U$ alors $`G \type U : s$ et $s `: \{ \Set, \Prop, \Type(i) \}$.
\end{fact}

L'affaiblissement est nécessaire pour montre le lemme de
renforcement. Il établit que tout jugement peut être dérivé dans un
contexte étendu par de nouvelles déclarations.

\begin{lemma}[Affaiblissement]
  Si $`G, `D \type t : T$ alors pour tout $x : S `; `G, `D$ tel que
  $\wf `G, x : S, `D$, $`G, x : S, `D \type t : T$
\end{lemma}

\begin{proof}
  \begin{induction}[typing-decl]
    \casetwo{PropSet}{Type} Trivial.

    \case{Var}
    On a $x : S `; `G, `D$, donc $`G, x : S, `D \type y : T$ est toujours dérivable.
    
    \case{Prod}
    Par induction $`G, x : S, `D \type T : s1$ et $`G, x : S, `D,
    y : T \seq U : s2$. On applique \irule{Prod} pour obtenir 
    $`G, x : S, `D \type \Pi x : T.U : s2$. De même pour le reste des règles.

%     \case{Abs}
%     \case{App}
%     \case{LetIn}
%     \case{Sigma}
%     \case{Sum}
%     \case{LetSum}
%     \case{Subset}
%     \case{Subsum}
    

  \end{induction}
\end{proof}  

Le renforcement montre que notre notion de sous-typage est correcte
vis-à-vis du typage. On peut dériver les mêmes jugements dans des
contextes où les variables ont des types plus précis.

\begin{lemma}[Renforcement]
  \[ `G \seq S, S' : s, S' \sub S "=>" 
  \left\{ \begin{array}{lcl}
      \typewf `G, x : S, `D & "=>" & \typewf `G, x : S', `D \\
      & `^{} & \\
      `G, x : S, `D \seq t : T & "=>" & `G, x : S', `D \seq t : T
    \end{array}
  \right. \]
\end{lemma}

\begin{proof}
  Par induction sur la taille de la dérivation de typage ou de bonne formation.
    
  \begin{induction}
    \case{WfEmpty} Trivial.
    
    \case{WfVar} 
    La conclusion est $\typewf `G, x : S, `D$
    
    \begin{induction}[text=Par induction sur la taille de $`D$]
    \item[\protect{$`D = []$}]
      La racine de la dérivation est de la forme:
      \begin{prooftree}
        \UAX{WfVar}
        {$`G \type S : s$}
        {$\wf `G, x : S$}
        {$s `: \{ \Set, \Prop, \Type(i) \}$}
      \end{prooftree}
      On a $`G \type S' : s$, donc par \irule{WfVar}, $\typewf `G, x : S'$.  

    \item[\protect{$`D `= `D', y : U$}]
      La racine de la dérivation est de la forme:
      \begin{prooftree}
        \UAX{WfVar}
        {$`G, x : S, `D' \type U : t$}
        {$\wf `G, x : S, `D', y : U$}
        {$s `: \{ \Set, \Prop, \Type(i) \}$}
      \end{prooftree}
      Par induction sur la dérivation de typage $`G, x : S', `D' \seq U : t$,
      on a donc bien $\typewf `G, x : S', `D', y : U$ par \irule{WfVar}.
    \end{induction}
    
    \casetwo{PropSet}{Type} 
    Par induction, $\typewf `G, x : S', `D$, on applique simplement la règle.
    
    \case{Var}
    Par induction, $\typewf `G, x : S', `D$. La seule différence avec le
    contexte précedent est le type associé à $x$, donc si $t \not= x$, on
    peut simplement réappliquer \irule{Var}. Si $t `= x$ on construit la
    dérivation:

    \begin{prooftree}
      \BAX{Var}
      {$\wf `G, x : S', `D$}
      {$x : S' `: `G$}
      {$`G, x : S', `D \seq x : S'$}
      {}
      \AXC{$`G, x : S', `D \type S : s$}
      \AXC{$S' \sub S$} % `G \subt 
      \TIC{$`G, x : S', `D \type x : S$}
    \end{prooftree}
    
    Par l'affaiblissement (lemme \ref{weakening-d}) et $`G \type S : s$,
    on obtient la prémisse $`G, x : S', `D \type S : s$.
    
    \case{Prod} 
    Par induction, $`G, x : S', `D \type T : s1$ et $`G, x : S', `D
    y : T \seq U : s2$. On applique \irule{Prod} pour obtenir 
    $`G, x : S' \type \Pi x : T.U : s2$. De même pour le reste des règles.
  \end{induction}
\end{proof}

Maintenant que nous avons montré que ce système a bien les
propriétés que l'ont veut pour la coercion par prédicats, on va le
raffiner pour obtenir un algorithme de typage.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "subset-typing"
%%% LaTeX-command: "TEXINPUTS=\"style:$TEXINPUTS\" latex"
%%% End: 
