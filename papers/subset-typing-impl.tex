\section{Génération des obligations de preuve}
On veut désormais traduire les dérivations du système algorithmique
dans \CCI{} dont le jugement de typage est $\typec$. 
Les termes de \lng{} ne sont pas directement typables dans \CCI{}
puisque nous avons permis d'utiliser des objets comme s'ils avaient des
types différents de leurs types originaux avec la règle de coercion. Il
va donc falloir maintenant expliciter ces coercions pour obtenir des
termes typables dans \CCI{}. Cependant, on ne peut pas créer un terme
complet à partir de notre dérivation, puisqu'on ne peut pas inférer des
preuves arbitraires. On utilise donc des existentielles (intuitivement
des trous dont on ne connait que le type des habitants) pour traduire le
fait qu'il est de la responsabilité de l'utilisateur de prouver que son
utilisation de la coercion n'était pas incorrecte.

\newcommand{\ip}[2]{\llbracket #1 \rrbracket_{#2}}
\newcommand{\ipG}[1]{\llbracket #1 \rrbracket}
\newcommand{\ipt}[2]{\llfloor #1 \rrfloor_{#2}}
\newcommand{\ipT}[2]{\llceil #1 \rrceil_{#2}}

L'interprétation $\ip{t}{`G}$ renvoie à la fois un terme $t'$ réecrit et
son type dans l'environnement \Coq{} $`G$.
On utilise les abbréviations suivantes:
\begin{itemize}
\item $\ipt{t}{`G} `= \pi_1~ \ip{t}{`G}$, soit le terme réecrit ;
\item $\ipT{t}{`G} `= \pi_2~ \ip{t}{`G}$, soit le type \Coq{} de $t'$.
\end{itemize}

On définit l'interprétation $\ip{t}{`G}$ par récurrence sur la forme des termes:
\[\begin{array}{lcll}
  \ip{x}{`G} & = & x, `G(x) & \\
  \\
  \ip{s}{`G} & = & s, \Type & s `: \{ \Prop, \Set \}\\
  \ip{\Type}{`G} & = & \Type, \Type(1) & \\
  \\
  \ip{\Pi x : T.U}{`G} 
  & = & \letml~(T', s_{1}) = \ip{T}{`G}~\inml & \\
  & & \letml~(U', s_{2}) = \ip{U}{`G, x : T'}~\inml & \\
  & & \letml~s_3 = \mathcal{R}~s_1~s_2~\inml & \\
  & & (\Pi x : T'.U', s_3) & \\
  & \\
  \ip{\lambda x : `t.v}{`G} 
  & = & \letml~(`t', s') = \ip{`t}{`G}~\inml & \\
  & & \letml~(v', `g) = \ip{v}{`G, x : `t'}~\inml & \\
  & & (\lambda x : `t'. v'), \Pi x : `t'. `g & \\
  & \\
  \ip{f~u}{`G} 
  & = & \letml~(f', `t) = \ip{f}{`G}~\inml & \\
  & & \letml~(\pi, \Pi x : V.W) = \muimpl(`t)~\inml & \\
  & & \letml~(u', U') ` = \ip{u}{`G}~\inml & \\
  & & \letml~c = \sref{coerce}~U'~V~\inml & \\
  & & (\pi~f')~(c~u'), W[c~u/x] & \\
  & \\
  \ip{\Sigma x : T.U}{`G} 
  & = & \letml~(T', s) = \ip{T}{`G}~\inml & \\
  & & \letml~(U', s) = \ip{U}{`G, x : T'}~\inml & \\
  & & (\Sigma x : T'.U', s) & \\
  & \\
  \ip{(x \coloneqq t, u : U)}{`G}
  & = & \letml~(t', T') = \ip{t}{`G}~\inml & \\
  & & \letml~(\Sigma x : T'.U', s) = \ip{\Sigma x : T.U}{`G}~\inml& \\
  & & \letml~(u', U'') = \ip{u}{`G}~\inml & \\
  & & \letml~c = \sref{coerce}~U''~U'[t'/x]~\inml & \\
  & & (t', c~u'), \Sigma x : T'.U' & \\
  & \\
  \ip{\letml~(x,y) = t~\inml~v}{`G} 
  & = & \letml~(t', `t) = \ip{t}{`G}~\inml & \\
  & & \letml~(\pi, \Sigma x : T.U) = \muimpl(`t)~\inml & \\
  & & \letml~(v', V) = \ip{v}{`G, x : T, y : U}~\inml & \\
  & & (\letml~(x, y) = t'~\inml~v'), V & \\
  & \\
  \ip{\mysubset{x}{U}{P}}{`G}
  & = & \letml~(U', \Set) = \ip{U}{`G}~\inml & \\
  & & \letml~(P', \Prop) = \ip{P}{`G, x : U'}~\inml & \\
  & & \mysubset{x}{U'}{P'} : \Set  
\end{array}\]

On fait l'extension aux contextes de la façon suivante:
\begin{itemize}
\item $\ipG{[]} = []$
\item $\ipG{`G, x : T} =  \ipG{`G}, x : \ipt{T}{\ipG{`G}}$
\end{itemize}

On peut remarquer plusieurs choses sur notre interprétation:
\begin{itemize}
\item[Déterminisme] L'interprétation est déterministe par rapport à la
  forme des termes. Cela implique que si $\ipG{`G} = `g$ alors $\ipG{`G,
    x : T} = `g, x : \ipG{T}_{`g}$. On peut aussi en déduire que
  si $`G \typea x : T$ et $`G \typea \Sigma x : T.U : s$ alors 
  si $\ipt{T}{\ipG{`G}} = T'$ on a $\ipt{\Sigma x : T.U}{\ipG{`G}} =
  \Sigma x : T'. U'$.
  

\item[Conservation de la structure] On voit très clairement que notre
  interprétation est un homomorphisme, c'est à dire qu'elle préserve la
  structure. On va montrer que si $\hnf{t} = \Pi x : V.W$ alors
  il existe $V'$ et $W'$ tels que $\hnf{\ipt{t}{`G}} = \Pi x : V'.W'$.


\item[Consevation du typage] Notre interprétation transforme un terme
  bien typé dans le système algorithmique en un terme bien typé dans
  \CCI{}. Ce résultat découle du fait que l'on reconstruit implicitement
  la dérivation de typage du système algorithmique dans notre
  interprétation en ajoutant les coercions nécessaires.
\end{itemize}

% \input{typing-impl-new}
%\typeinewFig
\setboolean{displayLabels}{false}
\begin{theorem}[Correction de l'interprétation]
  \label{correct-interp}
  Si $`G \typea t : T$ alors on a $\ipG{`G} \typec \ipt{t}{\ipG{`G}} :
  \ipt{T}{\ipG{`G}}$ avec $\ipT{t}{`G} = \ipt{T}{\ipG{`G}}$.
  Si $\wf `G$ alors $\wf \ipG{`G}$.
\end{theorem}

\begin{proof}
  Par induction mutuelle sur la dérivation de typage ou de bonne
  formation.

  \begin{induction}
    \case{WfEmpty} Trivial.

    \case{WfVar}
    Par induction $\ipG{`G} \typec \ipt{A}{\ipG{`G}} :
    \ipt{s}{\ipG{`G}}$. Par inversion du jugement de bonne formation
    dans \CCI{}, $\typewf \ipG{`G}$.
    Or, $\ipt{s}{\ipG{`G}} = s$ ($s `: \{ \Prop, \Set, \Type \}$), donc 
    on peut appliquer \irule{WfVar} dans \CCI{} pour obtenir:
    $\wf \ipG{`G}, x : \ipt{A}{\ipG{`G}}$, soit $\wf \ipG{`G, x : A}$.

    \case{PropSet}
    Direct par induction, $\ipG{`G} \typec \ipt{s}{\ipG{`G}} = s :
    \ipt{\Type}{\ipG{`G}} = \Type$. La deuxième condition est directe
    par définition de l'interprétation.
    
    \case{Var} On a:
    \begin{prooftree}
      \Var
    \end{prooftree}
    Par induction, $\wf \ipG{`G}$ et par simple inspection de la
    définition de l'interprétation des contextes, si $x : A `: `G$ alors
    $x : \ipt{A}{`D} `: \ipG{`G}$ pour $`D ``( `G$. Par affaiblissement
    dans \CCI{}, on obtient aisément $\ipG{`G} \typec x : \ipt{A}{`D}$ 
    à partir de  $\ipG{`D} \typec x : \ipt{A}{\ipG{`D}}$. Or il est clair par
    la définition de l'interprétation que $\ipt{A}{`D} = \ipt{A}{`G}$  
    si $`G$ est une extension de $`D$ puisqu'on utilise l'environnement
    uniquement au moment de typer les variables et
    $\ipG{`G}(x) = \ipG{`D}(x)$ pour tout $x$ utilisé dans $A$.
    On a donc $\ipG{`G} \typec x : \ipt{A}{\ipG{`G}}$.
    La deuxième condition est montrée par $\ipT{x}{`G} = \ipG{`G}(x) = 
    \ipt{A}{\ipG{`D}} = \ipt{A}{\ipG{`G}}$.
      
    \case{Prod}
    
    


    \case{Abs}
    \case{App}
    \case{LetIn}
    \case{Sigma}
    \case{Sum}
    \case{LetSum}
    \case{Subset}
    \case{Subsum}



  \end{induction}
\end{proof}









\subsection{Définition de la réécriture vers \Coq}
\typenvi
La traduction transforme une dérivation dans notre système algorithmique
vers une dérivation de \CCI{} valide (figure \ref{fig:typing-impl-rules}). Le jugement 
$\timpl{`G}{t}{T}{`G'}{t'}{T'}$ se lit: on transforme le séquent
$`G \typea t : T$ (système algorithmique) en $`G' \typec t' : T'$
(\Coq). Le jugement $\subimpl{`G}{c}{T}{U}$ (figure
\ref{fig:subtyping-impl-rules}) se lit: la coercion de $T$ à
$U$ est $c$ et on construit le séquent $`G \typec c : T "->" U$.
La traduction est un homomorphisme (elle conserve la structure de la
dérivation et se rappelle récursivement) excepté pour \irule{App} et \irule{SumDep}, ce qui
est normal puisque nous avons un système très proche de \CCI{}. Le fait
de traduire aussi les environnements $\Gamma$ est dû au fait que nous
faisons la coercion dans les types,  donc les environnements (listes
de couples $(\text{nom}, \text{type})$) doivent aussi être réécrits. Cela assure aussi la
cohérence avec l'environnement général de \Coq, c'est-à-dire
l'intégration transparente de notre tactique dans les développements
\Coq~et la réutilisabilité des programmes générés. En conséquence, les
types spécifiés ne sont donc pas toujours préservés (on veut pouvoir y
introduire des coercions).

\typeiFig
\typemuiFig

Ici la fonction $\muimpl$ (figure \ref{fig:muimpl-definition}) renvoie à la fois un type (qu'on demande
équivalent à un produit) et une fonction de coercion qui va faire les
projections nécessaires sur l'objet \Coq~$f'$. En effet dans \Coq~les
objets de type sous-ensemble $\mysubset{x}{T}{P}$ sont codés par un terme 
de la forme $\sref{elt}~t~p$ dont on peut extraire les parties objet 
(un certain $t$ de type $T$, par la projection $\Pi_1$) et preuve
 (de type $P[t/x]$). Il faut donc faire exactement
une projection pour atteindre par exemple la fonction à partir d'un objet de type
 $\mysubset{f}{\nat "->" \nat}{f~0 \neq 0}$.

Le jugement de coercion $U \suba V$ nous assure qu'il est possible de
dériver le jugement $`G' \typec U' \subi V'$ et donc de créer une coercion de $U'$
à $V'$ soit une fonction de type $U' "->" V'$ dans \CCI.
On trouve ici l'essence du mécanisme de coercion par prédicats. 

\subtiFig

\vspace{1.4em}
\begin{itemize}
\item[ \SubConvI\DP:] \quad\\

  Crée une coercion identité puisque \CCI{}~a la règle de conversion. 
  \vspace{1em}

\item[\SubLeftI\DP:] \quad\\
  
  Engendre une projection,
  c'est le cas où l'on ne s'intéresse pas à la preuve accompagnant
  l'objet. 
  \vspace{1em}

\item[\SubRightI\DP:] \quad\\

  Correspond à la génération d'une
  obligation de preuve dans \PVS. On utilise le mécanisme des variables
  existentielles (notées $?:\text{type}$) décrit plus loin pour donner 
  l'information au système qu'il faut compléter le terme à un endroit
  donné avec un nouveau terme de type approprié. On peut aisément créer
  des obligations qui ne seront pas prouvables mais cela relève de la
  responsabilité de l'utilisateur.
  \vspace{1em}

\item[\SubProdI\DP,] \quad\\
  

\item[\SubSigmaI\DP:] \quad\\

  Réalisent respectivement
  les coercions pour les produits fonctionnels et cartésiens.

\end{itemize}
  
\subsection{Propriétés}
On veut montrer que si l'on a une dérivation dans notre système
algorithmique, alors son image par la réécriture est une dérivation
valide de \CCI{}. On rappelle que \CCI{} est équivalent au premier
calcul présenté moins la règle de subsumption.
Voici les règles qui ont changé de manière non triviale entre les deux systèmes:
\vspace{0.2em}


\setboolean{displayLabels}{false}
\hspace{-1cm}
\App\DP
\quad$"~>"$\quad
\AppI\DP

\vspace{\infvspace}
\hspace{-1cm}
\SumDepA\DP
\quad$"~>"$\quad
\SumDepI\DP

\begin{theorem}
  Si $`G \typea t : T$ et $\timpl{`G}{t}{T}{`G'}{t'}{T'}$ alors $`G'
  \typec t' : T'$.
\end{theorem}
\setboolean{displayLabels}{false}

Nous n'avons pas encore trouvé de preuve de ce résultat. En effet le
jugement de coercion rend la preuve très difficile à cause de son caractère
non local. Pour mieux comprendre ce problème, considérons l'exemple
suivant:

Dans le système algorithmique, on peut très bien dériver
$\Pi n : \nat. \sref{list}~n \suba \Pi n :
\mysubset{x}{\nat}{P}.\listml~n$ puisque $\mysubset{x}{\nat}{P} \suba
\nat$ et $\listml~n \eqbi \listml~n$.
Si l'on réécrit la dérivation vers \CCI{}, on n'aura plus les même types
de départ pour dériver le jugement puisqu'on part de types \Coq~valides.
Ici, une coercion a été insérée dans le second type:
$`G' \typec c : \Pi n : \nat. \listml~n \subi \Pi n :
\mysubset{x}{\nat}{P}.\listml~(\pi_1~n)$. Seulement, et c'est là la
preuve que l'intuition de la coercion par prédicats est bonne, on peut
dériver ce jugement:

\begin{prooftree}
  \AXC{$\nat \eqbi \nat$}
  \UIC{$`G' \typec \lambda x.x : \nat \subi \nat$}
  \UIC{$`G' \typec (\lambda x.x) `o \pi_1 : \mysubset{x}{\nat}{P} \subi \nat$}
  \AXC{$(\listml~n)[\pi_1~n/n] \eqbi \listml~(\pi_1~n)$}
  \UIC{$`G, n : \mysubset{x}{\nat}{P} \typec c_2 = (\lambda x.x) :
    (\listml~n)[\pi_1~n/n] \subi \listml~(\pi_1~n)$}
  \BIC{$`G' \typec \lambda f.\lambda x.c_2~(f~(\pi_1~x)) : 
    \Pi n : \nat. \listml~n \subi 
    \Pi n : \mysubset{x}{\nat}{P}.\listml~(\pi_1~n)$}
\end{prooftree}

On ne peut donc pas simplement faire une induction sur la dérivation de
typage dans le système algorithmique, il nous faut l'information
correspondant aux coercions appliquées dans la réécriture. 

On a cependant des idées sur les propriétées à montrer pour pouvoir
faire notre preuve. 

\begin{proposition}[Restriction et réécriture]
  Si $`G, x : U, `D \typea t : T$ et $`G \typea u : V$ avec $V \suba U$
  alors $`G' \typec c : V' \suba U'$ et $`G', x : u', `D' \typec t' :
  T'$, $`G' \typec u' : V'$ et $`G', `D'[c~v'/x] \typec t'[c~v'/x] :
  T'[c~v'/x]$.
\end{proposition}
Cette propriété montre que notre réécriture conserve la substitutivité
et la propriété de restriction.

Dans le cas de l'application, on ne peut obtenir la preuve
de $(W[u/x])' = W'[c~u'/x]$ si $x : V$, $u : U$ et $U \suba V$ qu'en
faisant une analyse détaillée de la fonction $'$ (la réécriture peut
être guidée uniquement par les termes puisque nous partont de
dérivations du système algorithmique qui est décidable).

On définit l'extension de la coercion aux contextes de la façon
suivante:
\begin{itemize}
\item $[] \suba []$
\item $`G, x : T \suba `D, x : U$ si $`G \suba `D$,
  $`G \typea T : s$, $`D \typea U : s$ et $T \suba U$.
\end{itemize}

On a besoin pour assurer que l'on peut bien dériver une coercion de $U'$
a $V'$ à partir de $U \suba V$ de formaliser la traduction des
contextes, puisqu'on les modifie lorsque l'on passe la règle
\irule{SubProd} ou \irule{SubSigma}, on obtient une hypothèse de 
récurrence plus forte pour montrer: $U \suba V "=>" `E c, `G' \typec c : U' \subi V'$.
On définit l'extension de la coercion aux contextes réécrits 
de la façon suivante:
\begin{lemma}[Traduction et $\beta$-équivalence]
  Si $`G \typea T, U : s$, $T \eqbi U$ alors $`G' \typec T', U' : s$ et
  $T' \eqbi U'$.
\end{lemma}




\begin{itemize}
\item $`q : [] "->" []$
\item $`q, x = c x : `G', x : T' "->" `D', x : U'$ 
  si
  \begin{itemize}
  \item $`q : `G' \suba `D'$
  \item $`G' \typec c : T' \subi U'[`q]$, soit $`G', x : T' \typec c~x :
    U'[`q]$.
  \end{itemize}
\end{itemize}
\begin{proposition}
  Si $`G \typea T : s$ et $`D \typea U : s$ et $`G \suba
  `D$, $T \suba U$ alors on a:
  \begin{itemize}
  \item $`q : `G' "->" `D'$ 
  \item $`r : `D' "->" `G'$
  \item $`G' \typec c_{`G} : T' \subi U'[`q]$
  \item $`D' \typec c_{`D} : T'[`r] \subi U'$.
  \end{itemize}
\end{proposition}

Ainsi, à l'application on a la preuve que $`G' \typec c : U' \subi V'$
puisque la fonction de $`D$ à $`D$ est l'identité.

\begin{proof}
  Par induction sur la dérivation de $`G \suba `D$.
  
  \begin{itemize}
  \item $[] \suba []$ On construit $`q$ et $`r$ de façon triviale
    puisque $`D' = `G' = []$.
    Il faut maintenant montrer qu'on a une coercion de $T'$ à $U'$ dans
    l'environnement vide.
    Si $`G$ est vide alors $T$ est un type clos. 
    Par induction sur la dérivation de $T \suba U$:
    \begin{induction}
      \case{SubConv}. On a $T \eqbi U$. Il faut montrer que la
      traduction préserve la béta-équivalence.
      
    \end{induction}
  \end{itemize}
%   \begin{induction}
%     \case{SubConv} 
%     On a $T \eqbi U$. 
%     On procède par induction sur $`G \suba `D$ pour construire $`z$ et
%     $`p$:
%     \begin{itemize}
%     \item $[] \suba []$ Trivial, $`D' = `G' = []$.
%     \item $`G'', x : V \suba `D'', x : W$: Par induction on a
%       \begin{itemize}
%       \item $`G'' \suba `D''$
%       \item $V \suba W'$
%       \end{itemize}
      
%     \end{itemize}
    
%   \end{induction}
\end{proof}


% Nous avons de bonnes raisons de penser que la traduction fonctionne: le
% système \PVS{} repose sur système similaire depuis des années, notre
% réécriture fonctionne en pratique et enfin, on voit bien que le système
% déclaratif se plonge dans \CCI{} aisément. Dans ce cas, il suffit de
% voir que la règle de coercion permet toujours de trouver une fonction de
% $U$ à $T$ et qu'elle ne peut modifier que la forme des objets, alors
% qu'aucune règle ne repose dessus.

% \begin{proof}
%   Notre traduction est un homomorphisme, il est donc direct que le
%   typage soit conservé. Il faut juste s'assurer que l'on ne modifie pas
%   la forme des termes et des types par la réécriture. C'est possible
%   uniquement pour les règles \irule{App} et \irule{LetSum}, on va donc
%   les étudier plus en détail.

%   \begin{prooftree}
%     \QAX{App}
%     {$\timpl{`G}{f}{T}{`G'}{f'}{T'}$}
%     {$\muimpl~T' `= (\pi, \Pi x : V'. W')$}
%     {$\timpl{`G}{u}{U}{`G'}{u'}{U'}$}
%     {$\subimpl{`G'}{c}{U'}{V'}$}
%     {$\timpl{`G}{f u}{W[u/x]}{`G'}{(\pi~f')~(c~u')}{W'[ c~u' / x ]}$}
%     {}
%   \end{prooftree}
  
%   Par induction, on sait que $\muimpl(T') `= (\pi, \Pi x : V'. W')$ puisque
%   la réécriture ne change pas la forme des types.
%   Par définition de $\muimpl$ on a $\pi~f' : \Pi x : V'.W'$.
%   On assure donc la forme fonctionelle de $f$ par la réécriture.
%   La définition de la coercion nous assure que $c~u' : V'$. On obtient
%   donc $(\pi~f) (c~u') : W'[c~u'/x]$. 
%   Ici, la coercion pourrait changer la forme du type, par exemple si 
%   $W `= x$, on aurait $W'[c~u'/x] = c~u'$. Nous allons montrer que cela
%   ne change pas la forme du type.
%   Si $W = x$, alors $V'$ ne peut être qu'une sorte. En effet, il n'est
%   pas possible de former des produits ayant un terme en membre droit, la
%   syntaxe même nous assure que les termes ne peuvent figurer qu'en
%   position interne, c'est-à-dire appliqués à un type. Or si $V'$ est une
%   sorte, la forme de $W$ et donc de $W'$ n'est pas changé par la
%   substitution puisque $x$ n'apparait pas dedans.
%   Si $V'$ n'est pas une sorte, il peut être par exemple un produit.
  
%   La règle de formation du produit nous assure que si $x$ apparait dans
%   $W'$ alors c'est en position interne.


% \end{proof}


% \begin{proof}
%   Par induction sur la réécriture de la dérivation.
  
%   \begin{induction}

%     \case{WfEmpty}% \quad
% %     \begin{prooftree}
% %       \UAX{Wf-Atom}
% %       {}
% %       {$\wf [] "~>"~\wf []$}
% %       {}
% %     \end{prooftree}
%     Trivial.
    
%     \case{WfVar}
% %     \begin{prooftree}
% %       \UAX{Wf-Var}
% %       {$\timpl{`G}{A}{s}{`G'}{A'}{s}$}
% %       {$\wf `G, x : A "~>"~\wf `G', x : A'$}
% %       {$s `: \{ \Set, \Prop, \Type(i) \}$}
% %     \end{prooftree}
%     Par induction $`G' \typec A' : s$, on applique simplement \irule{WfVar}.
    
%     \casetwo{PropSet}{Type}
% %     \begin{prooftree}
% %       \UAX{PropSet}
% %       {$\wf `G "~>" ~\wf `G'$}
% %       {$\timpl{`G}{s}{\Type(0)}{`G'}{s}{\Type(0)}$}
% %       {$s `: \{ \Prop, \Set \}$} 
% %     \end{prooftree}
%     Direct par induction.

% %     \case{Type}\quad
% %     \begin{prooftree}
% %       \UAX{Type}
% %       {$\wf `G "~>" \wf `G$}
% %       {$\timpl{`G}{\Type(i)}{\Type(i + 1)}{`G'}{\Type(i)}{\Type(i + 1)}$}
% %       {}
% %     \end{prooftree}

%     \case{Var}\quad
%     \begin{prooftree}
%       \BAX{Var}
%       {$\wf `G "~>"~\wf `G'$}
%       {$x : A `: `G "~>" x : A' `: `G'$}
%       {$\timpl{`G}{x}{A}{`G'}{x}{A'}$}
%       {}
%     \end{prooftree}
%     La réécriture ne change pas le domaine des contextes, c'est donc
%     direct par induction.

%     \case{Prod}\quad
%     \begin{prooftree}
%       \BAX{Prod}
%       {$\timpl{`G}{T}{s1}{`G'}{T'}{s1}$}
%       {$\timpl{`G, x : T}{U}{s2}{`G', x : T'}{U'}{s2}$}
%       {$\timpl{`G}{\Pi x : T.U}{s2}{`G'}{\Pi x : T'.U'}{s2}$}
%       {$(s1, s2) `: \mathcal{R}$}
%     \end{prooftree}
    


%     \case{Abs}\quad
%     \begin{prooftree}
%       \BAX{Abs}
%       {$\timpl{`G}{\Pi x : T. U}{s}{`G'}{\Pi x : T'. U'}{s}$}
%       {$\timpl{`G, x : T}{M}{U}{`G', x : T'}{M'}{U'}$}
%       {$\timpl{`G}{\lambda x : T. M}{\Pi x : T.U}
%         {`G'}{\lambda x : T'. M'}{\Pi x : T'.U'}$}
%       {}
%     \end{prooftree}

%     \case{App}\quad
%     \begin{prooftree}
%       \QAX{App}
%       {$\timpl{`G}{f}{T}{`G'}{f'}{T'}$}
%       {$\mu~T' `= (\pi, \Pi x : V'. W')$}
%       {$\timpl{`G}{u}{U}{`G'}{u'}{U'}$}
%       {$\subimpl{`G'}{c}{U'}{V'}$}
%       {$\timpl{`G}{f u}{W[u/x]}{`G'}{(\pi~f')~(c~u')}{W'[ c~u' / x ]}$}
%       {}
%     \end{prooftree}

%     \case{LetIn}\quad
%     \begin{prooftree}
%       \BAX{LetIn}
%       {$\timpl{`G}{t}{T}{`G'}{t'}{T'}$}
%       {$\timpl{`G, x : T}{v}{V}{`G', x : T'}{v'}{V'}$}
%       {$\timpl{`G}{\letml~x = t~\inml~v}{V[t / x]}
%         {`G'}{\letml~x = t'~\inml~v'}{V'[t' / x]}$}
%       {}
%     \end{prooftree}

%     \case{SigmaR}\quad
%     \begin{prooftree}
%       \BAX{Sigma}
%       {$\timpl{`G}{T}{s1}{`G'}{T'}{s1}$}
%       {$\timpl{`G, x : T}{U}{s2}{`G', x : T'}{U'}{s2}$}
%       {$\timpl{`G}{\Sigma x : T.U}{s2}{`G'}{\Sigma x : T'.U'}{s2} $}
%       {$(s1, s2) `: \mathcal{R}$}
%     \end{prooftree}


%     \case{SumInf}\quad
%     \begin{prooftree}
%       \TAXWide{SumInf}
%       {$\timpl{`G}{t}{T}{`G'}{t'}{T'}$}
%       {$\timpl{`G}{u}{U}{`G'}{u'}{U'}$}
%       {$\timpl{`G}{\Sigma \_ : T.U}{s}{`G'}{\Sigma \_ : T'.U'}{s}$}
%       {$\timpl{`G}{(t, u)}{\Sigma \_ : T.U}{`G'}{(t', u')}{\Sigma \_ : T'.U'}$}
%       {}
%     \end{prooftree}

%     \case{SumDep}\quad
%     \begin{prooftree}
%       \TAXWide{SumDep}
%       {$\timpl{`G}{t}{T}{`G'}{t'}{T'}$}
%       {$\timpl{`G}{u}{U[t/x]}{`G'}{u'}{U'[t'/x]}$}
%       {$\timpl{`G}{\Sigma x : T.U}{s}{`G'}{\Sigma x : T'.U'}{s}$}
%       {$\timpl{`G}{(t, u : U)}{\Sigma x : T.U}{`G'}{(t', u')}{\Sigma x : T'.U'}$}
%       {}
%     \end{prooftree}
    
%     \case{LetSum}\quad
%     \begin{prooftree}
%       \BAX{LetSum}
%       {$\timpl{`G}{t}{\Sigma x : T. U}{`G'}{t'}{\Sigma x : T'.U'}$}
%       {$\timpl{`G, x : T, u : U}{v}{V}{`G, x : T', u : U'}{v'}{V'}$}
%       {$\timpl{`G}{\letml~(x, u) = t~\inml~v}{V}
%         {`G'}{\letml~(x, u) = t'~\inml~v'}{V'}$}
%       {}
%     \end{prooftree}

%     \case{Subset}\quad
%     \begin{prooftree}
%       \BAX{Subset}
%       {$\timpl{`G}{U}{\Type}{`G'}{U'}{\Type}$}
%       {$\timpl{`G, x : U}{P}{\Prop}{`G', x : U'}{P'}{\Prop} $}
%       {$\timpl{`G}{\mysubset{x}{U}{P}}{\Type}{`G'}{\mysubset{x}{U'}{P'}}{\Type}$}
%       {$$}
%     \end{prooftree}
%   \end{induction}
% \end{proof}



% Ce travail est en cours à ce jour, nous nous sommes
% plutôt penchés sur l'implémentation du typeur et de la fonction de
% réécriture avant de commencer cette dernière preuve.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "subset-typing"
%%% LaTeX-command: "TEXINPUTS=\"style:$TEXINPUTS\" latex"
%%% End: 
