\section{Génération des obligations de preuve}
On veut désormais traduire les dérivations du système algorithmiques
dans \CCI{} (modifiant aussi les termes de \lng{}) dont le jugement 
de typage est $\typec$. 
Les termes de \lng{} ne sont pas directement typables dans \CCI{}
puisque nous avons permis d'utiliser des objets comme s'ils avaint des
types différents de leurs types originaux avec la règle de coercion. Il
va donc falloir maintenant expliciter ces coercions pour obtenir des
termes typables dans \CCI{}. Cependant, on ne peut pas créer un terme
complet à partir de notre dérivation, puisqu'on ne peut pas inférer des
preuves arbitraires. On utilise donc des existentielles (intuitivement
des trous dont on ne connait que le type des habitants) pour traduire le
fait qu'il est de la responsabilité de l'utilisateur de prouver que son
utilisation de la coercion n'était pas incorrecte.

\newcommand{\ip}[2]{\llbracket #1 \rrbracket_{#2}}
On définit l'interprétation $\ip{t}{`G}$ par récurrence sur la forme des termes:
\begin{itemize}
\item $\ip{x}{`G} = x, `G(x)$
\item $\ip{\lambda x : T.v}{`G} = \lambda x : \ip{T}{`G}. \ip{v}{`G, x :
    \ip{T}{`G}}$
\item $\ip{f~u}{`G} = \ip{f}{`G}~\ip{u}{`G}$.
\end{itemize}


\subsection{Définition de la réécriture vers \Coq}
\typenvi
La traduction transforme une dérivation dans notre système algorithmique
vers une dérivation de \CCI{} valide (figure \ref{fig:typing-impl-rules}). Le jugement 
$\timpl{`G}{t}{T}{`G'}{t'}{T'}$ se lit: on transforme le séquent
$`G \typea t : T$ (système algorithmique) en $`G' \typec t' : T'$
(\Coq). Le jugement $\subimpl{`G}{c}{T}{U}$ (figure
\ref{fig:subtyping-impl-rules}) se lit: la coercion de $T$ à
$U$ est $c$ et on construit le séquent $`G \typec c : T "->" U$.
La traduction est un homomorphisme (elle conserve la structure de la
dérivation et se rappelle récursivement) excepté pour l'application, ce qui
est normal puisque nous avons un système très proche de \CCI{}. Le fait
de traduire aussi les environnements $\Gamma$ est dû au fait que nous
faisons la coercion dans les types,  donc les environnements (listes
de couples $(\text{nom}, \text{type})$) doivent aussi être réécrits. Cela assure aussi la
cohérence avec l'environnement général de \Coq, c'est-à-dire
l'intégration transparente de notre tactique dans les développements
\Coq~et la réutilisabilité des programmes générés. En conséquence, les
types spécifiés ne sont donc pas toujours préservés (on veut pouvoir y
introduire des coercions).

\typeiFig
\typemuiFig

Ici la fonction $\muimpl$ renvoie à la fois un type (qu'on demande
équivalent à un produit) et une fonction de coercion qui va faire les
projections nécessaires sur l'objet \Coq~$f'$. En effet dans \Coq~les
objets de type sous-ensemble $\subset{x}{T}{P}$ sont codés par un terme 
de la forme $\sref{elt}~t~p$ dont on peut extraire les parties objet 
(un certain $t$ de type $T$, par la projection $\Pi_1$) et preuve
 (de type $P[t/x]$). Il faut donc faire exactement
une projection pour atteindre par exemple la fonction à partir d'un objet de type
 $\subset{f}{\nat "->" \nat}{f~0 \neq 0}$.

Le jugement de coercion $U \suba V$ nous assure qu'il est possible de
dériver le jugement $`G' \typec U' \subi V'$ et donc de créer une coercion de $U'$
à $V'$ soit une fonction de type $U' "->" V'$ dans \CCI.
On trouve ici l'essence du mécanisme de coercion par prédicats. 

\subtiFig

\vspace{1.4em}
\begin{itemize}
\item[ \SubConvI\DP:] \quad\\

  Crée une coercion identité puisque \CCI{}~a la règle de conversion. 
  \vspace{1em}

\item[\SubLeftI\DP:] \quad\\
  
  Engendre une projection,
  c'est le cas où l'on ne s'intéresse pas à la preuve accompagnant
  l'objet. 
  \vspace{1em}

\item[\SubRightI\DP:] \quad\\

  Correspond à la génération d'une
  obligation de preuve dans \PVS. On utilise le mécanisme des variables
  existentielles (notées $?:\text{type}$) décrit plus loin pour donner 
  l'information au système qu'il faut compléter le terme à un endroit
  donné avec un nouveau terme de type approprié. On peut aisément créer
  des obligations qui ne seront pas prouvables mais cela relève de la
  responsabilité de l'utilisateur.
  \vspace{1em}

\item[\SubProdI\DP,] \quad\\
  

\item[\SubSigmaI\DP:] \quad\\

  Réalisent respectivement
  les coercions pour les produits fonctionnels et cartésiens.

\end{itemize}
  
\subsection{Propriétés}
On veut montrer que si l'on a une dérivation dans notre système
algorithmique, alors son image par la réécriture est une dérivation
valide de \CCI{}. On rappelle que \CCI{} est équivalent au premier
calcul présenté moins la règle de subsumption.

\begin{theorem}
  Si $`G \typea t : T$ et $\timpl{`G}{t}{T}{`G'}{t'}{T'}$ alors $`G'
  \typec t' : T'$.
\end{theorem}
\setboolean{displayLabels}{false}

\begin{proof}
  Notre traduction est un homomorphisme, il est donc direct que le
  typage soit conservé. Il faut juste s'assurer que l'on ne modifie pas
  la forme des termes et des types par la réecriture. C'est possible
  uniquement pour les règles \irule{App} et \irule{LetSum}, on va donc
  les étudier plus en détail.

  \begin{prooftree}
    \QAX{App}
    {$\timpl{`G}{f}{T}{`G'}{f'}{T'}$}
    {$\muimpl~T' `= (\pi, \Pi x : V'. W')$}
    {$\timpl{`G}{u}{U}{`G'}{u'}{U'}$}
    {$\subimpl{`G'}{c}{U'}{V'}$}
    {$\timpl{`G}{f u}{W[u/x]}{`G'}{(\pi~f')~(c~u')}{W'[ c~u' / x ]}$}
    {}
  \end{prooftree}
  
  Par induction, on sait que $\muimpl(T') `= (\pi, \Pi x : V'. W')$ puisque
  la réecriture ne change pas la forme des types.
  Par définition de $\muimpl$ on a $\pi~f' : \Pi x : V'.W'$.
  On assure donc la forme fonctionelle de $f$ par la réecriture.
  La définition de la coercion nous assure que $c~u' : V'$. On obtient
  donc $(\pi~f) (c~u') : W'[c~u'/x]$. 
  Ici, la coercion pourrait changer la forme du type, par exemple si 
  $W `= x$, on aurait $W'[c~u'/x] = c~u'$. Nous allons montrer que cela
  ne change pas la forme du type.
  Si $W = x$, alors $V'$ ne peut être qu'une sorte. En effet, il n'est
  pas possible de former des produits ayant un terme en membre droit, la
  syntaxe même nous assure que les termes ne peuvent figurer qu'en
  position interne, c'est-à-dire appliqués à un type. Or si $V'$ est une
  sorte, la forme de $W$ et donc de $W'$ n'est pas changé par la
  substitution puisque $x$ n'apparait pas dedans.
  Si $V'$ n'est pas une sorte, il peut être par exemple un produit.
  
  La règle de formation du produit nous assure que si $x$ apparait dans
  $W'$ alors c'est en position interne.


\end{proof}


\begin{proof}
  Par induction sur la réecriture de la dérivation.
  
  \begin{induction}

    \case{WfEmpty}% \quad
%     \begin{prooftree}
%       \UAX{Wf-Atom}
%       {}
%       {$\wf [] "~>"~\wf []$}
%       {}
%     \end{prooftree}
    Trivial.
    
    \case{WfVar}
%     \begin{prooftree}
%       \UAX{Wf-Var}
%       {$\timpl{`G}{A}{s}{`G'}{A'}{s}$}
%       {$\wf `G, x : A "~>"~\wf `G', x : A'$}
%       {$s `: \{ \Set, \Prop, \Type(i) \}$}
%     \end{prooftree}
    Par induction $`G' \typec A' : s$, on applique simplement \irule{WfVar}.
    
    \casetwo{PropSet}{Type}
%     \begin{prooftree}
%       \UAX{PropSet}
%       {$\wf `G "~>" ~\wf `G'$}
%       {$\timpl{`G}{s}{\Type(0)}{`G'}{s}{\Type(0)}$}
%       {$s `: \{ \Prop, \Set \}$} 
%     \end{prooftree}
    Direct par induction.

%     \case{Type}\quad
%     \begin{prooftree}
%       \UAX{Type}
%       {$\wf `G "~>" \wf `G$}
%       {$\timpl{`G}{\Type(i)}{\Type(i + 1)}{`G'}{\Type(i)}{\Type(i + 1)}$}
%       {}
%     \end{prooftree}

    \case{Var}\quad
    \begin{prooftree}
      \BAX{Var}
      {$\wf `G "~>"~\wf `G'$}
      {$x : A `: `G "~>" x : A' `: `G'$}
      {$\timpl{`G}{x}{A}{`G'}{x}{A'}$}
      {}
    \end{prooftree}
    La réecriture ne change pas le domaine des contextes, c'est donc
    direct par induction.

    \case{Prod}\quad
    \begin{prooftree}
      \BAX{Prod}
      {$\timpl{`G}{T}{s1}{`G'}{T'}{s1}$}
      {$\timpl{`G, x : T}{U}{s2}{`G', x : T'}{U'}{s2}$}
      {$\timpl{`G}{\Pi x : T.U}{s2}{`G'}{\Pi x : T'.U'}{s2}$}
      {$(s1, s2) `: \mathcal{R}$}
    \end{prooftree}
    


    \case{Abs}\quad
    \begin{prooftree}
      \BAX{Abs}
      {$\timpl{`G}{\Pi x : T. U}{s}{`G'}{\Pi x : T'. U'}{s}$}
      {$\timpl{`G, x : T}{M}{U}{`G', x : T'}{M'}{U'}$}
      {$\timpl{`G}{\lambda x : T. M}{\Pi x : T.U}
        {`G'}{\lambda x : T'. M'}{\Pi x : T'.U'}$}
      {}
    \end{prooftree}

    \case{App}\quad
    \begin{prooftree}
      \QAX{App}
      {$\timpl{`G}{f}{T}{`G'}{f'}{T'}$}
      {$\mu~T' `= (\pi, \Pi x : V'. W')$}
      {$\timpl{`G}{u}{U}{`G'}{u'}{U'}$}
      {$\subimpl{`G'}{c}{U'}{V'}$}
      {$\timpl{`G}{f u}{W[u/x]}{`G'}{(\pi~f')~(c~u')}{W'[ c~u' / x ]}$}
      {}
    \end{prooftree}

    \case{LetIn}\quad
    \begin{prooftree}
      \BAX{LetIn}
      {$\timpl{`G}{t}{T}{`G'}{t'}{T'}$}
      {$\timpl{`G, x : T}{v}{V}{`G', x : T'}{v'}{V'}$}
      {$\timpl{`G}{\letml~x = t~\inml~v}{V[t / x]}
        {`G'}{\letml~x = t'~\inml~v'}{V'[t' / x]}$}
      {}
    \end{prooftree}

    \case{SigmaR}\quad
    \begin{prooftree}
      \BAX{Sigma}
      {$\timpl{`G}{T}{s1}{`G'}{T'}{s1}$}
      {$\timpl{`G, x : T}{U}{s2}{`G', x : T'}{U'}{s2}$}
      {$\timpl{`G}{\Sigma x : T.U}{s2}{`G'}{\Sigma x : T'.U'}{s2} $}
      {$(s1, s2) `: \mathcal{R}$}
    \end{prooftree}


    \case{SumInf}\quad
    \begin{prooftree}
      \TAXWide{SumInf}
      {$\timpl{`G}{t}{T}{`G'}{t'}{T'}$}
      {$\timpl{`G}{u}{U}{`G'}{u'}{U'}$}
      {$\timpl{`G}{\Sigma \_ : T.U}{s}{`G'}{\Sigma \_ : T'.U'}{s}$}
      {$\timpl{`G}{(t, u)}{\Sigma \_ : T.U}{`G'}{(t', u')}{\Sigma \_ : T'.U'}$}
      {}
    \end{prooftree}

    \case{SumDep}\quad
    \begin{prooftree}
      \TAXWide{SumDep}
      {$\timpl{`G}{t}{T}{`G'}{t'}{T'}$}
      {$\timpl{`G}{u}{U[t/x]}{`G'}{u'}{U'[t'/x]}$}
      {$\timpl{`G}{\Sigma x : T.U}{s}{`G'}{\Sigma x : T'.U'}{s}$}
      {$\timpl{`G}{(t, u : U)}{\Sigma x : T.U}{`G'}{(t', u')}{\Sigma x : T'.U'}$}
      {}
    \end{prooftree}
    
    \case{LetSum}\quad
    \begin{prooftree}
      \BAX{LetSum}
      {$\timpl{`G}{t}{\Sigma x : T. U}{`G'}{t'}{\Sigma x : T'.U'}$}
      {$\timpl{`G, x : T, u : U}{v}{V}{`G, x : T', u : U'}{v'}{V'}$}
      {$\timpl{`G}{\letml~(x, u) = t~\inml~v}{V}
        {`G'}{\letml~(x, u) = t'~\inml~v'}{V'}$}
      {}
    \end{prooftree}

    \case{Subset}\quad
    \begin{prooftree}
      \BAX{Subset}
      {$\timpl{`G}{U}{\Type}{`G'}{U'}{\Type}$}
      {$\timpl{`G, x : U}{P}{\Prop}{`G', x : U'}{P'}{\Prop} $}
      {$\timpl{`G}{\subset{x}{U}{P}}{\Type}{`G'}{\subset{x}{U'}{P'}}{\Type}$}
      {$$}
    \end{prooftree}
  \end{induction}
\end{proof}



% Ce travail est en cours à ce jour, nous nous sommes
% plutôt penchés sur l'implémentation du typeur et de la fonction de
% réécriture avant de commencer cette dernière preuve.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "subset-typing"
%%% LaTeX-command: "TEXINPUTS=\"style:$TEXINPUTS\" latex"
%%% End: 
