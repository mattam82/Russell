\section{Génération des obligations de preuve}
On veut désormais traduire les dérivations du système algorithmique
dans \CCI{} dont le jugement de typage est $\typec$. 
Les termes de \lng{} ne sont pas directement typables dans \CCI{}
puisque nous avons permis d'utiliser des objets comme s'ils avaient des
types différents de leurs types originaux avec la règle de coercion. Il
va donc falloir maintenant expliciter ces coercions pour obtenir des
termes typables dans \CCI{}. Cependant, on ne peut pas créer un terme
complet à partir de notre dérivation, puisqu'on ne peut pas inférer des
preuves arbitraires. On utilise donc des existentielles (intuitivement
des trous dont on ne connait que le type des habitants) pour traduire le
fait qu'il est de la responsabilité de l'utilisateur de prouver que son
utilisation de la coercion n'était pas incorrecte.

\subsection{Interprétation}
On définit l'interprétation $\ip{t}{`G}$ par récurrence sur la forme des
termes (figure \ref{fig:interp}). Cette interprétation renvoie
un terme $t'$ réecrit que l'on montrera bien typé dans l'environnement \CCI{} $\ipG{`G}$.

\begin{definition}[Interprétation des contextes]
  \label{ctx-interp}
  On fait l'extension aux contextes de la façon suivante:
  \begin{itemize}
  \item $\ipG{[]} = []$
  \item $\ipG{`G, x : T} =  \ipG{`G}, x : \ip{T}{`G}$
  \end{itemize}
\end{definition}

\def\typeafn#1#2{\typeml_{#1}(#2)}
\begin{figure}
  \[\begin{array}{lcll}
    \ip{x}{`G} & = & x & \\
    \\
    \ip{s}{`G} & = & s & s `: \setproptype\\
    \\
    \ip{\Pi x : T.U}{`G} 
    & = & \Pi x : \ip{T}{`G}.\ip{U}{`G, x : T} & \\
    & \\
    \ip{\lambda x : `t.v}{`G} 
    & = & \letml~`t' = \ip{`t}{`G}~\inml & \\
    & & \letml~v' = \ip{v}{`G, x : `t}~\inml & \\
    & & (\lambda x : `t'. v') & \\
    & \\
    \ip{f~u}{`G} 
    & = & \letml~F~=\typeafn{`G}{f}~\andml~U = \typeafn{`G}{u}~\inml & \\
    & & \letml~(\Pi x : V.W) = \mualgo(F)~\inml & \\
    & & \letml~\pi = \coerce{`G}{F}{(\Pi x : V.W)} & \\
    & & \letml~c = \coerce{`G}{U}{V}\inml & \\
    & & (\pi~\ip{f}{`G})~(c~\ip{u}{`G}) & \\
    & \\
    \ip{\Sigma x : T.U}{`G} 
    & = & \Sigma x : \ip{T}{`G}.\ip{U}{`G, x : T} & \\
    & \\
    \ip{x \coloneqq t, u : U}{`G}
    & = & \letml~t' = \ip{t}{`G}~\inml & \\
    & & \letml~U' = \typeafn{`G}{u}~\inml& \\
    & & \letml~u' = \ip{u}{`G}~\inml & \\
    & & \letml~c = \coerce{`G}{U'}{U[t/x]}~\inml & \\
    & & (t', c~u') & \\
    & \\
    \ip{\pi_i~t}{`G} 
    & = & \letml~t' = \ip{t}{`G}~\inml & i `: \{ 1, 2 \} \\
    & & \letml~T = \typeafn{`G}{t}~\inml & \\
    & & \letml~\Sigma x : V.W = \mualgo(T)~\inml & \\
    & & \letml~c = \coerce{`G}{T}{(\Sigma x : V.W)}~\inml & \\
    & & \pi_i~c[t'] & \\
    & \\
    \ip{\mysubset{x}{U}{P}}{`G}
    & = & \mysubset{x}{\ip{U}{`G}}{\ip{P}{`G, x : U}}
  \end{array}\]
  \caption{Interprétation dans \CCI{}}
  \label{fig:interp}
\end{figure}

Chaque jugement de coercion du système algorithmique permet de dériver
une coercion explicite qui sera directement appliquée à un objet.

On formalise donc les coercions par des contextes d'évaluation classiques.
\begin{definition}[Contextes d'évaluation]
  \label{eval-ctx}
  Un contexte d'évaluation est un terme formé à partir de la grammaire
  originale des termes à laquelle on ajoute des terminaux $\ctxdot$ dans
  chacune de règles.
\end{definition}

\begin{definition}[Substitution et composition de coercions]
  La substitution (l'application) dans un contexte d'évaluation est notée $c[d]$, elle
  remplace toutes les occurrences de $\ctxdot$ dans $c$ par $d$.

  Le composition de deux coercions notée $c `o d$ est égale à $c[d]$,
  son élément neutre est $\ctxdot$.
  
  La substitution d'un terme pour une variable dans un contexte
  d'évaluation est notée $c[t/x]$ comme pour les termes.
\end{definition}

\subsubsection{Coercions explicites}
On définit le système $\suba$ (figure \ref{fig:coerce-impl-rules})
qui dérive une coercion à partir de deux types $S$ et $T$ dans un environnement $`G$.
On a introduit du déterminisme par rapport au jugement de
coercion algorithmique puisqu'on donne priorité à la règle
\irule{SubSub} par rapport à la règle \irule{SubProof} (ces règles sont
confluentes). On explicite aussi la priorité donnée à la mise en forme
normale de tête (figure \ref{fig:hnfdef}) puis à la dérivation
par rapport au test de conversion dans la prémisse de \irule{SubConv}.

Notre opération de mise en forme normale de tête est définie de la façon suivante:
\begin{figure}[ht]
  \[\begin{array}{lcll}
    \hnf{((\lambda x : T.e)~v)} & = & \hnf{e[v/x]} & \\
    \hnf{\pi_1~(x, y)} & = & \hnf{x} & \\
    \hnf{\pi_2~(x, y)} & = & \hnf{y} & \\
    \hnf{e} & = & e & \{\text{si $e$ est d'une autre forme}\}
  \end{array}\]
  \caption{Définition de la réduction de tête}
  \label{fig:hnfdef}
\end{figure}

On note donc $\hnf{T}$ la forme normale de tête $T$ et $\nf{T}$ la forme normale
de $T$.

\begin{figure}[ht]
  \[\begin{array}{llcll}
    (\beta) & (\lambda x : X.e)~v & = & e[v/x] & \\
    (\pi_i) & \pi_i~\pair{T}{e_1}{e_2} & = & e_i & \\
    (\sigma_i) & \sigma_i~(\elt{E}{P}{e_1}{e_2}) & = & e_i & \\
    (\eta) & (\lambda x : X.e~x) & = & e & \text{si $x `; FV(e)$} \\ % et $e : \Pi x : X.Y$} \\
    (\rho) & \pair{\Sigma x : X.Y}{\pi_1~e}{\pi_2~e} & = & e & \text{si $e : \Sigma x : X. Y$} \\
    & \elt{E}{P}{(\eltpit~e)}{(\eltpip~e)} & = & e & \text{si $e : \mysubset{x}{E}{P}$} \\
    (\sigma) & \elt{E}{P}{t}{p} & = & \elt{E}{P}{t'}{p'} & \text{si $t
      `= t'$}
  \end{array}\]
  \caption{Théorie équationnelle de \CCI{}}
  \label{fig:eqcci}
\end{figure}

On utilise l'équivalence $\eqbpers$ définie comme la clôture réflexive,
symétrique et transitive de la relation définie figure
\ref{fig:eqcci}. Cette relation sera dénotée par $`=$ pour plus de
clarté. Cette relation contient la $\beta$-réduction et les projections
pour les sommes dépendantes, mais aussi des relations nécessaires pour
supporter l'interprétation de termes de \lng{} dans le langage. On a
donc la règle $\eta$ pour l'abstraction et $\rho$ pour le
\emph{surjective pairing} qui s'applique aux sommes dépendantes et aux
objets de type sous-ensemble. Enfin on a une forme limitée
d'indifférence aux preuves pour les objets de type sous-ensemble.
On ajoute une règle de typage au système de \CCI{} pour typer les
existentielles:
\begin{prooftree}
  \AXC{$\tcoq{`G}{P}{\Prop}$}
  \UIC{$\tcoq{`G}{\ex{P}}{P}$}
\end{prooftree}

% enrichie avec les
%existentielles, on étend donc la relation aux existentielles de la façon
%suivante: \[\ex{`G}{P} \eqbres \ex{`G'}{P'} `= `G \eqbres `G' `^ P \eqbres P'\]

\subtiFig

Le système figure \ref{fig:coerce-impl-rules} dérive les termes de
coercion. Il a de bonnes propriétés pour la preuve et l'implémentation
telles que l'unicité et l'admissibilité de la transitivité que nous
montrerons plus tard. 

\subsection{Propriétés}
On veut montrer que si l'on a un jugement valide dans notre système
algorithmique, alors son image par l'interprétation est un jugement
valide de \CCI{}. On rappelle que \CCI{} est équivalent au premier
calcul présenté où la règle de coercion est remplacée par la règle 
de conversion.

\typenvi

\subsubsection{Correction}
Notre problème se ramène à montrer le théorème suivant: 
\[`G \typea t : T "=>" \iG \typec \ip{t}{`G} : \ip{T}{`G}\]
Ce résultat ne se montre pas aisément.
En effet le jugement de coercion rend la preuve
très difficile à cause de son caractère
non local. Pour mieux comprendre ce problème, considérons l'exemple
suivant:

\paragraph{Exemple}
Dans le système algorithmique, on peut très bien dériver
$\Pi n : \nat. \sref{list}~n \suba \Pi n :
\mysubset{x}{\nat}{P}.\listml~n$ puisque $\mysubset{x}{\nat}{P} \suba
\nat$ et $\listml~n \eqbr \listml~n$.
Si l'on interprète ces deux types, une coercion va être insérée dans le
second type: $\ip{\Pi n : \mysubset{x}{\nat}{P}.\listml~n}{`G} = \Pi n :
\mysubset{x}{\nat}{P}.\listml~(\pi_1~n)$. La coercion générée doit donc
avoir pour type: $\Pi n : \nat. \listml~n "->" \Pi n :
\mysubset{x}{\nat}{P}.\listml~(\pi_1~n)$, mais elle est dérivée en se
basant seulement sur les types algorithmiques. On peut vérifier ici
que l'intuition de la coercion par prédicats est bonne, puisqu'on peut
dériver ce jugement:

\begin{prooftree}
  \AXC{$\nat \eqbr \nat$}
  \UIC{$\subimpl{`G'}{\ctxdot}{\nat}{\nat}$}
  \UIC{$\subimpl{`G'}{\pi_1~\ctxdot}{\mysubset{x}{\nat}{P}}{\nat}$}

  \AXC{$\listml~n \eqbr \listml~n$}
  \UIC{$\subimpl{`G, n : \mysubset{x}{\nat}{P}}{\ctxdot}
    {\listml~n}{\listml~n}$}

  \BIC{$\subimpl{`G'}{\lambda x : \ip{\mysubset{x}{\nat}{P}}{`G}.
      \ctxdot~[\ctxdot~(\pi_1~x)] = \ctxdot~(\pi_1 x)}{\Pi n : \nat. \listml~n}
    {\Pi n : \mysubset{x}{\nat}{P}.\listml~n}$}
\end{prooftree}

Supposons $`G \typec t : \Pi n : \nat. \listml~n$ alors on a la dérivation
de typage suivante:
\begin{prooftree}
  
  \AXC{$\timpl{`G, x : \mysubset{x}{\nat}{\ip{P}{`G}}}{t}
    {\Pi n : \nat. \listml~n}$}

  \AXC{$\timpl{`G, x : \mysubset{x}{\nat}{\ip{P}{`G}}}{\pi_1~x}{\nat}$}
  
  \BIC{$\timpl{`G, x : \mysubset{x}{\nat}{\ip{P}{`G}}}
    {t~(\pi_1~x)}
    {\listml~(\pi_1~x)}$}

  \UIC{$\timpl{`G}
    {\lambda x : \ip{\mysubset{x}{\nat}{P}}{`G}. t~(\pi_1~x)}
    {\Pi n : \ip{\mysubset{x}{\nat}{P}}{`G}.\listml~(\pi_1~x)}$}
\end{prooftree}

On crée donc bien un terme de type $\ip{\Pi n :
  \mysubset{x}{\nat}{P}.\listml~n}{`G}$ en appliquant la coercion a un
terme de type $\ip{\Pi n : \nat. \listml~n}{`G}$, c'est l'effet recherché.

\input{subset-typing-impl-subtyping}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "subset-typing"
%%% LaTeX-command: "TEXINPUTS=\"style:$TEXINPUTS\" latex"
%%% End: 
