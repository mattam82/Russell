\section{Génération des obligations de preuve}
On veut désormais traduire les dérivations du système algorithmique
dans \CCI{} dont le jugement de typage est $\typec$. 
Les termes de \lng{} ne sont pas directement typables dans \CCI{}
puisque nous avons permis d'utiliser des objets comme s'ils avaient des
types différents de leurs types originaux avec la règle de coercion. Il
va donc falloir maintenant expliciter ces coercions pour obtenir des
termes typables dans \CCI{}. Cependant, on ne peut pas créer un terme
complet à partir de notre dérivation, puisqu'on ne peut pas inférer des
preuves arbitraires. On utilise donc des existentielles (intuitivement
des trous dont on ne connait que le type des habitants) pour traduire le
fait qu'il est de la responsabilité de l'utilisateur de prouver que son
utilisation de la coercion n'était pas incorrecte.

\newcommand{\ip}[2]{\llbracket #1 \rrbracket_{#2}}
\newcommand{\ipG}[1]{\llbracket #1 \rrbracket}
\newcommand{\ipt}[2]{\llfloor #1 \rrfloor_{#2}}
\newcommand{\ipT}[2]{\llceil #1 \rrceil_{#2}}

L'interprétation $\ip{t}{`G}$ renvoie à la fois un terme $t'$ réecrit et
son type dans l'environnement \Coq{} $`G$.
On utilise les abbréviations suivantes:
\begin{itemize}
\item $\ipt{t}{`G} `= \pi_1~ \ip{t}{`G}$, soit le terme réecrit ;
\item $\ipT{t}{`G} `= \pi_2~ \ip{t}{`G}$, soit le type \Coq{} de $t'$.
\end{itemize}

On définit l'interprétation $\ip{t}{`G}$ par récurrence sur la forme des termes:
\[\begin{array}{lcll}
  \ip{x}{`G} & = & x, `G(x) & \\
  \\
  \ip{s}{`G} & = & s, \Type & s `: \{ \Prop, \Set \}\\
  \ip{\Type}{`G} & = & \Type, \Type(1) & \\
  \\
  \ip{\Pi x : T.U}{`G} 
  & = & \letml~(T', s_{1}) = \ip{T}{`G}~\inml & \\
  & & \letml~(U', s_{2}) = \ip{U}{`G, x : T'}~\inml & \\
  & & \letml~s_3 = \mathcal{R}~s_1~s_2~\inml & \\
  & & (\Pi x : T'.U', s_3) & \\
  & \\
  \ip{\lambda x : `t.v}{`G} 
  & = & \letml~(`t', s') = \ip{`t}{`G}~\inml & \\
  & & \letml~(v', `g) = \ip{v}{`G, x : `t'}~\inml & \\
  & & (\lambda x : `t'. v'), \Pi x : `t'. `g & \\
  & \\
  \ip{f~u}{`G} 
  & = & \letml~(f', `t) = \ip{f}{`G}~\inml & \\
  & & \letml~(\pi, \Pi x : V.W) = \muimpl(`t)~\inml & \\
  & & \letml~(u', U') ` = \ip{u}{`G}~\inml & \\
  & & \letml~c = \sref{coerce}~U'~V~\inml & \\
  & & (\pi~f')~(c~u'), W[c~u/x] & \\
  & \\
  \ip{\Sigma x : T.U}{`G} 
  & = & \letml~(T', s) = \ip{T}{`G}~\inml & \\
  & & \letml~(U', s) = \ip{U}{`G, x : T'}~\inml & \\
  & & (\Sigma x : T'.U', s) & \\
  & \\
  \ip{(x \coloneqq t, u : U)}{`G}
  & = & \letml~(t', T') = \ip{t}{`G}~\inml & \\
  & & \letml~(\Sigma x : T'.U', s) = \ip{\Sigma x : T.U}{`G}~\inml& \\
  & & \letml~(u', U'') = \ip{u}{`G}~\inml & \\
  & & \letml~c = \sref{coerce}~U''~U'[t'/x]~\inml & \\
  & & (t', c~u'), \Sigma x : T'.U' & \\
  & \\
  \ip{\letml~(x,y) = t~\inml~v}{`G} 
  & = & \letml~(t', `t) = \ip{t}{`G}~\inml & \\
  & & \letml~(\pi, \Sigma x : T.U) = \muimpl(`t)~\inml & \\
  & & \letml~(v', V) = \ip{v}{`G, x : T, y : U}~\inml & \\
  & & (\letml~(x, y) = t'~\inml~v'), V & \\
  & \\
  \ip{\mysubset{x}{U}{P}}{`G}
  & = & \letml~(U', \Set) = \ip{U}{`G}~\inml & \\
  & & \letml~(P', \Prop) = \ip{P}{`G, x : U'}~\inml & \\
  & & \mysubset{x}{U'}{P'} : \Set  
\end{array}\]

\typemuiFig
Ici la fonction $\muimpl$ (figure \ref{fig:muimpl-definition}) renvoie à la fois un type (qu'on demande
équivalent à un produit) et une fonction de coercion qui va faire les
projections nécessaires sur l'objet \Coq~$f'$. En effet dans \Coq~les
objets de type sous-ensemble $\mysubset{x}{T}{P}$ sont codés par un terme 
de la forme $\sref{elt}~t~p$ dont on peut extraire les parties objet 
(un certain $t$ de type $T$, par la projection $\Pi_1$) et preuve
(de type $P[t/x]$). Il faut donc faire exactement
une projection pour atteindre par exemple la fonction à partir d'un objet de type
$\mysubset{f}{\nat "->" \nat}{f~0 \neq 0}$.

On fait l'extension aux contextes de la façon suivante:
\begin{itemize}
\item $\ipG{[]} = []$
\item $\ipG{`G, x : T} =  \ipG{`G}, x : \ipt{T}{\ipG{`G}}$
\end{itemize}

\subsection{Coercions explicites}
On définit la fonction $\sref{coerce}$ de façon récursive sur la dérivation
de coercion: $\sref{coerce}~U~V = c$ si $c : U \subi V$.
On va décrire informellement le sens de chaque règle:
\typenvi
\vspace{1.4em}
\begin{itemize}
\item[ \SubConvI\DP:] \quad\\

  Crée une coercion identité puisque \CCI{}~a la règle de conversion. 
  \vspace{1em}

\item[\SubLeftI\DP:] \quad\\
  
  Engendre une projection,
  c'est le cas où l'on ne s'intéresse pas à la preuve accompagnant
  l'objet. 
  \vspace{1em}

\item[\SubRightI\DP:] \quad\\

  Correspond à la génération d'une
  obligation de preuve dans \PVS. On utilise le mécanisme des variables
  existentielles (notées $?:\text{type}$) décrit plus loin pour donner 
  l'information au système qu'il faut compléter le terme à un endroit
  donné avec un nouveau terme de type approprié. On peut aisément créer
  des obligations qui ne seront pas prouvables mais cela relève de la
  responsabilité de l'utilisateur.
  \vspace{1em}

\item[\SubProdI\DP,] \quad\\
  

\item[\SubSigmaI\DP:] \quad\\

  Réalisent respectivement
  les coercions pour les produits fonctionnels et cartésiens.

\end{itemize}

\subticFig

% \input{typing-impl-new}
%\typeinewFig
\input{subset-typing-impl-proof}


% Nous avons de bonnes raisons de penser que la traduction fonctionne: le
% système \PVS{} repose sur système similaire depuis des années, notre
% réécriture fonctionne en pratique et enfin, on voit bien que le système
% déclaratif se plonge dans \CCI{} aisément. Dans ce cas, il suffit de
% voir que la règle de coercion permet toujours de trouver une fonction de
% $U$ à $T$ et qu'elle ne peut modifier que la forme des objets, alors
% qu'aucune règle ne repose dessus.

% \begin{proof}
%   Notre traduction est un homomorphisme, il est donc direct que le
%   typage soit conservé. Il faut juste s'assurer que l'on ne modifie pas
%   la forme des termes et des types par la réécriture. C'est possible
%   uniquement pour les règles \irule{App} et \irule{LetSum}, on va donc
%   les étudier plus en détail.

%   \begin{prooftree}
%     \QAX{App}
%     {$\timpl{`G}{f}{T}{`G'}{f'}{T'}$}
%     {$\muimpl~T' `= (\pi, \Pi x : V'. W')$}
%     {$\timpl{`G}{u}{U}{`G'}{u'}{U'}$}
%     {$\subimpl{`G'}{c}{U'}{V'}$}
%     {$\timpl{`G}{f u}{W[u/x]}{`G'}{(\pi~f')~(c~u')}{W'[ c~u' / x ]}$}
%     {}
%   \end{prooftree}
  
%   Par induction, on sait que $\muimpl(T') `= (\pi, \Pi x : V'. W')$ puisque
%   la réécriture ne change pas la forme des types.
%   Par définition de $\muimpl$ on a $\pi~f' : \Pi x : V'.W'$.
%   On assure donc la forme fonctionelle de $f$ par la réécriture.
%   La définition de la coercion nous assure que $c~u' : V'$. On obtient
%   donc $(\pi~f) (c~u') : W'[c~u'/x]$. 
%   Ici, la coercion pourrait changer la forme du type, par exemple si 
%   $W `= x$, on aurait $W'[c~u'/x] = c~u'$. Nous allons montrer que cela
%   ne change pas la forme du type.
%   Si $W = x$, alors $V'$ ne peut être qu'une sorte. En effet, il n'est
%   pas possible de former des produits ayant un terme en membre droit, la
%   syntaxe même nous assure que les termes ne peuvent figurer qu'en
%   position interne, c'est-à-dire appliqués à un type. Or si $V'$ est une
%   sorte, la forme de $W$ et donc de $W'$ n'est pas changé par la
%   substitution puisque $x$ n'apparait pas dedans.
%   Si $V'$ n'est pas une sorte, il peut être par exemple un produit.
  
%   La règle de formation du produit nous assure que si $x$ apparait dans
%   $W'$ alors c'est en position interne.


% \end{proof}


% \begin{proof}
%   Par induction sur la réécriture de la dérivation.
  
%   \begin{induction}

%     \case{WfEmpty}% \quad
% %     \begin{prooftree}
% %       \UAX{Wf-Atom}
% %       {}
% %       {$\wf [] "~>"~\wf []$}
% %       {}
% %     \end{prooftree}
%     Trivial.
    
%     \case{WfVar}
% %     \begin{prooftree}
% %       \UAX{Wf-Var}
% %       {$\timpl{`G}{A}{s}{`G'}{A'}{s}$}
% %       {$\wf `G, x : A "~>"~\wf `G', x : A'$}
% %       {$s `: \{ \Set, \Prop, \Type(i) \}$}
% %     \end{prooftree}
%     Par induction $`G' \typec A' : s$, on applique simplement \irule{WfVar}.
    
%     \casetwo{PropSet}{Type}
% %     \begin{prooftree}
% %       \UAX{PropSet}
% %       {$\wf `G "~>" ~\wf `G'$}
% %       {$\timpl{`G}{s}{\Type(0)}{`G'}{s}{\Type(0)}$}
% %       {$s `: \{ \Prop, \Set \}$} 
% %     \end{prooftree}
%     Direct par induction.

% %     \case{Type}\quad
% %     \begin{prooftree}
% %       \UAX{Type}
% %       {$\wf `G "~>" \wf `G$}
% %       {$\timpl{`G}{\Type(i)}{\Type(i + 1)}{`G'}{\Type(i)}{\Type(i + 1)}$}
% %       {}
% %     \end{prooftree}

%     \case{Var}\quad
%     \begin{prooftree}
%       \BAX{Var}
%       {$\wf `G "~>"~\wf `G'$}
%       {$x : A `: `G "~>" x : A' `: `G'$}
%       {$\timpl{`G}{x}{A}{`G'}{x}{A'}$}
%       {}
%     \end{prooftree}
%     La réécriture ne change pas le domaine des contextes, c'est donc
%     direct par induction.

%     \case{Prod}\quad
%     \begin{prooftree}
%       \BAX{Prod}
%       {$\timpl{`G}{T}{s1}{`G'}{T'}{s1}$}
%       {$\timpl{`G, x : T}{U}{s2}{`G', x : T'}{U'}{s2}$}
%       {$\timpl{`G}{\Pi x : T.U}{s2}{`G'}{\Pi x : T'.U'}{s2}$}
%       {$(s1, s2) `: \mathcal{R}$}
%     \end{prooftree}
    


%     \case{Abs}\quad
%     \begin{prooftree}
%       \BAX{Abs}
%       {$\timpl{`G}{\Pi x : T. U}{s}{`G'}{\Pi x : T'. U'}{s}$}
%       {$\timpl{`G, x : T}{M}{U}{`G', x : T'}{M'}{U'}$}
%       {$\timpl{`G}{\lambda x : T. M}{\Pi x : T.U}
%         {`G'}{\lambda x : T'. M'}{\Pi x : T'.U'}$}
%       {}
%     \end{prooftree}

%     \case{App}\quad
%     \begin{prooftree}
%       \QAX{App}
%       {$\timpl{`G}{f}{T}{`G'}{f'}{T'}$}
%       {$\mu~T' `= (\pi, \Pi x : V'. W')$}
%       {$\timpl{`G}{u}{U}{`G'}{u'}{U'}$}
%       {$\subimpl{`G'}{c}{U'}{V'}$}
%       {$\timpl{`G}{f u}{W[u/x]}{`G'}{(\pi~f')~(c~u')}{W'[ c~u' / x ]}$}
%       {}
%     \end{prooftree}

%     \case{LetIn}\quad
%     \begin{prooftree}
%       \BAX{LetIn}
%       {$\timpl{`G}{t}{T}{`G'}{t'}{T'}$}
%       {$\timpl{`G, x : T}{v}{V}{`G', x : T'}{v'}{V'}$}
%       {$\timpl{`G}{\letml~x = t~\inml~v}{V[t / x]}
%         {`G'}{\letml~x = t'~\inml~v'}{V'[t' / x]}$}
%       {}
%     \end{prooftree}

%     \case{SigmaR}\quad
%     \begin{prooftree}
%       \BAX{Sigma}
%       {$\timpl{`G}{T}{s1}{`G'}{T'}{s1}$}
%       {$\timpl{`G, x : T}{U}{s2}{`G', x : T'}{U'}{s2}$}
%       {$\timpl{`G}{\Sigma x : T.U}{s2}{`G'}{\Sigma x : T'.U'}{s2} $}
%       {$(s1, s2) `: \mathcal{R}$}
%     \end{prooftree}


%     \case{SumInf}\quad
%     \begin{prooftree}
%       \TAXWide{SumInf}
%       {$\timpl{`G}{t}{T}{`G'}{t'}{T'}$}
%       {$\timpl{`G}{u}{U}{`G'}{u'}{U'}$}
%       {$\timpl{`G}{\Sigma \_ : T.U}{s}{`G'}{\Sigma \_ : T'.U'}{s}$}
%       {$\timpl{`G}{(t, u)}{\Sigma \_ : T.U}{`G'}{(t', u')}{\Sigma \_ : T'.U'}$}
%       {}
%     \end{prooftree}

%     \case{SumDep}\quad
%     \begin{prooftree}
%       \TAXWide{SumDep}
%       {$\timpl{`G}{t}{T}{`G'}{t'}{T'}$}
%       {$\timpl{`G}{u}{U[t/x]}{`G'}{u'}{U'[t'/x]}$}
%       {$\timpl{`G}{\Sigma x : T.U}{s}{`G'}{\Sigma x : T'.U'}{s}$}
%       {$\timpl{`G}{(t, u : U)}{\Sigma x : T.U}{`G'}{(t', u')}{\Sigma x : T'.U'}$}
%       {}
%     \end{prooftree}
    
%     \case{LetSum}\quad
%     \begin{prooftree}
%       \BAX{LetSum}
%       {$\timpl{`G}{t}{\Sigma x : T. U}{`G'}{t'}{\Sigma x : T'.U'}$}
%       {$\timpl{`G, x : T, u : U}{v}{V}{`G, x : T', u : U'}{v'}{V'}$}
%       {$\timpl{`G}{\letml~(x, u) = t~\inml~v}{V}
%         {`G'}{\letml~(x, u) = t'~\inml~v'}{V'}$}
%       {}
%     \end{prooftree}

%     \case{Subset}\quad
%     \begin{prooftree}
%       \BAX{Subset}
%       {$\timpl{`G}{U}{\Type}{`G'}{U'}{\Type}$}
%       {$\timpl{`G, x : U}{P}{\Prop}{`G', x : U'}{P'}{\Prop} $}
%       {$\timpl{`G}{\mysubset{x}{U}{P}}{\Type}{`G'}{\mysubset{x}{U'}{P'}}{\Type}$}
%       {$$}
%     \end{prooftree}
%   \end{induction}
% \end{proof}



% Ce travail est en cours à ce jour, nous nous sommes
% plutôt penchés sur l'implémentation du typeur et de la fonction de
% réécriture avant de commencer cette dernière preuve.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "subset-typing"
%%% LaTeX-command: "TEXINPUTS=\"style:$TEXINPUTS\" latex"
%%% End: 
