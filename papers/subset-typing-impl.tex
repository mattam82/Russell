\section{Génération des obligations de preuve}
On veut désormais traduire les dérivations du système algorithmique
dans \CCI{} dont le jugement de typage est $\typec$. 
Les termes de \lng{} ne sont pas directement typables dans \CCI{}
puisque nous avons permis d'utiliser des objets comme s'ils avaient des
types différents de leurs types originaux avec la règle de coercion. Il
va donc falloir maintenant expliciter ces coercions pour obtenir des
termes typables dans \CCI{}. Cependant, on ne peut pas créer un terme
complet à partir de notre dérivation, puisqu'on ne peut pas inférer des
preuves arbitraires. On utilise donc des existentielles (intuitivement
des trous dont on ne connait que le type des habitants) pour traduire le
fait qu'il est de la responsabilité de l'utilisateur de prouver que son
utilisation de la coercion n'était pas incorrecte.

\subsection{Interprétation}
On définit l'interprétation $\ip{t}{`G}$ par récurrence sur la forme des
termes (figure \ref{fig:interp}). Cette interprétation renvoie
un terme $t'$ réecrit bien typé dans l'environnement \CCI{} $\ipG{`G}$.

\begin{definition}[Interprétation des contextes]
  \label{ctx-interp}
  On fait l'extension aux contextes de la façon suivante:
  \begin{itemize}
  \item $\ipG{[]} = []$
  \item $\ipG{`G, x : T} =  \ipG{`G}, x : \ipt{T}{`G}$
  \end{itemize}
\end{definition}


\def\typeafn#1#2{\typeml_{#1}(#2)}
\begin{figure}
  \[\begin{array}{lcll}
    \ip{x}{`G} & = & x & \\
    \\
    \ip{s}{`G} & = & s & s `: \setproptype\\
    \\
    \ip{\Pi x : T.U}{`G} 
    & = & \Pi x : \ip{T}{`G}.\ip{U}{`G, x : T} & \\
    & \\
    \ip{\lambda x : `t.v}{`G} 
    & = & \letml~`t' = \ip{`t}{`G}~\inml & \\
    & & \letml~v' = \ip{v}{`G, x : `t}~\inml & \\
    & & (\lambda x : `t'. v') & \\
    & \\
    \ip{f~u}{`G} 
    & = & \letml~F~=\typeafn{`G}{f}~\andml~U = \typeafn{`G}{u}~\inml & \\
    & & \letml~(\Pi x : V.W) = \mualgo(F)~\inml & \\
    & & \letml~\pi = \coerce{`G}{F}{(\Pi x : V.W)} & \\
    & & \letml~c = \coerce{`G}{U}{V}\inml & \\
    & & (\pi~\ip{f}{`G})~(c~\ip{u}{`G}) & \\
    & \\
    \ip{\Sigma x : T.U}{`G} 
    & = & \Sigma x : \ip{T}{`G}.\ip{U}{`G, x : T} & \\
    & \\
    \ip{x \coloneqq t, u : U}{`G}
    & = & \letml~t' = \ip{t}{`G}~\inml & \\
    & & \letml~U' = \typeafn{`G}{u}~\inml& \\
    & & \letml~u' = \ip{u}{`G}~\inml & \\
    & & \letml~c = \coerce{`G}{U'}{U[t/x]}~\inml & \\
    & & (t', c~u') & \\
    & \\
    \ip{\pi_i~t}{`G} 
    & = & \letml~t' = \ip{t}{`G}~\inml & i `: \{ 1, 2 \} \\
    & & \letml~T = \typeafn{`G}{t}~\inml & \\
    & & \letml~\Sigma x : V.W = \mualgo(T)~\inml & \\
    & & \letml~c = \coerce{`G}{T}{(\Sigma x : V.W)}~\inml & \\
    & & \pi_i~c[t'] & \\
    & \\
    \ip{\mysubset{x}{U}{P}}{`G}
    & = & \mysubset{x}{\ip{U}{`G}}{\ip{P}{`G, x : U}}
  \end{array}\]
  \caption{Interprétation dans \CCI{}}
  \label{fig:interp}
\end{figure}

Chaque jugement de coercion du système algorithmique permet de dériver
une coercion explicite qui sera directement appliquée à un objet.

On formalise donc les coercions par des contextes d'évaluation classiques.
\begin{definition}[Contextes d'évaluation]
  \label{eval-ctx}
  Un contexte d'évaluation est un terme formé à partir de la grammaire
  originale des termes à laquelle on ajoute des terminaux $\ctxdot$ dans
  chacune de règles.
\end{definition}

\begin{definition}[Substitution et composition de coercions]
  La substitution (l'application) dans un contexte d'évaluation est notée $c[d]$, elle
  remplace toutes les occurences de $\ctxdot$ dans $c$ par $d$.

  Le composition de deux coercions notée $c `o d$ est égale à $c[d]$,
  son élément neutre est $\ctxdot$.
  
  La substitution d'un terme pour une variable dans un contexte
  d'évaluation est notée $c[t/x]$ comme pour les termes.
\end{definition}

\subsubsection{Coercions explicites}
On définit le système $\suba$ (figure \ref{fig:coerce-impl-rules})
qui dérive une coercion à partir de deux types $S$ et $T$ dans un environnement $`G$.
On a introduit du déterminisme par rapport au jugement de
coercion algorithmique puisqu'on donne priorité à la règle
\irule{SubSub} par rapport à la règle \irule{SubProof} (ces règles sont
confluentes). On explicite aussi la prioritée donnée à la mise en forme
normale de tête (figure \ref{fig:hnfdef}) puis à la dérivation
par rapport au test de
conversion dans la prémisse de \irule{SubConv}.

Notre opération de mise en forme normale de tête est définie de la façon suivante:
\begin{figure}[h]
  \[\begin{array}{lcl}
    \hnf{((\lambda x : T.e)~v)} & = & \hnf{e[v/x]} \\
    \hnf{\pi_1~(x, y)} & = & \hnf{x} \\
    \hnf{\pi_2~(x, y)} & = & \hnf{y} \\
    \hnf{x} & = & x
  \end{array}\]
  \caption{Définition de réduction de tête}
  \label{fig:hnfdef}
\end{figure}

On utilise la $\beta\rho$-équivalence de $CCI$ enrichie avec les
existentielles, on étend donc la relation aux existentielles de la façon
suivante: \[\ex{`G}{P} \eqbr \ex{`G'}{P'} `= `G \eqbr `G' `^ P \eqbr P'\]

\subtiFig

Le système figure \ref{fig:coerce-impl-rules} dérive les termes de
coercion. Il a de bonnes propriétés pour la preuve et l'implémentation
telles que l'unicité et l'élimination de la transitivité que nous
montrerons plus tard.

\subsection{Propriétés}
On veut montrer que si l'on a un jugement valide dans notre système
algorithmique, alors son image par l'interprétation est un jugement
valide de \CCI{}. On rappelle que \CCI{} est équivalent au premier
calcul présenté où la règle de coercion est remplacée par la règle 
de conversion.

\typenvi

\subsubsection{Correction}
Notre problème se rammène à montrer le théorème suivant: 
\[`G \typea t : T "=>" \iG \typec \ip{t}{`G} : \ip{T}{`G}\]
Ce résultat ne se montre pas aisément.
En effet le jugement de coercion rend la preuve
très difficile à cause de son caractère
non local. Pour mieux comprendre ce problème, considérons l'exemple
suivant:

\paragraph{Exemple}
Dans le système algorithmique, on peut très bien dériver
$\Pi n : \nat. \sref{list}~n \suba \Pi n :
\mysubset{x}{\nat}{P}.\listml~n$ puisque $\mysubset{x}{\nat}{P} \suba
\nat$ et $\listml~n \eqbr \listml~n$.
Si l'on réécrit vers \CCI{}, on n'aura plus les même types
de départ pour dériver le jugement puisqu'on part de types \Coq~valides.
Ici, une coercion a été insérée dans le second type:
$`G' \typec c : \Pi n : \nat. \listml~n \subi \Pi n :
\mysubset{x}{\nat}{P}.\listml~(\pi_1~n)$. Seulement, et c'est là la
preuve que l'intuition de la coercion par prédicats est bonne, on peut
dériver ce jugement:

\begin{prooftree}
  \AXC{$\nat \eqbr \nat$}
  \UIC{$\subimpl{`G'}{\ctxdot}{\nat}{\nat}$}
  \UIC{$\subimpl{`G'}{\pi_1~\ctxdot}{\mysubset{x}{\nat}{P}}{\nat}$}

  \AXC{$(\listml~n)[\pi_1~n/n] \eqbr \listml~(\pi_1~n)$}
  \UIC{$\subimpl{`G, n : \mysubset{x}{\nat}{P}}{\ctxdot}
    {(\listml~n)[\pi_1~n/n]}{\listml~(\pi_1~n)}$}

  \BIC{$\subimpl{`G'}{\lambda x.f~(\pi_1~x)}{\Pi n : \nat. \listml~n}
    {\Pi n : \mysubset{x}{\nat}{P}.\listml~(\pi_1~n)}$}
\end{prooftree}

\input{subset-typing-impl-subtyping}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "subset-typing"
%%% LaTeX-command: "TEXINPUTS=\"style:$TEXINPUTS\" latex"
%%% End: 
