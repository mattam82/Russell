\documentclass[twocolumn]{article}
\usepackage{abbrevs}
\usepackage{array}
%\usepackage{
\usepackage{amsmath}

%\usepackage{qzapfcha}
%\usepackage{cmbright}
\usepackage{concmath}
\usepackage{ifthen}

\newboolean{defineTheoremFr}
\newboolean{defineTheoremEn}
\setboolean{defineTheoremFr}{false}
\setboolean{defineTheoremEn}{true}
\input{mathenv}

\usepackage{bussproofs}
% Optional to turn on the short abbreviations
\EnableBpAbbreviations

\input{typing-macros}
\input{typing-decl}
\input{typing-algo}

\usepackage{framed}
%\usepackage{multicol}

\author{Matthieu Sozeau \\
  sozeau@lri.fr}
\title{Subset coercions in \Coq}
\date{\today}

\begin{document}
\maketitle

\abstract{We set out to establish a phase distinction between writing and
  proving algorithms in the \Coq{} environment. Concretely, this means
  allowing to write algorithms as easily as in a pratical functionnal 
  programming language
  whilst giving them as rich a specification as desired and proving that
  the code meets the specification using the whole \Coq{} proof
  apparatus. This is achieved by extending conversion to an equivalence 
  which relates types
  and subsets based on them, a technique  
  originating from the ``\emph{Predicate subtyping}'' feature of \PVS{} and
  following mathematical convention. The typing judgments can be
  translated to the \CICfull (\CIC{}) by means of an interpretation which inserts
  coercions at the appropriate places. These coercions can contain
  existential variables representing the propositional parts of the final
  term. A prototype implementation of this process
  has been implemented.}

\section{Introduction}
There are many means to program in the \Coq{} environment. One
can write programs as in \ML{} and prove properties about them
separately, loosing the possibility of using dependent types in
specifications, or give a rich type expressing them as a goal and use the
proof tactics to solve it, producing a corresponding program by the
\CurryHoward isomorphism but having much less control on its algorithmic
essence. It is however difficult to mix the two methods
(writing code and prove interactively) using a rich specification. We
propose a solution to overcome this difficulty, based on the \ps{}
\cite{Shankar&Owre:WADT99} technique of \PVS{}
\cite{PVS:Language,PVS:Semantics-TR}. This solution also provides
facilities to express properties with a syntaxicaly more mathematical flavor,
bridging the gap between mathematical convention and type theory.

The \Program{} tactic by C. Parent \cite{conf/mpc/Parent95} had the same
goal as ours but a slightly different method for achieving it. It was strongly
linked to the extraction mechanism included in \Coq, both theoreticaly
and practically. Sketching the mechanism, they defined a weakened
extraction operation on \CIC{} terms which could be inverted because it left enough
information in the extracted term to rebuild a partial proof. The
mechanism, while general and theoreticaly well thought out, required
some heuristics and did not integrate smoothly with the \Coq{}
environment. In particular it lacked the pervasivness our method has,
being applicable in a wide variety of situations in the proof assistant
environment.

Instead of trying to find a general method for synthetising proofs from
programs in the \CICfull, we have integrated a method which permits to
link strong specifications and purely algorithmical code. This method,
known as \ps{} in the \PVS{} system has been used with great success and
fits naturally with how we write specifications. The main contribution
of this paper is to show how the \ps{} method can be adapted in a proof
assistant with proof terms, which formally justifies the extension in
the first place.

The rest of the article is organized as follows: first we present a
type system based on \ECC{}, which integrates subset ``subtyping'', and
we show how it relates to \CIC{} by means of traductions between
judgements of the two systems. Then, we present a prototype
implementation with some case studies, and finally we give our
conclusions on this work and discuss future directions.

\section{\Russell{}}
The name of our language is an homage to the mathematician ? Russell who
discovered the famous paradox of set theory with the unrestricted
comprehension axiom. In this theory, it is possible to construct the set
$X = \{x `| x `; x\}$ whose definition is circular. Clearly, if $X `: X$
then $X `; X$ and if $X `; X$ then $X `: X$, hence we have an
inconsistency. \Russell{} was one of the pioneers of type theory when he
devised a set theory with a restricted comprehension axiom that
permitted to create subsets only from already defined subsets,
forbidding the definition of $X$. 

The subset equivalence idea is to identify elements of subsets if
they are built from the same underlying set. That is, we can identify
elements of $`N$ with elements of any subset $\{ x `: `N `| P \}$.
However, we should not be able to draw conclusions based on the
properties attached to an element of a subset. Otherwise it would be
possible to claim that $0 `: \{ x `: `N `| x \neq 0 \}$ but also that $0
\neq 0$ which would lead us to inconsistency. 

Informally, this idea is already present in mathematics. When you have a
subset $\{ x `: S `| P \}$, you can freely forget about the property $P$
and use any operation which is defined on $S$. Conversely, when you
want to use an operation defined on a subset, you usually prove \emph{first}
that you apply it only to elements having the desired property. 
In the context of formal development of programs, such a workflow is not
entirely satisfactory because it forces one to create objects and prove
properties about them \emph{at the same time}. We would like for example
to prove that our usage of partial functions is correct only after the
program is wrote. Subsets are particularly well-suited in this respect
because they separate the objects we want to manipulate and the
properties which we use to reason about them.

\subsection{From \ps{} to subset equivalence}
The \ps{} mechanism \cite{Rushby98:TSE, Shankar&Owre:WADT99}
is an extension of the \PVS type system which internalizes this idea.
Concretely, this means that the following rules are derivable in \PVS:
\begin{figure}[h]
  \begin{center}
    \AXC{$`G \vdash t : \{ x : T `| P[x] \}$}
    \UIC{$`G \vdash t : T$}
    \DP
    \AXC{$`G \vdash t : T$}
    \AXC{$`G \vdash P[t]$}
    \BIC{$`G \vdash t : \{ x : T `| P[x] \}$}
    \DP
  \end{center}
  \vspace{-1em}
  \label{PVS:rules}
  \caption{\PVS}
\end{figure}

The first one formalizes the fact that an object of a subset based on
$T$ is an object of type $T$. The second one permits using an object of
type $T$ as an object of type $\{ x : T `| P[x] \}$, but it generates a
\emph{type checking condition} $`G \vdash P[t]$ which will need to be
discharged later. Effectively, the typing algorithm of \PVS{} collects
the conditions that must be satisfied for the term to be accepted as a
valid definition. However, the acceptance criteria is rather vague in
\PVS{}. By design, when proving in \PVS{}, the trusted code base (TCB
hereafter) is the entire system, not only the typing system but also the
various decision procedures and tactics used to build proofs
automatically or interactively. It is nonetheless a widely used proof
assistant and the predicate subtyping feature has apparently helped to
build a consequent library of certified code. On the other hand, \Coq
has a small TCB and greater expressiveness but less automation and
methodology to build certified programs. We capitalize on the \PVS
success to make \Coq more usable for this kind of tasks, and as we will see,
it will have other benefits.

\subsection{Typing and conversion}
Our adaptation of \ps{} differs from the presentation of
\ps{} in \cite{Rushby98:TSE, Shankar&Owre:WADT99} essentially because of the
proof terms, but we have also extended it in some ways. 

\subsubsection{The typing judgment}
\Russell{}'s typing system (figure \ref{fig:typing-algo-rules}) is based
on the \ECCfull \cite{Luo:ECC}, with sigma types but without universes.
This restriction may be removed in future work, but cause no problem for
our main purpose which is programming. The judgement $`G \typed t : T$
means $t$ is a well-typed term of type $T$ in environment $`G$, and $`G
\typed T \subd U$ means $T$ is convertible to $U$ in environment $`G$.

We need to restrict the system so that it becomes property irrelevant for
the propositions appearing in subset types. Indeed, in \PVS{} you can't
manipulate proof terms, so you have
no way to create a term of type $0 \neq 0$ from the judgment $0 :
\mysubset{x}{`N}{P}$, but in a classical Calculus of Constructions with
sigma types or inductive types, the subset type is a first class object
defined with proper introduction and
elimination terms (figure \ref{fig:subset}). What we need to do is forbid the use of these terms
in \Russell{} terms, leaving only the type former.

\begin{figure}
  \begin{center}
    \def\type{\typed}
    \AXC{$`G \type A : \Set$}
    \AXC{$`G, x : A \type P : \Prop$}
    \BIC{$`G \type \mysubset{x}{A}{P} : \Set$}
    \DP
    
    \vspace{\infvspace}

    \AXC{$`G \type a : A$}
    \AXC{$`G \type p : P[a/x]$}
    \BIC{$`G \type \elt{A}{(\lambda x : A.P)}{a}{p} : \mysubset{x}{A}{P}$}
    \DP
    \vspace{\infvspace}

    \AXC{$`G \type t : \mysubset{x}{A}{P}$}
    \UIC{$`G \type \text{proj1\_sig}~t : A$}
    \DP
    \vspace{\infvspace}

    \AXC{$`G \type t : \mysubset{x}{A}{P}$}
    \UIC{$`G \type \text{proj2\_sig}~t : P[\text{proj1\_sig}~t/x]$}
    \DP
  \end{center}
  \caption{Subset type in \CCI}
  \label{fig:subset}
\end{figure}

\begin{figure*}[t]
  \typedRules
\caption{\Russell{} typing}
\end{figure*}


\subsubsection{Equivalence}
We have renamed the technique from \ps{} to 
subset \emph{equivalence} because we have a symmetric relation, contrary
to usual subtyping relations. 
because we can state reflexivity

- Not subtyping but conversion. Contravariant product.

\subsubsection{Properties}
- Assumptions, results, algo system.

\subsection{From \CCq to \lng{}}
- Present \CCq
- Forgetful map

\section{From \lng{} to \CCq{}}
mutually recursive...

\subsection{Explicit coercions}
... derivation algo.

\subsection{Terms}
- Follows algo typing derivation. Done at the same time as typing in the
impl.

\subsection{Properties}
- Proofs.

\section{Conclusion}
\subsection{Related work}

\subsection{Further work}

\end{document}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% LaTeX-command: "TEXINPUTS=\"..:../style:$TEXINPUTS\" latex"
%%% End: 
