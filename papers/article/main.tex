\documentclass{llncs}
\usepackage{abbrevs}
\usepackage{array}

\def\text{\mbox}

%\usepackage{amsmath}
%\usepackage{amsthm}

%\usepackage{qzapfcha}
%\usepackage{cmbright}
\usepackage{concmath}
\usepackage{ifthen}
\usepackage{url}
\usepackage{varioref}

\newboolean{defineTheoremFr}
\newboolean{defineTheoremEn}
\setboolean{defineTheoremFr}{false}
\setboolean{defineTheoremEn}{false}
\input{mathenv}

\usepackage{bussproofs}
% Optional to turn on the short abbreviations
\EnableBpAbbreviations
\def\ScoreOverhang{3pt}			% How much underlines extend out
\def\defaultHypSeparation{\hskip.05in}   % Used if \insertBetweenHyps isn't given

\input{typing-macros}
\input{typing-decl}
\input{subtyping-decl}
\input{typing-algo}
\input{subtyping-algo}
\renewcommand{\SubSubAs}[1][\Gamma]{%
\UAX{SubSub}
{$\subalgoimpl{#1}{c}{U}{T}{\Set}$}
{$\subalgoimpl{#1}{c[\eltpit~\ctxdot]}{\mysubset{x}{U}{P}}{T}{\Set}$}
{}
}

\input{typing-impl}
\input{subtyping-impl}

\def\sidecond{\sideconden}

\usepackage{framed}
%\usepackage{multicol}

\def\CCI{\CIC}

\author{Matthieu Sozeau\inst{1}}

\institute{LRI, Paris Sud XI University\\\email{sozeau@lri.fr}}
\title{Subset coercions in \Coq}
\date{\today}

\begin{document}
\maketitle

\abstract{We propose a new language for writing programs with dependent
  types which can be elaborated into \Coq terms. This language permits
  to establish a phase distinction between writing and proving
  algorithms in the \Coq{} environment.  Concretely, this means allowing
  to write algorithms as easily as in a pratical functionnal programming
  language whilst giving them as rich a specification as desired and
  proving that the code meets the specification using the whole \Coq{}
  proof apparatus. This is achieved by extending conversion to an
  equivalence which relates types and subsets based on them, a technique
  originating from the ``\emph{Predicate subtyping}'' feature of \PVS{}
  and following mathematical convention. The typing judgments can be
  translated to the \CICfull (\CIC{}) by means of an interpretation
  which inserts coercions at the appropriate places. These coercions can
  contain existential variables representing the propositional parts of
  the final term. A prototype implementation of this process has been
  implemented.}

\section{Introduction}
There are many means to program in the \Coq{} environment. One
can write programs as in \ML{} and prove properties about them
separately, loosing the possibility of using dependent types in
specifications, or give a rich type expressing them as a goal and use the
proof tactics to solve it, producing a corresponding program by the
\CurryHoward isomorphism but having much less control on its algorithmic
essence. It is however difficult to mix the two methods
(writing code and prove interactively) using a rich specification. We
propose a solution to overcome this difficulty, based on the \ps{}
\cite{Shankar&Owre:WADT99} technique of \PVS{}
\cite{PVS:Language,PVS-Semantics:TR}. This solution also provides
facilities to express properties with a more mathematical flavor,
bridging a gap between mathematical convention and type theory.

The \Program{} tactic by C. Parent \cite{conf/mpc/Parent95} had the same
goal as ours but a slightly different method for achieving it. It was strongly
linked to the extraction mechanism included in \Coq, both theoreticaly
and practically. Sketching the mechanism, she defined a weakened
extraction operation on \CIC{} terms which could be inverted because it left enough
information in the extracted term to rebuild a partial proof. The
mechanism, while general and theoreticaly well thought out, required
some heuristics and did not integrate smoothly with the \Coq{}
environment. In particular it lacked the pervasivness our method has,
being applicable in a wide variety of situations in the proof assistant
environment.

Instead of trying to find a general method for synthetising proofs from
programs in the \CICfull, we have integrated a method which permits to
link strong specifications and purely algorithmical code. This method,
known as \ps{} in the \PVS{} system has been used with great success and
fits naturally with how we write specifications. The main contribution
of this paper is to show how the \ps{} method can be adapted in a proof
assistant with proof terms, which formally justifies the extension in
the first place.

The rest of the article is organized as follows: first we present a
type system based on \CC, which integrates subset ``subtyping'', and
we show how it relates to \CIC{} by means of traductions between
judgements of the two systems. Then, we present a prototype
implementation with some case studies, and finally we give our
conclusions on this work and discuss future directions.

\section{\Russell{}}
The name of our language is an homage to the mathematician Bertrand Russell who
discovered the famous paradox of set theory with the unrestricted
comprehension axiom. In this theory, it is possible to construct the set
$X = \{x `| x `; x\}$ whose definition is circular. Clearly, if $X `: X$
then $X `; X$ and if $X `; X$ then $X `: X$, hence we have an
inconsistency. \Russell{} was one of the pioneers of type theory when he
devised a set theory with a restricted comprehension axiom that
permitted to create subsets only from already defined subsets,
forbidding the definition of $X$ \cite{whitehead.russell:principia}. 

The subset equivalence idea is to identify elements of subsets if
they are built from the same underlying set. That is, we can identify
elements of $`N$ with elements of any subset $\{ x `: `N `| P \}$.
However, we should not be able to draw conclusions based on the
properties attached to an element of a subset. Otherwise it would be
possible to claim that $0 `: \{ x `: `N `| x \neq 0 \}$ but also that $0
\neq 0$ which would lead us to inconsistency. 

Informally, this idea is already present in mathematics. When you have a
subset $\{ x `: S `| P \}$, you can freely forget about the property $P$
and use any operation which is defined on $S$. Conversely, when you
want to use an operation defined on a subset, you usually prove \emph{first}
that you apply it only to elements having the desired property. 
In the context of formal development of programs, such a workflow is not
entirely satisfactory because it forces one to create objects and prove
properties about them \emph{at the same time}. We would like for example
to prove that our usage of partial functions is correct only after the
program is written. Subsets are particularly well-suited in this respect
because they separate the objects we want to manipulate and the
properties which we use to reason about them.

\subsection{From \ps{} to subset equivalence}
The \ps{} mechanism \cite{Rushby98:TSE,Shankar&Owre:WADT99}
is an extension of the \PVS type system which internalizes this idea.
Concretely, this means that the following rules are derivable in \PVS:
\begin{center}
  \AXC{$`G \vdash t : \{ x : T `| P[x] \}$}
  \UIC{$`G \vdash t : T$}
  \DP
  \AXC{$`G \vdash t : T$}
  \AXC{$`G \vdash P[t]$}
  \BIC{$`G \vdash t : \{ x : T `| P[x] \}$}
  \DP
\end{center}

The first one formalizes the fact that an object of a subset based on
$T$ is an object of type $T$. The second one permits using an object of
type $T$ as an object of type $\{ x : T `| P[x] \}$, but it generates a
\emph{type checking condition} $`G \vdash P[t]$ which will need to be
discharged later. Effectively, the typing algorithm of \PVS{} collects
the conditions that must be satisfied for the term to be accepted as a
valid definition. However, the acceptance criteria is rather vague in
\PVS{}. By design, when proving in \PVS{}, the trusted code base (TCB
hereafter) is the entire system, not only the typing system but also the
various decision procedures and tactics used to build proofs
automatically or interactively. It is nonetheless a widely used proof
assistant and the predicate subtyping feature has apparently helped to
build a consequent library of certified code. On the other hand, \Coq
has a small TCB and greater expressiveness but less automation and
methodology to build certified programs. We capitalize on the \PVS
success to make \Coq more usable for this kind of tasks, and as we will see,
it will have other benefits.

\subsection{Typing and conversion}
Our presentation of \ps{} differs slightly from the original one
essentially because of the proof terms, but we have also extended it in some ways. 

\subsubsection{Type system}
\begin{figure}[t]
  \begin{center}
    \def\infvspace{0.1in}
    \def\seq{\typed}
    \def\fCenter{\wf}
    
    \WfEmpty\DP\WfVar\DP

    \def\fCenter{\typed}
    \vspace{\infvspace}

    \Var\DP\PropSet\DP
    
    \vspace{\infvspace}
    \Subsum\DP
       
    \vspace{\infvspace}
    \Prod\DP
    
    \vspace{\infvspace}
    \Abs\DP

    \vspace{\infvspace}
    \App\DP

    \vspace{\infvspace}
    \SigmaR\DP
    
    \vspace{\infvspace}
    \SumDep\DP

    \vspace{\infvspace}
    \PiLeft\DP
    \quad
    \PiRight\DP

    \vspace{\infvspace}
    \SubsetR\DP
  \end{center}
  \vspace{-2em}
  \caption{\Russell{} typing}
  \label{fig:typing-decl-rules}
  \vspace{-1em}
\end{figure}
%
\Russell{}'s type system (figure \vref{fig:typing-decl-rules}) is based
on the Calculus of Constructions \cite{coquandhuet88,Barras99}, with sigma types but without universes.
This restriction may be removed in future work, but cause no problem for
our main purpose which is programming. The judgement $`G \typed t : T$
means $t$ is a well-typed term of type $T$ in environment $`G$, and $`G
\typed T \subd U$ means $T$ is equivalent to $U$ in environment $`G$. 
Following the presentation as a pure type system \cite{barendregt91}, 
the set of sorts $\PTSsorts$ is defined as $\setproptype$. As usual, we
let $s, s_i$ for $i `: `N$ range over sorts. The
axioms are $\PTSaxioms = \{ (\Set, \Type), (\Prop, \Type) \}$ and the
set of rules $\PTSrules$ is defined by the following (functional) relation:
% \begin{table}[h]
%   \vspace{-1.5em}
  \axiomsd
%   \vspace{-1em}
%   \caption{Definition of $\PTSrules$}
%   \label{fig:PTSrules}
% \end{table}

We allow to form dependent sums $\Sigma x : U.V$ (\irule{Sigma}, \irule{Sum-Dep},
\irule{Pi-1}, \irule{Pi-2} rules) only when $U, V : \Set$
or $U, V : \Prop$. The first sum represents dependent pairs, useful
when defining functions returning a tuple, the latter represent
dependent pairs of propositions, which is rarely used. The dependent
pair with $U : \Set$ and $V : \Prop$ is the subset type which we
distinguish (rule \irule{Subset}). The last possible pair $U : \Prop, V : \Set$ is forbidden
because it corresponds to a pair where the last component, which is
informative, may depend on a particular proof of the proposition
$U$. This is quite contrary to the mantra ``Computations do not depend
on proofs'' which governs our programming language.

Likewise, we need to restrict the system so that it becomes property irrelevant for
the propositions appearing in subset types. Indeed, in \PVS{} you can't
manipulate proof terms, so you have
no way to create a term of type $0 \neq 0$ from the judgment $0 :
\mysubset{x}{`N}{P}$, but in a classical Calculus of Constructions with
sigma types or inductive types, the subset type is a first class object
defined with proper introduction and
elimination terms (figure \vref{fig:cci-subset}). What we need to do is forbid the use of these terms
in \Russell{} terms, leaving only the type former.

\begin{figure}
  \begin{center}
    \def\type{\typed}
    \AXC{$`G \type A : \Set$}
    \AXC{$`G, x : A \type P : \Prop$}
    \BIC{$`G \type \mysubset{x}{A}{P} : \Set$}
    \DP
    
    \vspace{\infvspace}
    
    \AXC{$`G \type a : A$}
    \AXC{$`G \type p : P[a/x]$}
    \AXC{$`G \type \mysubset{x}{A}{P} : \Set$}
    \TIC{$`G \type \elt{A}{(\lambda x : A.P)}{a}{p} : \mysubset{x}{A}{P}$}
    \DP
    \vspace{\infvspace}

    \AXC{$`G \type t : \mysubset{x}{A}{P}$}
    \UIC{$`G \type \eltpit~t : A$}
    \DP
    \vspace{\infvspace}

    \AXC{$`G \type t : \mysubset{x}{A}{P}$}
    \UIC{$`G \type \eltpip~t : P[\eltpit~t/x]$}
    \DP
  \end{center}
  \vspace{-1em}
  \caption{Subset type in \CCI}
  \label{fig:cci-subset}
  \vspace{-2.5em}
\end{figure}

We now need to change the conversion rule to a stronger one which will
include our subset equivalence.

\subsubsection{Equivalence}
We have renamed the technique from \ps{} to 
\emph{subset equivalence} because we have a symmetric relation, contrary
to usual subtyping relations. It also conveys the idea that it can
include the usual $\beta\pi$-conversion directly in the judgement.
The judgment $`G \typed T \subd{} U : s$ (figure
\vref{fig:conversion-decl-rules}) reads $T$ is equivalent to $U$ in
environment $`G$, both being sorted by $s$. 

\begin{figure}[h]
  \subtdRules
  \caption{\Russell{} conversion}
  \label{fig:conversion-decl-rules}
\end{figure}

The rule \irule{SubConv} integrates $\beta\pi$-conversion in the
judgment. We use a judgemental equality here, which will be refined by
the usual conversion relation later. The \irule{SubSym} and
\irule{SubTrans} rules ensure that our judgement constructs an \emph{equivalence} and has
proper modularity. The next two rules (\irule{SubProd} and
\irule{SubSigma}) do context closure for dependent
products and sums. It is remarkable that we use contravariance
\cite{journals/toplas/Castagna95} for
domains in the \irule{SubProd} rule, not restricting to invariance as in
\PVS. It is accessory here, as we could have used \emph{co}variance and
still get the same judgements because we have symetry. However, it will
become important when we create coercions (see
\vref{fig:coerce-impl-rules-short}).

The really interesting rules are \irule{SubSub} and
\irule{SubProof}. The first one allows to use an object of a subset type
as an object of its support type. The later allows (maybe abusively) to
consider an object of any type as an object of any subset based on
this type. We must check that the property $P$ is well-formed, but
we do not care about its provability.

\subsubsection{Properties}
We have proved the metatheory for this system in \Coq{}
\cite{sozeau:coq/Russell/meta}. We have assumed that it is strongly
normalizing (SN) but we have proved subject reduction (SR) for it: 
if $`G \typed t : T$ and $t "->"_{\beta\pi} t'$ then $`G \typed t' :
T$. Gang Chen \cite{ChenPhD} has studied various type systems from the
$\lambda$-cube extended by subtyping or coercive subtyping
\cite{DBLP:conf/csl/Luo96}, including the Calculus of Constructions, and
proved such results as SN and SR for them. It requires a very careful
analysis of the system to avoid cycles in the proof due to the presence
of dependent types and conversion. However we prefered to adapt the method of
Robin Adams \cite{adams:PTSEQ} to prove SR, because Gang Chen's method
seemed very tied to the peculiarities of the system he studied. 
Strong normalization could also be proved, perhaps more easily,
using the generic proof method developed in \cite{geuvers95}, by finding
a proper interpretation of \Russell terms into the Calculus of
Constructions.

So, apart from strong normalization, we have shown all the usual structural
and metatheoretic properties of a dependent programming language, like
weakening, thinning and substitution, stability by context coercion etc\ldots
We stop here on the subject of theoretical properties of this first system, as
it gives no new insights for our purpose and we will focus more on the
algorithmic system's properties. Besides, the details of the
formalization and the proof fall outside the scope of this paper.
% The essential properties of the $\subd$ judgement are 
% its reflexivity: if $`G \typed A : s$, then $`G \typed A \subd A$,
% symetry: if $`G \typed A, B : s$ then $`G \typed A \subd B "<=>" `G \typed
% B \subd A$ and transitivity by \irule{SubTrans}.

% As typing and equivalence are mutually recursive, we will generaly prove
% properties by mutual induction on the two derivations.

% \begin{lemma}[Weakening]
%   Suppose $\wf{`G, x : S, `D}$.
%   If $`G, `D \typed t : T$ then $`G, x : S, `D \typed t : T$. 
%   If $`G, `D \typed T \sub U : s$ then $`G, x : S, `D \typed T \sub U : s$.
% \end{lemma}
% \begin{proof}
%   Straightforward mutual induction.
% \end{proof}

% Similarly for thining and substitution. An important property for
% dependent type systems is to have invariance of judgments which are
% definitionaly equal (here equivalent). Hence the following lemma:
% \begin{lemma}
%   Suppose $`G \typed U \sub V : s$.
%   If $`G, x : V, `D \typed t : T$ then $`G, x : U, `D \typed t : T$.
%   If $`G, x : V, `D \typed S \sub T : s'$ then
%   $`G, x : U, `D \typed S \sub T : s'$.
% \end{lemma}
% \begin{proof}
%   By mutual induction on the typing and equivalence derivations.
% \end{proof}

\subsubsection{Algorithmic typing}

\begin{paragraph}{}
We use a standard transformation to get an algorithm from our typing
rules, integrating the conversion (or subsumption) rule
(here \irule{Coerce}) to the premises of the other rules.
%We recall that $`G \type t : s$ is shorthand for $`G \type t : T$ and
%$T  `= s$ with $s `: \PTSsorts$ in a algorithmic presentation.
\TODO{App?, SumDep?, Pi?}. Our algorithmic judgement $`G \typea t : T$
(figure \vref{fig:typing-algo-rules})
reads: $t$ is a well-typed term of type $T$ in environment $`G$.
We need to introduce the notion of support for subset types in order to
define our algorithmic system. Indeed, when typing an application, 
we need to ensure that the object we apply can be seen as an object of a
product type modulo the equivalence. This notion is presented in \PVS{} by
means of a $\mu_0$ operator which was readily adaptable in our setting
(figure \vref{fig:mualgo-definition}). In Gang Chen's work, the notion is formalized by a
new judgement $\Pi_{lub}$ which is essentialy equivalent to the operator
$\mualgo$, except ours finds $\Sigma_{lub}$s too.
\begin{figure*}[t]
  \def\infvspace{0.5em}
    \def\type{\typea}
    \def\subt{\subta}
    \def\sub{\suba}
    \def\fCenter{\typea}
    \begin{center}
%     \WfEmpty\DP
    
%     \vspace{\infvspace}
%     \WfVar\DP
    
%     \vspace{\infvspace}
%     \Var\DP
    
%     \vspace{\infvspace}
%     \PropSet\DP
    
%     \vspace{\infvspace}
%     \Prod\DP

%     \vspace{\infvspace}
%     \Abs\DP

    \vspace{\infvspace}
    \AppA\DP

%     \vspace{\infvspace}
%     \SigmaR\DP
    
    \vspace{\infvspace}
    \SumDepA\DP

    \vspace{\infvspace}
    \PiLeftA\DP
    
    \vspace{\infvspace}
    \PiRightA\DP

%     \vspace{\infvspace}
%     \SubsetR\DP
  \end{center}
  \vspace{-2em}
  \caption{\Russell{} algorithmic typing, new rules}
  \label{fig:typing-algo-rules}
%  \vspace{-1em}
\end{figure*}

\typemuaFig[$\mualgo$ definition]

\begin{figure*}
    \def\fCenter{\suba}
    \def\type{\typea}
    \def\sub{\suba}
    \begin{center}
    \SubConvA\DP 

    \vspace{\infvspace}
    \SubHnfA\DP

    \vspace{\infvspace}
    \SubProdA\DP

    \vspace{\infvspace}
    \SubSigmaA\DP

    \vspace{\infvspace}
    \SubProofA\DP

    \vspace{\infvspace}
    \SubSubAs\DP
  \end{center}
  \vspace{-2em}
  \caption{\Russell{} algorithmic equivalence}
  \label{fig:subtyping-algo-rules}
  \vspace{-1em}
\end{figure*}


\end{paragraph}
\begin{paragraph}{}
  The next thing to do is to construct a decidable judgement for
  equivalence given two types. We denote it by $`G \typea T
  \suba U : s$ (figure \vref{fig:subtyping-algo-rules}).
  In our case, we have to check that conversion is decidable, which is the
  case. We also need to eliminate the transitivity rule which is not
  syntax-directed. That is the purpose of the following theorem:
\begin{theorem}[Admissibility of transitivity]
  If $`G \typea T \suba U : s$ and $`G \typea U \suba V : s$, then $`G \typea T
  \suba V : s$.
\end{theorem}
\begin{proof}
  By induction on the sum of the depths of the two derivations.
  \TODO{example?}
\end{proof}
\end{paragraph}

Classicaly, we have the following correspondence between the two
systems:
\begin{theorem}[Soundness]
  If $`G \typea t : T$ then $`G \typed t : T$.
  If $`G \typea T \suba{} U : s$ then $`G \typed T \subd U : s$.
\end{theorem}

\begin{theorem}[Completeness]
  If $`G \typed t : T$ then $`G \typea t : T' \suba T$.
  If $`G \typed T \subd U : s$ then $`G \typea T \suba U : s$.
\end{theorem}

Finaly, we can state the desired property of the algorithmic system:
\begin{theorem}[Decidability of typing and equivalence]
  $`A `G~t, `E T, `G \typea t : T$ and $`A `G~T~U~s, `G \typea T \suba U :
  s$ are decidable problems.
\end{theorem}

\subsection{From \CC to \lng{}}
We have presented a calculus based on \CC with a stronger equivalence
but with restricted typing rules. We will now see how they relate
formally.
We can build a forgetful map from terms of \CCI to \Russell
(interpreting inductives as constants). It bears
relation to the $`e$ extraction function defined in
\cite{Werner:ProofIrrelevance}. Essentially, \Russell{} terms do not
contain or manipulate logical information attached to objects of subset
types, hence we must forget about it when translating.

We define the forgetful map $()^{\circ}$ as an homomorphism on terms
except for the following cases:
\begin{center}
  \CCtoRussellforgetFig
\end{center}

We can now prove the following:
\begin{theorem}[Forgetful map correctness]
  If $`G \typec t : T$ then $`G^{\circ} \typea t^{\circ} : T^{\circ}$ if $()^{\circ}$ is
  defined (ie, does not return $`_$) on $`G, t$ and $T$.
\end{theorem}

Practically, this means we can use almost all existing definitions in the
\Coq environment. Obviously, this map is involutive and
the identity on \Russell terms. 
%, potentially turning them (locally) to an opaque form
% if their body is not traductible
\section{From \lng{} to \CCq{}}
We will now build an interpretation
$\ip{t}{`G}$ of \Russell terms $t$ in environment $`G$ into \CCI
terms. We will check at the end that it respects the $()^{\circ}$ operator
in the sense that if $t$ is well-typed in $`G$ then $\ip{t}{`G}^{\circ} = t$.

Our interpretation will build a full-fledged \CCI term from its
algorithmic skeleton and a rich type written in \Russell. Obviously, we
cannot infer proof terms where they are needed in \CCI, but we can build
a \emph{partial} term, leaving typed holes where proofs are
needed. Hence we add a rule to build existential variables (or
metavariables) in the target calculus ($\typeq$ denotes the new system's typing judgement):
\begin{prooftree}
  \UAX{}
  {$`G \typeq P : \Prop$}
  {$`G \typeq ?_{P} : P$}
  {}
\end{prooftree}

We restrict it to objects of type $\Prop$ because we consider that the
informative part of the algorithm has been entirely given in the
original term. 

Now we can build a total interpretation:
\begin{proposition}[Interpretation correctness]
  If $`G \typea t : T$ then $\ipG{`G} \typeq \ip{t}{`G} : \ip{T}{`G}$.
\end{proposition}

The proof of this proposition is the main technical contribution of this
paper. It also represented the main difficulty in our work. 
The remainder of this section is organized as follows: first we will
define the explicit coercion derivation algorithm which will permit to
put proof obligations in the terms, then we will define the
interpretation of terms which is mutually recursive with the precedent
algorithm. Finally we will present a proof sketch of the aforementionned
proposition.

\subsection{Explicit coercions}
The derivation of explicit coercions (figure
\vref{fig:coerce-impl-rules-short}) is based on the
algorithmic equivalence derivations, hence we can derive a function from
the judgement which build a coercion given two types. 
The side-conditions of the rules have not changed, so we omit them for
improved readability.

\subtis[Coercion derivation]

Coercions are formalized as multi-holes evaluation contexts, with
$\ctxdot$ the denotation of a hole. We define the instanciation $C[x]$ of a context $C$
by a term $x$ as simultaneous substitution of $x$ for every $\ctxdot$ in $C$.
Hence if $C$ is an evaluation context and $x$ a term, $C[x]$ is a term
(ie, it cannot contain $\ctxdot$).
The holes will denote the object to which the coercion is applied. Other
presentations are possible, notably the ``\LMS{}'' style of \cite{longo95logic} which
was adopted by Gang Chen in his treatment of coercive subtyping for the
Calculus of Constructions \cite{conf/popl/Chen03}, and the presentation 
of Amokrane Sa\"ibi \cite{saibi97inheritance}. The \LMS{} style consists
in defining a judgement $x : A \type y : B$ which reads: $A$ is
coercible to $B$ and the coercion is $\lambda x : A.y$. This
presentation is very elegant and well suited for checking coherence and
of the coercion judgement, which we don't need here as we can get unicity
of coercions. Moreover, it did not seem readily usable in
our setting, where coercions may contain metavariables. Similarly, Amokrane Sa\"ibi defines
a coercion derivation algorithm which respect some coherence criteria,
roughly, that type-erased coercions $\beta\eta$-reduce to the
identity. Again, this wasn't adapted to our setting, so we invented this
new presentation. 

We suppose that conversion is preserved by the interpretation $\ip{}{}$, so
the rule \irule{SubConv} derives an empty coercion, as the target system
will be able to derive itself that $\ip{T}{`G} `= \ip{U}{`G}$.
Similarly for \irule{SubHnf}, we rely on the target's system conversion
rule so that the coercion $c$ of codomain $\ip{\hnf{U}}{`G}$ can be seen
as an object of type $\ip{U}{`G}$.

Next, we have the rules for products and sums, which compose
coercions. In the \irule{SubProd} rule, we first coerce the argument to
an object of type $\ip{T}{`G}$. Then we apply it to the coerced
function, resulting in an object $\ctxdot~(c_1[x])$ of type
$\ip{V}{`G, x : T}[c_1[x]/x]$. We'll see later that this type is equivalent to
$\ip{V}{`G, x : U}$, so we can apply the second coercion and get an
object of type $\ip{W}{`G}$. There is a little twist when coercing the
second component of a dependent sum. Indeed, we must simultaneously
substitute the first projection of the coerced sum in the second
coercion which was typed in environment $`G, x : T$ and also instanciate
the coercion with the second component. Clearly, the $\ctxdot$ of the
former shouldn't be instanciated with the later, so we must first
instanciate $c_2$ and then substitute $\pi_1~\ctxdot$ for $x$, knowing
the $x$ can't appear in $\pi_2~t$ where $t : \Sigma x : T.V$.

Now for the original part, the \irule{SubSub} rule simply inserts a
projection before applying the inductively defined coercion on the
support of the subset. On the other hand, \irule{SubProof} creates an
object of a subset using its sole constructor \sref{elt}. The object
part is given by the coercion to the support of the target subset
while the proof part is promised using a metavariable of type $\ip{P}{`G, x : U}[c/x]$ which
we will turn later into a proof obligation. 

\subsection{Interpretation of terms}
The interpretation of terms from \Russell to \CCq (figure
\vref{fig:interp}) is a straightforward
recursive traversal of algorithmic typing derivations. In other, more
practical words, we can do interpretation of terms simultaneously with
typing in our implementation, just like for the existing coercion system
of \Coq. 

\interpfig[Interpretion of terms]

We describe the case of application here, others are similar. First we
get the types $F$ and $U$ of the function $f$ and argument $u$ by recursively calling the
typing function on both terms. Then we must ensure that $F$ can indeed
be seen as a product using the $\mualgo$ operator. We can then build
the coercion between $F$ and this product, and between $U$ and its
domain. We finally instantiate these coercions by their corresponding
interpreted objects and return their application.

\subsection{A little more expressiveness}
One may wonder how can we interpret \Russell terms to a system with only
$\beta\pi$-equivalence. 
Indeed, if our algorithmic system has transitivity and symetry of
coercions, we expect that the derived coercions will inherit these
properties, for example:
\begin{proposition}[Symetry of coercions]
  If $\subimpl{`G}{c}{T}{U}{s}$ then there exists $c^{-1}$ so that
  $\subimpl{`G}{c^{-1}}{U}{T}{s}$ and $c `o c^{-1} `= c^{-1} `o c `=
  \ctxdot$.
\end{proposition}

Now take the following example:
\begin{example}[Symetry for products]
  Let $T, U = \Pi x : A.B$. The coercions $c, c^{-1}$ derived by
  the algorithm must have the form $\lambda x :
  \ip{A}{`G}.c_2[\ctxdot~c_1[x]]$, hence we must include the $\eta$
  rule in order to have $c `o c^{-1} `= \ctxdot$.
\end{example}

Similarly, we must add $\eta$ rules for all introduction terms of our
language if we want to be conservative (the coercion algorithm will
always derive $\eta$-long normal forms, so we must be able to prove that they
are equivalent to the empty coercion) and have unicity of
coercions. The later is an important property of our system, as it
corresponds in practice to the determinism of proof-obligations
generation. The complete equational theory of \CCq{} is given in figure
\vref{fig:eqccq}. It includes $\eta$, surjective pairing for dependent
sums and subsets ($\rho$) and proof-irrelevance for the second component
of subset objects.
Benjamin Werner has studied the addition of proof-irrelevance (rule
$\sigma$) in the calculus of constructions
\cite{Werner:ProofIrrelevance}. It is not a trivial extension and it has
far-reaching consequences on the model of the calculus
\cite{DBLP:conf/types/MiquelW02}. We direct the reader to these papers for further
information on the subject.

\ccqeqfig[Equational theory of \CCq]

\subsection{Properties}
The correctness proof of the traduction is very involved, so we will
only sketch it here. A paper version \vref{sozeau:coq/Russell/report} is
available (in french) and a mechanically checked proof is in the works.


We first prove reflexivity, symmetry and transitivity of the coercion
derivation algorithm, which extends previous proofs for the algorithmic
system with properties on
the generated coercions. Then we show substitutivity of the
interpretation: if $`G, x : U, `D \type t : T$ then $\ip{t[u/x]}{`G,
 `D[u/x]} = \ip{t}{`G, x : U, `D}[\ip{u}{`G}/x]$. We extend the notion
of coercion to contexts next and show stability of judgements under
context coercion. It is then possible to prove a lemma about commutativity of
subtitution with the interpretation and coercions. Then we get an
important corrolary: if $`G \type u : U$, $\subimpl{`G}{c}{U}{V}{s}$ and
$`G, x : V \type T : s$ then $\ip{T[u/x]}{`G} `= \ip{T}{`G, x :
  V}[c[\ip{u}{`G}]/x]$. Essentially, it shows that coercions inserted
by the interpretation depend only on the context and hence could be
added later using substitution instead. This allows us to show that
equivalence is conserved by interpretation and finaly that our
interpretation is correct.

\section{Conclusion}
We have developed a new language for writing programs in the \Coq proof
assistant which allows the user to specify complex programs while
keeping the corresponding code simple. It is a first step towards
interpretation of \ML code into \Coq for building certified
programs. While the system and its accompanying proofs may seem complex, the
implementation is short, simple and has been tested with success on
various examples. This works is also a second proof of the
meaningfullness of the Predicate Subtyping feature of \PVS{} and may
help build a common interface for the two provers. 

\subsection{Related work}
Other efforts to build certified programs using type theory include
Cayenne \cite{Augustsson99} and Epigram
\cite{DBLP:journals/jfp/McBrideM04}. Cayenne offers dependent
types and general recursion at the expense of a non-terminating type
checker, it can be sought of as a testbed for developing languages with
dependent types but is not so much aimed at building certified programs.
Epigram ought to become a complete programming language with dependent
types at its heart. Instead of using a phase distinction to separate
coding and proving, Epigram is based on an interactive, 2-dimensional editing process
where code and proofs are written incrementaly to get a complete program.
Using type annotations and with the help of the editor for structuring, 
they are able to write programs with precise specifications. However it
is not obvious if it could be made usable by programmers because of the
paradigm change and scalling issues. 

\subsection{Further work}
Much has to be done for integrating \Russell cleanly into \Coq. The
treatment of existential variables of \Coq has to be improved, the
type inference algorithm needs some tuning to become more similar to \ML
and an implementation of proof-irrelevance, while rarely needed in
practice, is necessary to have a robust system.
We also hope to extend this mechanism of proof-obligations generation to other
constructs, notably inductive types. Finally, we intend to use this system as a
basis for interpretation of \ML{} programs in \Coq, using a monadic
traduction or some kind of effects as first class objects.

\bibliography{bib-joehurd,barras,pvs-bib,bcp,Luo,biblio-subset,%
cparent,demons,demons2,demons3}
\bibliographystyle{splncs}

\renewcommand{\thefootnote}{}
\footnotetext{This article was typeset in \LaTeX~using the
  \texttt{Concrete Math} font}
\end{document}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% LaTeX-command: "BIBINPUTS=\"${HOME}/research/demons-biblio:../bib:$BIBINPUTS\" TEXINPUTS=\"..:../style:$TEXINPUTS\" latex"
%%% End: 
