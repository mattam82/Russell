\documentclass[twocolumn]{article}
\usepackage{abbrevs}
\usepackage{array}
%\usepackage{
\usepackage{amsmath}
\usepackage{amsthm}

%\usepackage{qzapfcha}
%\usepackage{cmbright}
\usepackage{concmath}
\usepackage{ifthen}
\usepackage{varioref}

\newboolean{defineTheoremFr}
\newboolean{defineTheoremEn}
\setboolean{defineTheoremFr}{false}
\setboolean{defineTheoremEn}{true}
\input{mathenv}

\usepackage{bussproofs}
% Optional to turn on the short abbreviations
\EnableBpAbbreviations

\input{typing-macros}
\input{typing-decl}
\input{subtyping-decl}

\input{typing-algo}

\usepackage{framed}
%\usepackage{multicol}

\author{Matthieu Sozeau \\
  LRI, Paris Sud XI University \\
  sozeau@lri.fr}
\title{Subset coercions in \Coq}
\date{\today}

\begin{document}
\maketitle

\abstract{We set out to establish a phase distinction between writing and
  proving algorithms in the \Coq{} environment. Concretely, this means
  allowing to write algorithms as easily as in a pratical functionnal 
  programming language
  whilst giving them as rich a specification as desired and proving that
  the code meets the specification using the whole \Coq{} proof
  apparatus. This is achieved by extending conversion to an equivalence 
  which relates types
  and subsets based on them, a technique  
  originating from the ``\emph{Predicate subtyping}'' feature of \PVS{} and
  following mathematical convention. The typing judgments can be
  translated to the \CICfull (\CIC{}) by means of an interpretation which inserts
  coercions at the appropriate places. These coercions can contain
  existential variables representing the propositional parts of the final
  term. A prototype implementation of this process
  has been implemented.}

\section{Introduction}
There are many means to program in the \Coq{} environment. One
can write programs as in \ML{} and prove properties about them
separately, loosing the possibility of using dependent types in
specifications, or give a rich type expressing them as a goal and use the
proof tactics to solve it, producing a corresponding program by the
\CurryHoward isomorphism but having much less control on its algorithmic
essence. It is however difficult to mix the two methods
(writing code and prove interactively) using a rich specification. We
propose a solution to overcome this difficulty, based on the \ps{}
\cite{Shankar&Owre:WADT99} technique of \PVS{}
\cite{PVS:Language,PVS:Semantics-TR}. This solution also provides
facilities to express properties with a syntaxicaly more mathematical flavor,
bridging the gap between mathematical convention and type theory.

The \Program{} tactic by C. Parent \cite{conf/mpc/Parent95} had the same
goal as ours but a slightly different method for achieving it. It was strongly
linked to the extraction mechanism included in \Coq, both theoreticaly
and practically. Sketching the mechanism, they defined a weakened
extraction operation on \CIC{} terms which could be inverted because it left enough
information in the extracted term to rebuild a partial proof. The
mechanism, while general and theoreticaly well thought out, required
some heuristics and did not integrate smoothly with the \Coq{}
environment. In particular it lacked the pervasivness our method has,
being applicable in a wide variety of situations in the proof assistant
environment.

Instead of trying to find a general method for synthetising proofs from
programs in the \CICfull, we have integrated a method which permits to
link strong specifications and purely algorithmical code. This method,
known as \ps{} in the \PVS{} system has been used with great success and
fits naturally with how we write specifications. The main contribution
of this paper is to show how the \ps{} method can be adapted in a proof
assistant with proof terms, which formally justifies the extension in
the first place.

The rest of the article is organized as follows: first we present a
type system based on \ECC{}, which integrates subset ``subtyping'', and
we show how it relates to \CIC{} by means of traductions between
judgements of the two systems. Then, we present a prototype
implementation with some case studies, and finally we give our
conclusions on this work and discuss future directions.

\section{\Russell{}}
The name of our language is an homage to the mathematician ? Russell who
discovered the famous paradox of set theory with the unrestricted
comprehension axiom. In this theory, it is possible to construct the set
$X = \{x `| x `; x\}$ whose definition is circular. Clearly, if $X `: X$
then $X `; X$ and if $X `; X$ then $X `: X$, hence we have an
inconsistency. \Russell{} was one of the pioneers of type theory when he
devised a set theory with a restricted comprehension axiom that
permitted to create subsets only from already defined subsets,
forbidding the definition of $X$. 

The subset equivalence idea is to identify elements of subsets if
they are built from the same underlying set. That is, we can identify
elements of $`N$ with elements of any subset $\{ x `: `N `| P \}$.
However, we should not be able to draw conclusions based on the
properties attached to an element of a subset. Otherwise it would be
possible to claim that $0 `: \{ x `: `N `| x \neq 0 \}$ but also that $0
\neq 0$ which would lead us to inconsistency. 

Informally, this idea is already present in mathematics. When you have a
subset $\{ x `: S `| P \}$, you can freely forget about the property $P$
and use any operation which is defined on $S$. Conversely, when you
want to use an operation defined on a subset, you usually prove \emph{first}
that you apply it only to elements having the desired property. 
In the context of formal development of programs, such a workflow is not
entirely satisfactory because it forces one to create objects and prove
properties about them \emph{at the same time}. We would like for example
to prove that our usage of partial functions is correct only after the
program is wrote. Subsets are particularly well-suited in this respect
because they separate the objects we want to manipulate and the
properties which we use to reason about them.

\subsection{From \ps{} to subset equivalence}
The \ps{} mechanism \cite{Rushby98:TSE, Shankar&Owre:WADT99}
is an extension of the \PVS type system which internalizes this idea.
Concretely, this means that the following rules are derivable in \PVS:
\begin{figure}[h]
  \begin{center}
    \AXC{$`G \vdash t : \{ x : T `| P[x] \}$}
    \UIC{$`G \vdash t : T$}
    \DP
    \AXC{$`G \vdash t : T$}
    \AXC{$`G \vdash P[t]$}
    \BIC{$`G \vdash t : \{ x : T `| P[x] \}$}
    \DP
  \end{center}
  \vspace{-1em}
  \label{PVS:rules}
  \caption{\PVS}
\end{figure}

The first one formalizes the fact that an object of a subset based on
$T$ is an object of type $T$. The second one permits using an object of
type $T$ as an object of type $\{ x : T `| P[x] \}$, but it generates a
\emph{type checking condition} $`G \vdash P[t]$ which will need to be
discharged later. Effectively, the typing algorithm of \PVS{} collects
the conditions that must be satisfied for the term to be accepted as a
valid definition. However, the acceptance criteria is rather vague in
\PVS{}. By design, when proving in \PVS{}, the trusted code base (TCB
hereafter) is the entire system, not only the typing system but also the
various decision procedures and tactics used to build proofs
automatically or interactively. It is nonetheless a widely used proof
assistant and the predicate subtyping feature has apparently helped to
build a consequent library of certified code. On the other hand, \Coq
has a small TCB and greater expressiveness but less automation and
methodology to build certified programs. We capitalize on the \PVS
success to make \Coq more usable for this kind of tasks, and as we will see,
it will have other benefits.

\subsection{Typing and conversion}
Our adaptation of \ps{} differs from the presentation of
\ps{} in \cite{Rushby98:TSE, Shankar&Owre:WADT99} essentially because of the
proof terms, but we have also extended it in some ways. 

\subsubsection{The typing judgment}
\Russell{}'s typing system (figure \vref{fig:typing-decl-rules}) is based
on the \CCfull \cite{Barras99,Luo90}, with sigma types but without universes.
This restriction may be removed in future work, but cause no problem for
our main purpose which is programming. The judgement $`G \typed t : T$
means $t$ is a well-typed term of type $T$ in environment $`G$, and $`G
\typed T \subd U$ means $T$ is convertible to $U$ in environment $`G$.
Following the presentation as a pure type system \cite{PTS}, 
the set of sorts $\PTSsorts$ is defined as $\setproptype$, the
axioms are $\PTSaxioms = \{ (\Set, \Type), (\Prop, \Type) \}$ and the
rules $\PTSrules$ are defined by the following (functional) relation:
\axiomsd

We allow to form dependent sums $\Sigma x : U.V$ (\irule{Sigma}, \irule{Sum-Dep},
\irule{Pi-1}, \irule{Pi-2} rules) only when $U, V : \Set$
or $U, V : \Prop$. The first sum represents dependent pairs, useful
when defining functions returning a tuple, the latter represent
dependent pairs of propositions, which is rarely used. The dependent
pair with $U : \Set$ and $V : \Prop$ is the subset type which we
distinguish (rule \irule{Subset}). The last possible pair $U : \Prop, V : \Set$ is forbidden
because it corresponds to a pair where the last component, which is
informative, may depend on a particular proof of the proposition
$U$. This is quite contrary to the mantra ``Computations do not depend
on proofs'' which governs our programming language.

Likewise, we need to restrict the system so that it becomes property irrelevant for
the propositions appearing in subset types. Indeed, in \PVS{} you can't
manipulate proof terms, so you have
no way to create a term of type $0 \neq 0$ from the judgment $0 :
\mysubset{x}{`N}{P}$, but in a classical Calculus of Constructions with
sigma types or inductive types, the subset type is a first class object
defined with proper introduction and
elimination terms (figure \vref{fig:subset}). What we need to do is forbid the use of these terms
in \Russell{} terms, leaving only the type former.

Some basic properties of this system are well-formedness of
environments: if $`G \typed t : T$ then $\typedwf `G$ and
well-sortedness: if $`G \typed t : T$ then $T = \Type$ or $`G \typed T :
s$ for $s `: \PTSsorts$.

We now need to change the conversion rule to a stronger one which will
include our subset equivalence.

\begin{figure}
  \begin{center}
    \def\type{\typed}
    \AXC{$`G \type A : \Set$}
    \AXC{$`G, x : A \type P : \Prop$}
    \BIC{$`G \type \mysubset{x}{A}{P} : \Set$}
    \DP
    
    \vspace{\infvspace}

    \AXC{$`G \type a : A$}
    \AXC{$`G \type p : P[a/x]$}
    \BIC{$`G \type \elt{A}{(\lambda x : A.P)}{a}{p} : \mysubset{x}{A}{P}$}
    \DP
    \vspace{\infvspace}

    \AXC{$`G \type t : \mysubset{x}{A}{P}$}
    \UIC{$`G \type \text{proj1\_sig}~t : A$}
    \DP
    \vspace{\infvspace}

    \AXC{$`G \type t : \mysubset{x}{A}{P}$}
    \UIC{$`G \type \text{proj2\_sig}~t : P[\text{proj1\_sig}~t/x]$}
    \DP
  \end{center}
  \caption{Subset type in \CCI}
  \label{fig:subset}
\end{figure}

\begin{figure*}[h]
  \typedRules
  \caption{\Russell{} typing}
  \label{fig:typing-decl-rules}
\end{figure*}


\subsubsection{Equivalence}
We have renamed the technique from \ps{} to 
subset \emph{equivalence} because we have a symmetric relation, contrary
to usual subtyping relations. It also permits to include $\beta$-conversion
directly in the relation. The judgment $`G \typed T \subd{} U$ (figure
\vref{fig:conversion-decl-rules}) reads $T$ is convertible to $U$ in
environment $`G$. In the following, it is always assumed that the two
input types of the conversion are well-sorted, but maybe not by the same sort.

\begin{figure}[h]
  \subtdRules
  \caption{\Russell{} conversion}
  \label{fig:conversion-decl-rules}
\end{figure}

The rule \irule{SubConv} integrates $\beta\pi$-conversion in the
judgment. It is well-known \cite{Luo, Pottinger?} that $\beta\pi$ is
confluent only on well typed terms, so we have to ensure that our rules,
when read from bottom to top, keep well-typedness. That's the purpose of
the $`G \typed U : s$ premise of the \irule{SubTrans} rule. This rules
ensures that our judgement constructs an \emph{equivalence} and has
proper modularity. The next two rules do context closure for dependent
products and sums. It is remarkable that we use contravariance for
domains in the \irule{SubProd} rule, not restricting to invariance as in
\PVS \cite{journals/toplas/Castagna95}. It is accessory here, as we could have used \emph{co}variance and
still get the same judgements because we have symetry. However, it will
become important when we create coercions (see
\vref{fig:subtyping-impl-rules}).

The really interesting rules are \irule{SubSub} and
\irule{SubProof}. The first one allows to use an object of a subset type
as an object of its support type. The latter allows (maybe abusively) to
consider an object of any type as an object of any subset based on
it. By the assumption on the input types of the judgment, we know that $P$
is well-typed, but we do not care about the proof.

\subsubsection{Properties}
\begin{paragraph}{Assumptions}
  We have proved basic metatheoretical results for this system in \Coq{}
  \cite{CCP}. We have assumed that it is strongly normalizing (SN) and has the
  following subject reduction (SR) property: if $`G \typed t : T$ and $t
  "->"_{\beta\pi} t'$ then $`G \typed t' : T$. Strong normalization
  could be proved using the generic proof method developed in
  \cite{Geuvers} but we leave it for future work. Gang Chen
  \cite{GangChen} has studied various type systems from the
  $\lambda$-cube extended by subtyping or coercive subtyping \cite{Luo},
  including the Calculus of Constructions, and proved such results as
  SN and SR for them. It requires a very careful analysis of the system 
  to avoid cycles in the proof due to the presence of dependent types and
  conversion ; hence we also leave it for future work.
\end{paragraph}

We write $`G \typed T, U : s$ for $`G \typed T : s$ and $`G \typed U :
s$.

As all functionnal PTS, \Russell{} has the unicity of sorting property,
hence we can prove:
\begin{lemma}[Well-sortedness of equivalence derivations]
  If $`G \typed T : s_1$, $`G \typed U : s_2$ and $`G \typed T \sub U$
  then $`G \typed T, U : s$ and $s = s_1 = s_2$.
\end{lemma}
\begin{proof}
  We will use the abbreviation $`G \typed T \sub U : s$ for $`G \typed T,
  U : s$ and $`G \typed T \sub U$ in the following.

  By induction on the subtyping derivation:
  \case{SubConv} We have $T \eqbp U$, we apply unicity of sorting.

  \case{SubTrans} We have by induction $`G \typed T \sub S : s$ and 
  $`G \typed S \sub U : s$. Hence we have $`G \typed T, U : s$.

  \caseother{} Other cases are straightforward.
\end{proof}

We will omit $`G$ where unnecessary.
The essential properties of the $\_ \typed \_ \subd \_$ judgment are 
its reflexivity ($\forall A, A \subd A$), symmetry ($\forall A B, A \subd
B "<=>" B \subd A$) and transitivity by \irule{SubTrans}.

As typing and equivalence are mutually recursive, we will generaly prove
properties by mutual induction on the two derivations.
Our system has good structural properties like weakening, thinning and
substitution. 

\begin{lemma}[Weakening]
  Suppose $\typedwf `G, x : S, `D$.
  If $`G, `D \typed t : T$ then $`G, x : S, `D \typed t : T$. 
  If $`G, `D \typed T \sub U : s$ then $`G, x : S, `D \typed T \sub U : s$.
\end{lemma}
\begin{proof}
  Straightforward mutual induction.
\end{proof}

Similarly for thining and substitution. An important property for
dependent type systems is to have invariance of judgments which are
definitionaly equal (here equivalent). Hence the following lemma:
\begin{lemma}
  Suppose $`G \typed U \sub V : s$.
  If $`G, x : V, `D \typed t : T$ then $`G, x : U, `D \typed t : T$.
  If $`G, x : V, `D \typed S \sub T : s'$ then
  $`G, x : U, `D \typed S \sub T : s'$.
\end{lemma}
\begin{proof}
  By mutual induction on the typing and equivalence derivations.
\end{proof}

We stop here about the theoretical properties of this first system, as
it gives no new insights for our purpose and we will focus more on the
algorithmic system's properties.

\subsubsection{Algorithmic typing}
We use a standard transformation to get an algorithm from our typing
rules, basically restricting the conversion (or subsumption) rule
(\irule{Coerce}) to the premises of introduction and elimination rules.
\TODO{App?, SumDep?, Pi?}. Our algorithmic judgement $`G \typea t : T$
reads: $t$ is a well-typed term of type $T$ in environment $`G$.
We need to introduce the notion of support for subset types in order to
define our algorithmic system. Indeed, when typing an application, 
we need to ensure that the object we apply can be seen as an object of a
product type modulo the equivalence. This notion is presented in \PVS{} by
means of a $\mu_0$ operator which was readily adaptable in our setting
\ref{fig:mualgo}. In Gang Chen's work, the notion is formalized by a
new judgement $\Pi_{lub}$ which is essentialy equivalent to the operator.

The next thing to do is to construct a decidable judgement for
equivalence given two well-sorted types. We denote it by $`G \typea T
\suba U$ (figure \ref{fig:subta-rules}).
In our case, we have to check that conversion is decidable, which is the
case. We also need to eliminate the transitivity rule which is not
syntax-directed. That is the purpose of the following theorem:
\begin{theorem}[Elimination of transitivity]
  If $`G \typea T \suba U$ and $`G \typea U \suba V$, then $`G \typea T
  \suba V$.
\end{theorem}
\begin{proof}
  By lexicographic induction on the pair of derivations.
  \TODO{example}
\end{proof}

Classicaly, we have the following correspondence between the two
systems:
\begin{theorem}[Soundness]
  If $`G \typea t : T$ then $`G \typed t : T$.
  If $`G \typea T \suba U$ then $`G \typed T \subd U$.
\end{theorem}

\begin{theorem}[Completeness]
  If $`G \typed t : T$ then $`G \typea t : T' \suba T$.
  If $`G \typed T \subd U$ then $`G \typea T \suba U$.
\end{theorem}

Here is the desired property of the algorithmic system:
\begin{theorem}[Decidability of typing and equivalence]
  $`E T, `G \typea t : T$ and $`G \typea T \suba U$ are decidable
  problems.
\end{theorem}

\subsection{From \CCq to \lng{}}
- Present \CCq
- Forgetful map

\section{From \lng{} to \CCq{}}
mutually recursive...

\subsection{Explicit coercions}
... derivation algo.

\subsection{Terms}
- Follows algo typing derivation. Done at the same time as typing in the
impl.

\subsection{Properties}
- Proofs.

\section{Conclusion}
\subsection{Related work}

\subsection{Further work}

\end{document}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% LaTeX-command: "TEXINPUTS=\"..:../style:$TEXINPUTS\" latex"
%%% End: 
