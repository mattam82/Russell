\documentclass{llncs}
\usepackage{abbrevs}
\usepackage{alltt}
\def\text{\mbox}
\usepackage{ifthen}
\usepackage{url}
\usepackage{varioref}

\newboolean{defineTheoremFr}
\newboolean{defineTheoremEn}
\setboolean{defineTheoremFr}{false}
\setboolean{defineTheoremEn}{false}
\input{mathenv}

\usepackage{bussproofs}
% Optional to turn on the short abbreviations
\EnableBpAbbreviations
\def\ScoreOverhang{3pt}			% How much underlines extend out
\def\defaultHypSeparation{\hskip.05in}   % Used if \insertBetweenHyps isn't given

\input{typing-macros}
\input{typing-decl}
\input{subtyping-decl}
\input{typing-algo}
\input{subtyping-algo}
\renewcommand{\SubSubAs}[1][\Gamma]{%
\UAX{SubSub}
{$\subalgoimpl{#1}{c}{U}{T}{\Set}$}
{$\subalgoimpl{#1}{c[\eltpit~\ctxdot]}{\mysubset{x}{U}{P}}{T}{\Set}$}
{}
}

\newenvironment{code}{\begin{alltt}}{\end{alltt}}

\input{typing-impl}
\input{subtyping-impl}

\def\id#1{\texttt{#1}}
\def\sidecond{\sideconden}

\author{Matthieu Sozeau}

\institute{Universit\'e Paris Sud, CNRS, Laboratoire LRI, UMR 8623,
  Orsay, F-91405\\
  INRIA Futurs, ProVal, Parc Orsay Universit\'e, F-91893
  \\\email{sozeau@lri.fr}}
\title{Subset coercions in \Coq} % \\ \small{Draft - \today}}
\date{\today}

\begin{document}
\maketitle

\begin{abstract}
  We propose a new language for writing programs with dependent
  types on top of the \Coq proof assistant. This language permits
  to establish a phase distinction between writing and proving
  algorithms in the \Coq{} environment.  Concretely, this means allowing
  to write algorithms as easily as in a practical functional programming
  language whilst giving them as rich a specification as desired and
  proving that the code meets the specification using the whole \Coq{}
  proof apparatus. This is achieved by extending conversion to an
  equivalence which relates types and subsets based on them, a technique
  originating from the ``\emph{Predicate subtyping}'' feature of \PVS{}
  and following mathematical convention. The typing judgements can be
  translated to the \CICfull~(\CIC{}) by means of an interpretation
  which inserts coercions at the appropriate places. These coercions can
  contain existential variables representing the propositional parts of
  the final term, corresponding to proof obligations (or \PVS{}
  type-checking conditions). A prototype implementation of this process
  is integrated with the \Coq{} environment.
\end{abstract}

\section{Introduction}
There are many means to program in the \Coq{} environment \cite{CoqArt}. One
can write programs as in \ML{} and prove properties about them
separately, losing the possibility of using dependent types in
specifications, or give a rich type expressing them as a goal and use the
proof tactics to solve it, producing a corresponding program by the
\CurryHoward isomorphism but having much less control on its algorithmic
essence. It is however difficult to mix the two methods
(writing code and proving interactively) using a rich specification. 
Indeed, when using simple terms and types (\ML{}) or even complex terms and
types (\Coq{}), we can have decidable type-checking. However, when using
simple terms to represent inhabitants of complex types, we immediately get
undecidability of type-checking, as the terms do not give enough
information. Consider for example the function \id{tail} which returns
the tail of a non-empty list. In \ML{}:
\begin{code}
  let tail = function hd :: tl -> tl | [] -> assert(false)
\end{code}

This function is partial, its domain is reduced to non-empty lists. In
\Coq, we would rather write the following:
\begin{code}
  Definition tail (l : list A) : option (list A) :=
    match l with hd :: tl => Some tl | [] => None end.
\end{code}

The option type is the usual way to encode partiality in
\Coq. However we would more naturally constrain the argument \id{l} to
non-empty lists to be more faithful to the original \ML code, and also
attach a property to the result to express more precisely what \id{tail}
does:
\begin{code}
  Definition tail (l : list A) : (l <> []) -> 
  \{ l' : list A | exists a, a :: l' = l \}.
\end{code}
Now the definition's body requires some heavy plumbing of the code which is 
not affordable when programming. Moreover, the user is forced to give a
proof term justifying that \verb|l <> []| when calling the function.
We propose a solution to overcome these difficulties, based on the \ps{}
\cite{Shankar&Owre:WADT99} technique of \PVS{}
\cite{PVS-Semantics:TR}. It is separated into two phases. First, we have
a weak, \emph{decidable} type-checking
procedure which does not require proofs to be present in the code when
constructing objects of a subset type. In our new language \Russell, the
following is a well-typed term:
\begin{code}
  Program Definition tail ( l : list A | l <> [] ) : 
    \{ l' : list A | exists a, a :: l' = l \} := 
    match l with hd :: tl -> tl | [] -> [] end.
\end{code}

The specification shows that we are defining a partial function and
enforces a relation between input and output, using a dependent type, yet the
code remains as simple as the \ML{} definition. This is only possible
because we do not require the user to write proofs in the code. After type-checking,
there is an automatic elaboration into partial \Coq terms, which collects
obligations the user has to prove. In our example,
the proof assistant will ask the user to prove that:
\begin{enumerate}
\item The list \verb|tl| has the property \verb|exists a, a :: tl = hd :: tl|,
  and
\item In the context where
  \id{l} is a non-empty list and $\texttt{l} = []$, the list $[]$ has the property
  \verb|exists a, a :: [] = []| (which should be obvious as the context is contradictory).
\end{enumerate}

This solution also provides % PVS:Language,
facilities to express properties with a more mathematical flavour using subsets,
bridging a gap between mathematical convention and type theory. 

The \Program{} tactic by C. Parent \cite{conf/mpc/Parent95} had the same
goal as ours but a different method for achieving it. It was strongly
linked to the extraction mechanism included in \Coq, both theoretically
and practically. Sketching the mechanism, she defined a weakened
extraction operation on \CIC{} terms which could be inverted because it left enough
information in the extracted term to rebuild a partial proof. The
mechanism, while general and theoretically well thought out, required
some heuristics and did not integrate smoothly with the \Coq{}
environment. In particular it lacked the pervasiveness our method has,
being applicable in a wide variety of situations in the proof assistant
environment.


Instead of trying to find a general method for synthesizing proofs from
programs in the \CICfull, we have integrated a method which permits to
link strong specifications and purely algorithmical code. This method,
known as \ps{} in the \PVS{} system, has been used with great success and
fits naturally with how we write specifications using the subset type \cite{progmartinlof}.
The main contribution of this paper is to show how the \ps{} method 
can be adapted in a proof assistant with proof terms, which formally 
justifies the extension in the first place.

The remaining of the article is organised as follows: in section \ref{sec:Russell} we present a
type system based on \CIC, which integrates subset ``subtyping'', and
prove decidability of type-checking. Then, we show how it relates to
\CIC{} by means of translations between
judgements of the two systems in section \ref{sec:Translation}. Next we present a prototype
implementation in section \ref{sec:Program}, and finally we give our
conclusions on this work and discuss future directions in section \ref{sec:Conclusion}.

\section{\Russell{}}
\label{sec:Russell}
The name of our language is an homage to the mathematician Bertrand Russell who
discovered the famous paradox of set theory with the unrestricted
comprehension axiom. In this theory, it is possible to construct the set
$X = \{x `| x `; x\}$ whose definition is circular. Clearly, if $X `: X$
then $X `; X$ and if $X `; X$ then $X `: X$, hence we have an
inconsistency. Russell was one of the pioneers of type theory when he
devised a set theory with a restricted comprehension axiom that
permitted to create subsets only from already defined subsets,
forbidding the definition of $X$. % \cite{whitehead.russell:principia}. 

In \Coq, the distinction between informative and propositional parts of
a term is formalised by the \Set{}/\Prop{} sorts. In \Russell, we have
special support for propositions appearing in subset types. By
delimiting the use of propositions, we can separate code from proof.

This idea is already present in mathematics. When you have
an element of subset $\{ x `: S `| P \}$, you can freely forget about the property $P$
and use any operation which is defined on $S$. Conversely, when you
want to use an operation defined on a subset, say $f : \{ x : `N `| P \} "->"
X$, you usually prove \emph{first} that you apply it only to elements 
having the desired property. For example $(f~2)$ is a correct application
only if $(P[2/x])$ is provable.
In the context of formal development of programs, such a workflow is not
entirely satisfactory because it forces one to create objects and prove
properties about them \emph{at the same time}. In \Coq{}, we are forced
to apply $f$ to an object $(\elt{\nat}{\lambda x : \nat. P}{2}{p})$ where $p$ is a proof of
$(P[2/x])$ (Figure \ref{fig:cci-subset} presents the definition of the subset type in \Coq).
We would like to be able to prove that our usage of partial functions 
is correct only after the program is written. Subsets are particularly well-suited in this respect
because they separate the objects we want to manipulate and their associated
properties. Similar treatments of subsets as a construct to separate
informative and propositional parts of an object include the work by
Nordstr\"om et al. \cite{progmartinlof} and subset types in NuPRL \cite{constable86nuprl}.

\begin{figure}[ht]
  \begin{center}
    \def\type{\typed}
    \AXC{$`G \type A : \Set$}
    \AXC{$`G, x : A \type P : \Prop$}
    \LeftLabel{\irule{Subset}}
    \BIC{$`G \type \mysubset{x}{A}{P} : \Set$}
    \DP
    
    \vspace{\infvspace}
    
    \AXC{$`G \type a : A$}
    \AXC{$`G \type p : P[a/x]$}
    \AXC{$`G \type \mysubset{x}{A}{P} : \Set$}
    \LeftLabel{\irule{Element}}
    \TIC{$`G \type \elt{A}{(\lambda x : A.P)}{a}{p} : \mysubset{x}{A}{P}$}
    \DP
    \vspace{\infvspace}

    \AXC{$`G \type t : \mysubset{x}{A}{P}$}
    \LeftLabel{\irule{Subset-$\eltpit$}}
    \UIC{$`G \type \eltpit~t : A$}
    \DP
    \quad
    \AXC{$`G \type t : \mysubset{x}{A}{P}$}
    \LeftLabel{\irule{Subset-$\eltpip$}}
    \UIC{$`G \type \eltpip~t : P[\eltpit~t/x]$}
    \DP
  \end{center}  
  \caption{Subset type in \CIC}
  \label{fig:cci-subset}   
\end{figure}

\subsection{From \ps{} to subset equivalence}
The \ps{} mechanism \cite{Shankar&Owre:WADT99} %Rushby96:TSE
is an extension of the \PVS type system which internalises this idea.
Concretely, this means that the following rules are derivable in \PVS:
\begin{center}
  \AXC{$`G \vdash t : \{ x : T `| P \}$}
  \UIC{$`G \vdash t : T$}
  \DP
  \AXC{$`G \vdash t : T$}
  \AXC{$`G \vdash P[t/x]$}
  \BIC{$`G \vdash t : \{ x : T `| P \}$}
  \DP
\end{center}

The first one formalises the fact that an object of a subset based on
$T$ is an object of type $T$. The second one permits using an object of
type $T$ as an object of type $\{ x : T `| P \}$, but it generates a
\emph{type-checking condition} $`G \vdash P[t/x]$ which will need to be
discharged later. Effectively, the typing algorithm of \PVS{} collects
the conditions that must be satisfied for the term to be accepted as a
valid definition. However, the acceptance criteria can be rather large in
\PVS{}. By design, when proving in \PVS{}, the trusted code base (TCB
hereafter) is the entire system, not only the typing system but also the
various decision procedures and tactics used to build proofs
automatically or interactively. It is nonetheless a widely used proof
assistant and the predicate subtyping feature has apparently helped to
build a consequent library of certified code. On the other hand, \Coq
has a small TCB and greater expressiveness but less automation and
methodology to build certified programs. We capitalise on the \PVS
success to make \Coq more usable for this kind of tasks, and as we will see,
it will have other benefits.

\subsection{A weaker type system}
To formalise this idea in \Coq, we simply weaken the type system so that
it doesn't require the terms to contain the proof components for objects
of subset types. This permits to have a simple language for code while
retaining the richness of \Coq's specification language. Once we have a
derivation in this new type system, we can translate it to a partial
\Coq derivation, where the missing parts are represented by
metavariables. It can then be completed by instantiating these holes
with actual proofs.

\subsubsection{Type system}
\begin{figure}[ht]
  \begin{center}
    \def\infvspace{0.1in}
    \def\seq{\typed}
    \def\fCenter{\wf}
    
    \WfEmpty\DP\WfVar\DP

    \def\fCenter{\typed}
    \vspace{\infvspace}

    \Var\DP\PropSet\DP
    
    \vspace{\infvspace}
    \Prod\DP
    
    \vspace{\infvspace}
    \Abs\DP
    \quad\hspace{-2.5em}
    \App\DP

    \vspace{\infvspace}
    \SigmaR\DP
    
    \vspace{\infvspace}
    \SumDep\DP

    \vspace{\infvspace}
    \PiLeft\DP
    \quad
    \PiRight\DP

    \vspace{\infvspace}
    \Conv\DP
  \end{center}  
  \caption{\CIC typing judgement}
  \label{fig:cic-decl-rules}  
\end{figure}

\begin{figure}[t]
  \begin{center}
    \def\infvspace{0.1in}
    \def\seq{\typed}
    \def\fCenter{\wf}
    \vspace{\infvspace}
    \Subsum\DP  
       
    \vspace{\infvspace}
    \SubsetR\DP
  \end{center}  
  \caption{\Russell new rules}
  \label{fig:typing-decl-rules}  
\end{figure}

\Russell{}'s type system is based on the Calculus of Inductive
Constructions (figure \vref{fig:cic-decl-rules}) \cite{coquandhuet88},
with sigma types but without universes.  This restriction may be removed
in future work, but causes no problem for our main purpose which is
programming. We omit inductive constructs here, as they can be
considered as constants and leave their treatment as future work. The
judgement $`G \typed t : T$ means $t$ is a well-typed term of type $T$
in environment $`G$.  

Following the presentation as a Pure Type System, the set of sorts
$\PTSsorts$ is defined as $\setproptype$. As usual, we let $s, s_i$ for
$i `: `N$ range over sorts. The axioms are $\PTSaxioms = \{ (\Set,
\Type), (\Prop, \Type) \}$ and the set of rules $\PTSrules$ is defined
by the functional relation $`A s_1 s_2, (s_1, s_2, s_2) `: \PTSrules$. We allow products $\Pi x :
A. B$ where $A : \Prop$ and $B : \Set$ but the user is encouraged to
encode them as $\Pi x : \{ \_ : \texttt{unit} `| A \}. B$ (with \texttt{unit} the
type containing a single element \verb|tt|) to benefit from
the subtyping mechanism which we will define later.

The reduction rules of this system are the standard $\beta$ and $\pi$
for projections. We denote by $\hnf{x}$ the weak head normal form
of $x$. We use a standard judgemental equality $`G \type T \eqbp U : s$
meaning $T, U$ are well-typed, convertible terms of sort $s$ in context $`G$.

We allow to form dependent sums $\Sigma x : U.V$ (\irule{Sigma},
\irule{Pair}, \irule{Pi-1}, \irule{Pi-2} rules) only when $U, V :
\Set$ or $U, V : \Prop$. The first sum represents dependent pairs,
useful when defining functions returning a tuple, the latter represents
dependent pairs of propositions, which is most often used as conjunction
of propositions. The dependent pair with $U : \Set$ and $V : \Prop$ is
the subset type which we distinguish (rule \irule{Subset}). The last
possible pair $U : \Prop, V : \Set$ is forbidden because it corresponds
to a pair where the last component, which is informative, may depend on
a particular proof of the proposition $U$. This is quite contrary to the
mantra ``Computations do not depend on proofs'' which governs our
programming language. If there is no dependence then the components can be
swapped.

In \Russell, the conversion rule \irule{Conv} is replaced by a
new subsumption rule \irule{Subsum} (figure
\vref{fig:typing-decl-rules}) which will implement the subset
equivalence. The judgement $`G \typed T \subd U : s$ means $T$ is
equivalent to $U$ in environment $`G$, both sorted with $s$.
The essence of our equivalence is to identify subset types if they have
equivalent supports, hence we have the following property:
\begin{proposition}[Subset erasure and consistency]
  If we erase subset types from \Russell terms and rules, leaving only the supports, we get a valid
  \CIC term and derivation, hence $`_$ is not provable in \Russell.
\end{proposition}
\begin{proof}
  By erasing subsets in \Russell rules, the \irule{Subset} rule becomes
  admissible and the \irule{Subsum} rule becomes \irule{Conv}. By
  eliminating the subset type in a term we get a valid \CIC term. Hence
  to each \Russell derivation corresponds a \CIC derivation.
\end{proof}

\subsubsection{Equivalence}
We have renamed the technique from \ps{} to 
\emph{subset equivalence} because we have a symmetric relation, contrary
to usual subtyping relations. It also conveys the idea that it can
include the usual $\beta\pi$-conversion directly in the judgement.
The judgement $`G \typed T \subd{} U : s$ (figure
\vref{fig:conversion-decl-rules}) reads $T$ is equivalent to $U$ in
environment $`G$, both being sorted by $s$. 

\begin{figure}[h]
  \subtdRules
  \caption{\Russell{} conversion}
  \label{fig:conversion-decl-rules}
\end{figure}

The rule \irule{SubConv} integrates $\beta\pi$-conversion in the
judgement. We use a judgemental equality here, which will be refined by
the usual conversion relation later. The \irule{SubTrans} rule ensures
that our judgement builds an \emph{equivalence} and has
proper modularity. It is trivial to check that we have symmetry given 
the symmetry of the definitional equality. The next two rules (\irule{SubProd} and
\irule{SubSigma}) do context closure for dependent
products and sums. It is remarkable that we use contravariance for
% \cite{journals/toplas/Castagna95}
domains in the \irule{SubProd} rule, not restricting to invariance as in
\PVS. It is accessory here, as we could have used \emph{co}variance and
still get the same judgements because we have symmetry. However, it will
become important when we create coercions (see figure
\vref{fig:coerce-impl-rules-short}).

The really interesting rules are \irule{SubSub} and
\irule{SubProof}. The first one allows to use an object of a subset type
as an object of its support type. The later allows (maybe abusively) to
consider an object of any type as an object of any subset based on
this type. We must check that the property $P$ is well-formed, but
we do not care about its provability.

\subsubsection{Properties}
We have proved some of the metatheory for this system in \Coq{}
\cite{sozeau:Coq/Russell/meta-web}.
We have assumed that it is strongly
normalising (SN) but we have proved subject reduction (SR) for it: 
if $`G \typed t : T$ and $t "->"_{\beta\pi} t'$ then $`G \typed t' :
T$ (our proof of SR does not depend on SN).
Gang Chen \cite{ChenPhD} has studied various type systems from the
$\lambda$-cube extended by subtyping or coercive subtyping
\cite{DBLP:conf/csl/Luo96}, including the Calculus of Constructions, and
proved such results as SN and SR for them. It requires a very careful
analysis of the system to avoid cycles in the proof due to the presence
of dependent types and conversion. However we preferred to adapt the method of
Robin Adams \cite{adams:PTSEQ} to prove SR, because Gang Chen's method
seemed very tied to the peculiarities of the system he studied. 
% Strong normalisation could also be proved, perhaps more easily,
% using the generic proof method developed by Geuvers \cite{geuvers95}, by finding
% a proper interpretation of \Russell terms into the Calculus of
% Constructions.

So, apart from strong normalisation, we have shown all the usual structural
and metatheoretic properties of a dependent programming language, like
weakening, thinning and substitution, stability by context coercion, etc.
We stop here on the subject of theoretical properties of this first system, as
it gives no new insights for our purpose and we will focus more on the
algorithmic system's properties. Besides, the details of the
formalisation and the proof fall outside the scope of this paper.
% The essential properties of the $\subd$ judgement are 
% its reflexivity: if $`G \typed A : s$, then $`G \typed A \subd A$,
% symetry: if $`G \typed A, B : s$ then $`G \typed A \subd B "<=>" `G \typed
% B \subd A$ and transitivity by \irule{SubTrans}.

% As typing and equivalence are mutually recursive, we will generaly prove
% properties by mutual induction on the two derivations.

% \begin{lemma}[Weakening]
%   Suppose $\wf{`G, x : S, `D}$.
%   If $`G, `D \typed t : T$ then $`G, x : S, `D \typed t : T$. 
%   If $`G, `D \typed T \sub U : s$ then $`G, x : S, `D \typed T \sub U : s$.
% \end{lemma}
% \begin{proof}
%   Straightforward mutual induction.
% \end{proof}

% Similarly for thining and substitution. An important property for
% dependent type systems is to have invariance of judgments which are
% definitionaly equal (here equivalent). Hence the following lemma:
% \begin{lemma}
%   Suppose $`G \typed U \sub V : s$.
%   If $`G, x : V, `D \typed t : T$ then $`G, x : U, `D \typed t : T$.
%   If $`G, x : V, `D \typed S \sub T : s'$ then
%   $`G, x : U, `D \typed S \sub T : s'$.
% \end{lemma}
% \begin{proof}
%   By mutual induction on the typing and equivalence derivations.
% \end{proof}

\subsubsection{Algorithmic typing}

\begin{paragraph}{}
We use a standard transformation to get an algorithm from our typing
rules, removing the conversion (or subsumption) rule
(here \irule{Coerce}) and integrating it to the premises of the other rules.
%We recall that $`G \type t : s$ is shorthand for $`G \type t : T$ and
%$T  `= s$ with $s `: \PTSsorts$ in a algorithmic presentation.
Our algorithmic judgement $`G \typea t : T$
(figure \vref{fig:typing-algo-rules})
reads: $t$ has type $T$ in environment $`G$.
We need to introduce the notion of support for subset types in order to
define our algorithmic system. Indeed, when typing an application, 
we need to ensure that the object we apply can be seen as an object of a
product type modulo the equivalence. 
% This notion is presented in \PVS{} by
% means of a $\mu_0$ operator which was readily adaptable in our setting
% (figure \vref{fig:mualgo-definition}). In Gang Chen's work, the notion is formalized by a
% new judgement $\Pi_{lub}$ which is essentialy equivalent to the operator
% $\mualgo$, except ours finds $\Sigma_{lub}$s too.
\begin{figure*}[t]
  \def\infvspace{0.5em}
    \def\type{\typea}
    \def\subt{\subta}
    \def\sub{\suba}
    \def\fCenter{\typea}
    \begin{center}

    \vspace{\infvspace}
    \AppA\DP
    
    \vspace{\infvspace}
    \SumDepA\DP

    \vspace{\infvspace}
    \PiLeftA\DP
    \quad\hspace{-2.5em}
    \PiRightA\DP
  \end{center}  
  \caption{\Russell{} algorithmic typing, new rules}
  \label{fig:typing-algo-rules}  
\end{figure*}

\typemuaFig[$\mualgo$ definition]

\begin{figure*}
    \def\fCenter{\suba}
    \def\type{\typea}
    \def\sub{\suba}
    \begin{center}
    \SubConvA\DP 

    \vspace{\infvspace}
    \SubHnfA\DP

    \vspace{\infvspace}
    \SubProdA\DP

    \vspace{\infvspace}
    \SubSigmaA\DP

    \vspace{\infvspace}
    \SubProofA\DP

    \vspace{\infvspace}
    \SubSubAs\DP
  \end{center}  
  \caption{\Russell{} algorithmic equivalence}
  \label{fig:subtyping-algo-rules}  
\end{figure*}


\end{paragraph}
\begin{paragraph}{}
  The next thing to do is to construct a decidable judgement for
  equivalence given two types. We denote it by $`G \typea T
  \suba U : s$ (figure \ref{fig:subtyping-algo-rules}).
  In our case, we have to check that definitional equality is decidable, which is the
  case as we can replace the judgemental equality with the usual untyped
  convertibility $\eqbp$ (we proved $`G \type T \eqbp U : s
  "<=>" T \eqbp U `^ `G \type T, U : s$), which is decidable on well
  typed terms.
  We also need to eliminate the transitivity rule which is not
  syntax-directed. That is the purpose of the following theorem:
\begin{theorem}[Admissibility of transitivity]
  If $`G \typea T \suba U : s$ and $`G \typea U \suba V : s$, then $`G \typea T
  \suba V : s$.
\end{theorem}
\begin{proof}
  By induction on the sum of the depths of the two derivations.
\end{proof}

  Finally, we need to restrict the application of the \irule{SubConv}
  rule when no other rules apply and the two types are in head normal form.
  We can then prove:
  \begin{theorem}[Decidability of algorithmic typing]
    $`E T, `G \typea t : T$, $`G \typea t : T$ and $`G \typea T \suba U :
    s$ are decidable problems.
  \end{theorem}
  \begin{proof}
    Rules are syntax-directed.
  \end{proof}

  We denote by $\typeafn{`G}{t}$ the function which returns the type of
  term $t$ in context $`G$ such that $`G \typea t : \typeafn{`G}{t}$,
  when it exists.
\end{paragraph}

As usual, we have the following correspondence between the two
systems:
\begin{theorem}[Soundness]
  If $`G \typea t : T$ then $`G \typed t : T$.
  If $`G \typea T \suba{} U : s$ then $`G \typed T \subd U : s$.
\end{theorem}

\begin{theorem}[Completeness]
  If $`G \typed t : T$ then there exists $T', s$ so that $`G \typea t : T'$ and $`G \typea T' \suba T : s$.
  If $`G \typed T \subd U : s$ then $`G \typea T \suba U : s$.
\end{theorem}

Finally, we can state the desired property of our typing system:
\begin{corollary}[Decidability of declarative typing]
  $`G \type t : T$ is decidable.
\end{corollary}
% \begin{proof}
%   By soundness and completness, $`G \type t : T "<=>" `E T', `G \typea t
%   : T' `^ `G \typea T' \suba T : s$ which is decidable.
% \end{proof}



\subsection{From \CIC to \lng{}}
We have presented a calculus based on \CIC with a stronger equivalence
but with restricted typing rules. We will now see how \Russell and \CIC relate
formally.
We can build a forgetful map from terms of \CIC to \Russell
(interpreting inductives as constants). It bears
relation to the $`e$ extraction function defined by Werner in
\cite{Werner:ProofIrrelevance}. Essentially, \Russell{} terms do not
contain or manipulate logical information attached to objects of subset
types, hence we must forget about it when translating.

We define the forgetful map $()^{\circ}$ from \CIC terms to \Russell
terms plus a distinguished object $`_$ as an homomorphism on terms except for the following cases:
\begin{center}
  \CCtoRussellforgetFig
\end{center}

\begin{definition}[Definedness]
  $()^{\circ}$ is defined on $t$ if $t^{\circ}$ does not contain $`_$.
\end{definition}

We can now prove the following:
\begin{theorem}[Forgetful map correctness]
  If $`G \typec t : T$ then $`G^{\circ} \type t^{\circ} : T^{\circ}$ if $()^{\circ}$ is
  defined on $`G, t$ and $T$.
\end{theorem}

Practically, this means we can use almost all existing definitions in the
\Coq environment. This map is involutive and
the identity on \Russell terms as they do not contain the constructor
$\id{elt}$ or subset projections. Moreover, this erasure function will be
defined on all \Coq terms elaborated from \Russell.
Indeed, the second projection of a
subset element will only appear in the second component of a subset
element. Otherwise, we would have used the projection directly in the
\Russell{} term, where it does not exist. In fact, as we can derive the judgement $0 : \mysubset{x}{`N}{x \neq
  0}$ in \Russell, allowing the second projection would permit to derive
$0 \neq 0$, an inconsistency.
Hence we left only the subset type forming rule (figure
\vref{fig:typing-decl-rules}) in \Russell, while the introduction and
first projection of subset elements are internalized by the coercion judgement.

\section{From \lng{} to \CICq{}}
\label{sec:Translation}
We now build an interpretation
$\ip{t}{`G}$ of \Russell terms $t$ in environment $`G$ into \CIC
terms. We will check at the end that it respects the $()^{\circ}$ operator
in the sense that if $t$ is well-typed in $`G$ then $\ip{t}{`G}^{\circ} = t$.

Our interpretation will build a full-fledged \CIC term from its
algorithmic skeleton and a rich type written in \Russell. Obviously, we
cannot infer proof terms where they are needed in \CIC, but we can build
a \emph{partial} term, leaving typed holes where proofs are
needed. Hence we add a rule to build existential variables (or
metavariables) in the target calculus ($\typeq$ denotes the new system's typing judgement):

\begin{center}  
  \UAX{}
  {$`G \typeq P : \Prop$}
  {$`G \typeq ?_{P} : P$}
  {}
  \DP
  \vspace{-0.2em}
\end{center}
We restrict it to objects of type $\Prop$ because we consider that the
informative part of the algorithm has been entirely given in the
original term. 

We are ready to build the interpretation, which should have the following property:
\begin{theorem}[Interpretation correctness]
  \label{interp-correct}
  If $`G \typea t : T$ then $\ipG{`G} \typeq \ip{t}{`G} : \ip{T}{`G}$.
\end{theorem}

The proof of this proposition is the main technical contribution of this
work, it also represented the main difficulty. 
The remainder of this section is organised as follows: first we 
define the explicit coercion derivation algorithm which will permit to
put proof obligations in the terms, then we define the
interpretation of terms which is mutually recursive with the previous
algorithm. Finally we present a proof sketch of the aforementioned
theorem.

\subsection{Explicit coercions}
The derivation of explicit coercions (figure
\vref{fig:coerce-impl-rules-short}) is based on the
algorithmic equivalence derivations.  
The side-conditions of the rules have not changed, so we omit them for
better readability. The judgement $\subimpl{`G}{c}{T}{U}{s}$ builds a
coercion $c$ from $\ip{T}{`G}$ to $\ip{U}{`G}$ in context $\ipG{`G}$.
We use the \lng{} types to drive the
derivation but the resulting object $c$ will be a well-typed \Coq{} term
(lemma \ref{lemma:coercion-correct}). We denote $\coerce{`G}{T}{U}$
the function which builds $c$ given $`G$, $T$ and $U$.
% We
% could also directly use the interpreted types but that complicates the
% proof. 

\begin{figure}[ht]
  \subtisc
  \caption{Coercion derivation}
  \label{fig:coerce-impl-rules-short}
\end{figure}

Coercions are formalised as multi-holes evaluation contexts, with
$\ctxdot$ the denotation of a hole. We define the instantiation $C[x]$ of a context $C$
by a term $x$ as simultaneous substitution of $x$ for every $\ctxdot$ in $C$.
Hence if $C$ is an evaluation context and $x$ a term, $C[x]$ is a term
(i.e., it cannot contain $\ctxdot$).
The holes will denote the object to which the coercion is applied.
% Other
% presentations are possible, notably the ``\LMS{}'' style of \cite{longo95logic} which
% was adopted by Gang Chen in his treatment of coercive subtyping for the
% Calculus of Constructions \cite{conf/popl/Chen03}, and the presentation 
% of Amokrane Sa\"ibi \cite{saibi97inheritance}. The \LMS{} style consists
% in defining a judgement $x : A \type y : B$ which reads: $A$ is
% coercible to $B$ and the coercion is $\lambda x : A.y$. This
% presentation is very elegant and adapted for checking coherence 
% of coercions, which we do not need here as we can get uniqueness
% of coercions. Moreover, it did not seem readily usable in
% our setting, where coercions may contain metavariables and depend on a
% typing context. Similarly, Amokrane Sa\"ibi defines
% a coercion derivation algorithm which respects some coherence criteria,
% roughly, that type-erased coercions $\beta\eta$-reduce to the
% identity. Again, this was not adapted to our setting, so we invented this
% new presentation. 

As conversion will be preserved by the interpretation $\ip{}{}$,
the rule \irule{SubConv} derives an empty coercion, as the target system
will be able to derive itself that $\ip{T}{`G} `= \ip{U}{`G}$.
Similarly for \irule{SubHnf}, we rely on the target system's conversion
rule so that the coercion $c$ of codomain $\ip{\hnf{U}}{`G}$ can be seen
as an object of type $\ip{U}{`G}$.

Next, we have the rules for products and sums, which compose
coercions. In the \irule{SubProd} rule, we first coerce the argument to
an object of type $\ip{T}{`G}$. Then we apply it to the coerced
function, resulting in an object $\ctxdot~(c_1[x])$ of type
$\ip{V}{`G, x : T}[c_1[x]/x]$. We will see later that this type is equivalent to
$\ip{V}{`G, x : U}$, so we can apply the second coercion and get an
object of type $\ip{W}{`G}$. There is a little twist when coercing the
second component of a dependent sum. Indeed, we must simultaneously
substitute the first projection of the coerced sum in the second
coercion which was typed in environment $`G, x : T$ and also instantiate
the coercion with the second component. Clearly, the $\ctxdot$ of the
former shouldn't be instantiated with the later, so we must first
instantiate $c_2$ and then substitute $\pi_1~\ctxdot$ for $x$ 
($x$ cannot appear in $\pi_2~t$ where $t : \Sigma x : T.V$).

Now for the original part, the \irule{SubSub} rule simply inserts a
projection before applying the inductively defined coercion on the
support of the subset. On the other hand, \irule{SubProof} creates an
object of a subset using its sole constructor \sref{elt} (with type
parameters omitted for brevity). The object
part is given by the coercion to the support of the target subset
while the proof part is promised using a metavariable of type $\ip{P}{`G, x : U}[c/x]$ which
we will turn later into a proof obligation. 

\subsection{Interpretation of terms}
The interpretation of terms from \Russell to \CICq (figure
\vref{fig:interp}) is a straightforward
recursive traversal of algorithmic typing derivations. In other, more
practical words, we can do interpretation of terms simultaneously with
typing in our implementation, just like for the existing coercion system
of \Coq. 
\begin{figure}[ht]  
  \interparr  
  \caption{Interpretation of terms}
  \label{fig:interp}  
\end{figure}
We describe the case of application here; others are similar. First we
get the \Russell types $F$ and $U$ of the function $f$ and argument $u$ by calling the
typing function on both terms. Then we must ensure that $F$ can indeed
be seen as a product using the $\mualgo$ operator. We can build
the coercion between $F$ and this product and between $U$ and its
domain. We finally instantiate these coercions by their corresponding
interpreted objects and return their application.
Well-typedness of a term in \Russell is a sufficient condition for
$\ip{t}{}$ to be defined.

\subsection{A little more expressiveness}
One may wonder how can we interpret \Russell terms into a system with only
$\beta\pi$-equivalence and still be a simple extension of \CIC. 
Indeed, consider the following example. Suppose we have two types $A, B$
with coercions: $c : A \suba B$ and $d : B \suba A$. Additionally, let
$P : A "->" Prop$ with introduction terms $p : \Pi x : A, P~x$ and $q :
\Pi x : B, P~x$. Consider the following well-typed \Russell term $p~x
=_{P~x} q~x$ in context $`G = x : A$. By interpretation into \CIC, we
have $\ip{P}{`G} = P$, $\ip{p}{`G} = p$ and $\ip{q}{`G} = q : \Pi x : B,
P~d[x]$. Now the interpretation of the equality gives:
$p~x =_{P~x} \ip{q~x}{`G}$ where $\ip{q~x}{`G} `= q~c[x]$. 
The right hand side has type $P~d[c[x]]$ which must be
convertible with $P~x$ for the whole term to be well-typed. This
indicates that coercions must be unique (so that $d `o c `= id_A `=
\ctxdot$), which implies that we have to include $\eta$ 
conversion in the definitional equality. For
example if $A = \Pi x : X.Y$ and $B = \Pi x : X'.Y'$ with $X = X'$ and
$Y = Y'$, we have $d `o c = \lambda x : X. \ctxdot~x `o \lambda x
: X'. \ctxdot~x = \lambda x : X. \ctxdot~x$ which must be definitionally
equal to $\ctxdot$.
Similarly, we must add $\eta$ rules for all introduction terms of our
language to ensure uniqueness of coercions. It is an important
property of our system, as it corresponds in practice to the determinism
of proof-obligations
generation. The complete equational theory of \CICq{} is given in figure
\vref{fig:eqccq}. It includes $\eta$, surjective pairing for dependent
sums and subsets ($\rho$) and proof-irrelevance for the second component
of subset objects ($\tau$) and is sufficient to ensure uniqueness of coercions.
Benjamin Werner has studied the addition of proof-irrelevance (rule
$\sigma$) in the Calculus of Constructions
\cite{Werner:ProofIrrelevance}. It is not a trivial extension and it has
far-reaching consequences on the model of the calculus
\cite{DBLP:conf/types/MiquelW02}. We direct the reader to these papers for further
information on the subject.
\begin{figure}[ht]  
  \ccqeqarr 
  \caption{Equational theory of \CICq}
  \label{fig:eqccq}  
\end{figure}

\subsection{Properties}
The correctness proof of the translation is very involved, so we will
only sketch it here. A report \cite{sozeau:Coq/Russell/report} is
available (in French) and a mechanically checked proof is under development.

We first prove reflexivity, symmetry and transitivity of the coercion
derivation algorithm, which extends previous proofs for the algorithmic
system with properties on
the generated coercions. Then we show substitutivity of the
interpretation: if $`G, x : U, `D \type t : T$ then $\ip{t[u/x]}{`G,
 `D[u/x]} = \ip{t}{`G, x : U, `D}[\ip{u}{`G}/x]$. We extend the notion
of coercion to contexts next and show stability of judgements under
context coercion. It is then possible to prove a lemma about commutativity of
substitutions with the interpretation and coercions. Then we get an
important corollary: if $`G \type u : U$, $\subimpl{`G}{c}{U}{V}{s}$ and
$`G, x : V \type T : s$ then $\ip{T[u/x]}{`G} `= \ip{T}{`G, x :
  V}[c[\ip{u}{`G}]/x]$. Essentially, it shows that coercions inserted
by the interpretation depend only on the context and hence could be
added later using substitution instead. This allows us to show that
equivalence is conserved by interpretation and the following lemma:
\begin{lemma}[Coercion derivation correctness]
  \label{lemma:coercion-correct}
  If $\subimpl{`G}{c}{T}{U}{s}$ then $\ipG{`G} \typec \lambda x :
  \ip{T}{`G}.c[x] : \ip{T}{`G} "->" \ip{U}{`G}$.
\end{lemma}
Finally we can show that our interpretation is correct (theorem \ref{interp-correct}).

\section{Implementation}
\label{sec:Program}
This mechanism has been implemented in \Coq and tested on simple
examples (some are available on the author's website, including safe list
operations and a head normal form definition). We actually generate
coercions simultaneously with typing 
in the implementation, which is sound thanks to the previous proofs. Our
typing is a clone of \Coq's original typing algorithm, so we benefit
from all the features of \Coq including implicit variables, notations and the existing
coercion system. The prototype also contains support for strucural and 
well-founded \verb|Fixpoint| definitions.
The type-checker transforms pattern-matching so
that an equality between the matched term and the pattern is present in
the typing context of each branch and it allows the user to put explicit 
holes in the term, for example:
\begin{code}
  Program Definition tail ( l : list A | l <> [] ) : list A :=
    match l with hd :: tl -> tl | [] -> False_rec (list A) _ end.
\end{code}
In the second branch we have $l = []$ and $l \neq []$, hence we can
prove $`_$ and derive an object of type $\texttt{list}~A$.

It must be stressed that we do not lose any information when
generating obligations as we have the whole term context at hand,
avoiding the complicated proof obligation generation of \PVS \cite{PVS-Semantics:TR}.
Here we would have $l : \mysubset{l}{\texttt{list}~A}{l \neq []}, Heql : \eltpit~l =
[]$. We have tactics that clean the goal and context (deconstructing
subsets and simplifying to present $l : \texttt{list}~A, H : l \neq [], Heql : l = []$
to the user) but it does not match the usability of \PVS yet.


\section{Conclusion}
\label{sec:Conclusion}
We have developed a new language for writing programs in the \Coq proof
assistant which allows the user to specify complex programs while
keeping the corresponding code simple. It is a first step towards
interpretation of \ML code into \Coq to build certified
programs. While the system and its accompanying proofs may seem complex, the
implementation is short, simple and has been tested with success on
simple examples. This work is also a second proof of the
meaningfulness of the Predicate Subtyping feature of \PVS{} and may
help build a common interface for the two provers. 

\subsection{Related work}
Other efforts to build certified programs using type theory include
\Cayenne \cite{Augustsson99} and \Epigram
\cite{DBLP:journals/jfp/McBrideM04}. \Cayenne offers dependent
types and general recursion at the expense of a non-terminating type
checker; it can be thought of as a testbed for developing languages with
dependent types but is not so much aimed at building certified programs.
\Epigram ought to become a complete programming language with dependent
types at its heart. Instead of using a phase distinction to separate
coding and proving, \Epigram is based on an interactive, 2-dimensional editing process
where code and proofs are written incrementally to get a complete program.
Using type annotations and with the help of the editor for structuring, 
one is able to write programs with precise specifications. However it
is not obvious if it could be made usable by programmers because of the
paradigm change and scaling issues, time will tell which approach is
more beneficial for writing and reasonning about dependently typed
programs. The \DML language \cite{Xi98:PhD} is more akin to
comparison with our solution. It provides a way to use a restricted set
of dependent types in \ML programs, carefully chosen so as to keep
type-checking decidable with the help of an automatic prover. Our method
should subsume this one as it is perfectly possible to integrate automatic
proof tools with \Coq to discharge the generated obligations. There
exists many more systems like Xi's Applied Type Systems and Tim Sheard's
Omega language which explore the design space of dependently typed languages.

\subsection{Further work}
Much has to be done to smoothly integrate \Russell into \Coq. The
treatment of existential variables of \Coq has to be improved, the
type inference algorithm needs some tuning to become more similar to \ML
and an integration of proof-irrelevance in the kernel, while rarely needed in
practice, is necessary to have a robust system.
We also hope to extend this mechanism of proof-obligations generation to other
constructs, notably (co-)inductive types. Finally, we intend to use this system as a
basis for interpretation of more general \ML{} programs in \Coq, using a monadic
translation or some kind of effects to reflect imperative constructs
like exceptions and references.

\paragraph{Acknowledgements}
We would like to thank Christine Paulin-Mohring for directing this work and
Jean-Christophe Filli\^atre for discussions on previous versions of this
paper. We thank the anonymous referees for their insightful comments.
\bibliography{my,bib-joehurd,barras,pvs-bib,bcp,Luo,biblio-subset,%
cparent,demons,demons2,demons3}
\bibliographystyle{splncs}
% \renewcommand{\thefootnote}{}
% \footnotetext{This article was typeset in \LaTeX~using the
%   \texttt{Concrete Math} font}


\end{document}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% LaTeX-command: "BIBINPUTS=\"${HOME}/research/demons-biblio:../bib:$BIBINPUTS\" TEXINPUTS=\"${HOME}/.latex:..:../style:$TEXINPUTS\" latex"
%%% End: 
