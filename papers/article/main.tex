\documentclass{llncs}
\usepackage{abbrevs}
\usepackage{array}

\def\text{\mbox}

%\usepackage{amsmath}
%\usepackage{amsthm}

%\usepackage{qzapfcha}
%\usepackage{cmbright}
\usepackage{concmath}
\usepackage{ifthen}
\usepackage{varioref}

\newboolean{defineTheoremFr}
\newboolean{defineTheoremEn}
\setboolean{defineTheoremFr}{false}
\setboolean{defineTheoremEn}{false}
\input{mathenv}

\usepackage{bussproofs}
% Optional to turn on the short abbreviations
\EnableBpAbbreviations
\def\ScoreOverhang{3pt}			% How much underlines extend out
\def\defaultHypSeparation{\hskip.05in}   % Used if \insertBetweenHyps isn't given



\input{typing-macros}
\input{typing-decl}
\input{subtyping-decl}

\input{typing-algo}
% \renewcommand{\AppAFull}[9][\Gamma]{
% \TAX{App}
% {$\tgen{#1}{#2}{#3} \suba \Pi #4 : #5. #6$}
% {$\tgen{#1}{#8}{#9}$} % \quad \tgen{#1}{#9, #5}{#7'}$}
% {$\subalgo{#1}{#9}{#5}{s}$}
% {$\tgen{#1}{(#2 #8)}{#6 [ #8 / #4 ]}$}
% {}
% }
\input{subtyping-algo}
\renewcommand{\SubSubAs}[1][\Gamma]{%
\UAX{SubSub}
{$\subalgoimpl{#1}{c}{U}{T}{\Set}$}
{$\subalgoimpl{#1}{c[\eltpit~\ctxdot]}{\mysubset{x}{U}{P}}{T}{\Set}$}
{}
}

\usepackage{framed}
%\usepackage{multicol}

\author{Matthieu Sozeau\inst{1}}

\institute{LRI, Paris Sud XI University\\\email{sozeau@lri.fr}}
\title{Subset coercions in \Coq}
\date{\today}

\begin{document}
\maketitle

\abstract{We set out to establish a phase distinction between writing and
  proving algorithms in the \Coq{} environment. Concretely, this means
  allowing to write algorithms as easily as in a pratical functionnal 
  programming language
  whilst giving them as rich a specification as desired and proving that
  the code meets the specification using the whole \Coq{} proof
  apparatus. This is achieved by extending conversion to an equivalence 
  which relates types
  and subsets based on them, a technique  
  originating from the ``\emph{Predicate subtyping}'' feature of \PVS{} and
  following mathematical convention. The typing judgments can be
  translated to the \CICfull (\CIC{}) by means of an interpretation which inserts
  coercions at the appropriate places. These coercions can contain
  existential variables representing the propositional parts of the final
  term. A prototype implementation of this process
  has been implemented.}

\section{Introduction}
There are many means to program in the \Coq{} environment. One
can write programs as in \ML{} and prove properties about them
separately, loosing the possibility of using dependent types in
specifications, or give a rich type expressing them as a goal and use the
proof tactics to solve it, producing a corresponding program by the
\CurryHoward isomorphism but having much less control on its algorithmic
essence. It is however difficult to mix the two methods
(writing code and prove interactively) using a rich specification. We
propose a solution to overcome this difficulty, based on the \ps{}
\cite{Shankar&Owre:WADT99} technique of \PVS{}
\cite{PVS:Language,PVS-Semantics:TR}. This solution also provides
facilities to express properties with a syntaxicaly more mathematical flavor,
bridging the gap between mathematical convention and type theory.

The \Program{} tactic by C. Parent \cite{conf/mpc/Parent95} had the same
goal as ours but a slightly different method for achieving it. It was strongly
linked to the extraction mechanism included in \Coq, both theoreticaly
and practically. Sketching the mechanism, they defined a weakened
extraction operation on \CIC{} terms which could be inverted because it left enough
information in the extracted term to rebuild a partial proof. The
mechanism, while general and theoreticaly well thought out, required
some heuristics and did not integrate smoothly with the \Coq{}
environment. In particular it lacked the pervasivness our method has,
being applicable in a wide variety of situations in the proof assistant
environment.

Instead of trying to find a general method for synthetising proofs from
programs in the \CICfull, we have integrated a method which permits to
link strong specifications and purely algorithmical code. This method,
known as \ps{} in the \PVS{} system has been used with great success and
fits naturally with how we write specifications. The main contribution
of this paper is to show how the \ps{} method can be adapted in a proof
assistant with proof terms, which formally justifies the extension in
the first place.

The rest of the article is organized as follows: first we present a
type system based on \ECC{}, which integrates subset ``subtyping'', and
we show how it relates to \CIC{} by means of traductions between
judgements of the two systems. Then, we present a prototype
implementation with some case studies, and finally we give our
conclusions on this work and discuss future directions.

\section{\Russell{}}
The name of our language is an homage to the mathematician Bertrand Russell who
discovered the famous paradox of set theory with the unrestricted
comprehension axiom. In this theory, it is possible to construct the set
$X = \{x `| x `; x\}$ whose definition is circular. Clearly, if $X `: X$
then $X `; X$ and if $X `; X$ then $X `: X$, hence we have an
inconsistency. \Russell{} was one of the pioneers of type theory when he
devised a set theory with a restricted comprehension axiom that
permitted to create subsets only from already defined subsets,
forbidding the definition of $X$ \cite{whitehead.russell:principia}. 

The subset equivalence idea is to identify elements of subsets if
they are built from the same underlying set. That is, we can identify
elements of $`N$ with elements of any subset $\{ x `: `N `| P \}$.
However, we should not be able to draw conclusions based on the
properties attached to an element of a subset. Otherwise it would be
possible to claim that $0 `: \{ x `: `N `| x \neq 0 \}$ but also that $0
\neq 0$ which would lead us to inconsistency. 

Informally, this idea is already present in mathematics. When you have a
subset $\{ x `: S `| P \}$, you can freely forget about the property $P$
and use any operation which is defined on $S$. Conversely, when you
want to use an operation defined on a subset, you usually prove \emph{first}
that you apply it only to elements having the desired property. 
In the context of formal development of programs, such a workflow is not
entirely satisfactory because it forces one to create objects and prove
properties about them \emph{at the same time}. We would like for example
to prove that our usage of partial functions is correct only after the
program is written. Subsets are particularly well-suited in this respect
because they separate the objects we want to manipulate and the
properties which we use to reason about them.

\subsection{From \ps{} to subset equivalence}
The \ps{} mechanism \cite{Rushby98:TSE,Shankar&Owre:WADT99}
is an extension of the \PVS type system which internalizes this idea.
Concretely, this means that the following rules are derivable in \PVS:
\begin{center}
  \AXC{$`G \vdash t : \{ x : T `| P[x] \}$}
  \UIC{$`G \vdash t : T$}
  \DP
  \AXC{$`G \vdash t : T$}
  \AXC{$`G \vdash P[t]$}
  \BIC{$`G \vdash t : \{ x : T `| P[x] \}$}
  \DP
\end{center}

The first one formalizes the fact that an object of a subset based on
$T$ is an object of type $T$. The second one permits using an object of
type $T$ as an object of type $\{ x : T `| P[x] \}$, but it generates a
\emph{type checking condition} $`G \vdash P[t]$ which will need to be
discharged later. Effectively, the typing algorithm of \PVS{} collects
the conditions that must be satisfied for the term to be accepted as a
valid definition. However, the acceptance criteria is rather vague in
\PVS{}. By design, when proving in \PVS{}, the trusted code base (TCB
hereafter) is the entire system, not only the typing system but also the
various decision procedures and tactics used to build proofs
automatically or interactively. It is nonetheless a widely used proof
assistant and the predicate subtyping feature has apparently helped to
build a consequent library of certified code. On the other hand, \Coq
has a small TCB and greater expressiveness but less automation and
methodology to build certified programs. We capitalize on the \PVS
success to make \Coq more usable for this kind of tasks, and as we will see,
it will have other benefits.

\subsection{Typing and conversion}
Our presentation of \ps{} differs slightly from the original one
essentially because of the proof terms, but we have also extended it in some ways. 

\subsubsection{Type system}
\begin{figure}[t]
  \begin{center}
    \def\infvspace{0.1in}
    \def\seq{\typed}
    \def\fCenter{\wf}
    
    \WfEmpty\DP\WfVar\DP

    \def\fCenter{\typed}
    \vspace{\infvspace}

    \Var\DP\PropSet\DP
    
    \vspace{\infvspace}
    \Subsum\DP
       
    \vspace{\infvspace}
    \Prod\DP
    
    \vspace{\infvspace}
    \Abs\DP

    \vspace{\infvspace}
    \App\DP

    \vspace{\infvspace}
    \SigmaR\DP
    
    \vspace{\infvspace}
    \SumDep\DP

    \vspace{\infvspace}
    \PiLeft\DP
    \quad
    \PiRight\DP

    \vspace{\infvspace}
    \SubsetR\DP
  \end{center}
  \vspace{-2em}
  \caption{\Russell{} typing}
  \label{fig:typing-decl-rules}
  \vspace{-1em}
\end{figure}
%
\Russell{}'s type system (figure \vref{fig:typing-decl-rules}) is based
on the Calculus of Constructions \cite{coquandhuet88,Barras99}, with sigma types but without universes.
This restriction may be removed in future work, but cause no problem for
our main purpose which is programming. The judgement $`G \typed t : T$
means $t$ is a well-typed term of type $T$ in environment $`G$, and $`G
\typed T \subd U$ means $T$ is equivalent to $U$ in environment $`G$. 
Following the presentation as a pure type system \cite{barendregt91}, 
the set of sorts $\PTSsorts$ is defined as $\setproptype$. As usual, we
let $s, s_i$ for $i `: `N$ range over sorts. The
axioms are $\PTSaxioms = \{ (\Set, \Type), (\Prop, \Type) \}$ and the
set of rules $\PTSrules$ is defined by the following (functional) relation:
% \begin{table}[h]
%   \vspace{-1.5em}
  \axiomsd
%   \vspace{-1em}
%   \caption{Definition of $\PTSrules$}
%   \label{fig:PTSrules}
% \end{table}

We allow to form dependent sums $\Sigma x : U.V$ (\irule{Sigma}, \irule{Sum-Dep},
\irule{Pi-1}, \irule{Pi-2} rules) only when $U, V : \Set$
or $U, V : \Prop$. The first sum represents dependent pairs, useful
when defining functions returning a tuple, the latter represent
dependent pairs of propositions, which is rarely used. The dependent
pair with $U : \Set$ and $V : \Prop$ is the subset type which we
distinguish (rule \irule{Subset}). The last possible pair $U : \Prop, V : \Set$ is forbidden
because it corresponds to a pair where the last component, which is
informative, may depend on a particular proof of the proposition
$U$. This is quite contrary to the mantra ``Computations do not depend
on proofs'' which governs our programming language.

Likewise, we need to restrict the system so that it becomes property irrelevant for
the propositions appearing in subset types. Indeed, in \PVS{} you can't
manipulate proof terms, so you have
no way to create a term of type $0 \neq 0$ from the judgment $0 :
\mysubset{x}{`N}{P}$, but in a classical Calculus of Constructions with
sigma types or inductive types, the subset type is a first class object
defined with proper introduction and
elimination terms (figure \vref{fig:cci-subset}). What we need to do is forbid the use of these terms
in \Russell{} terms, leaving only the type former.

\begin{figure}
  \begin{center}
    \def\type{\typed}
    \AXC{$`G \type A : \Set$}
    \AXC{$`G, x : A \type P : \Prop$}
    \BIC{$`G \type \mysubset{x}{A}{P} : \Set$}
    \DP
    
    \vspace{\infvspace}
    
    \AXC{$`G \type a : A$}
    \AXC{$`G \type p : P[a/x]$}
    \BIC{$`G \type \elt{A}{(\lambda x : A.P)}{a}{p} : \mysubset{x}{A}{P}$}
    \DP
    \vspace{\infvspace}

    \AXC{$`G \type t : \mysubset{x}{A}{P}$}
    \UIC{$`G \type \text{proj1\_sig}~t : A$}
    \DP
    \vspace{\infvspace}

    \AXC{$`G \type t : \mysubset{x}{A}{P}$}
    \UIC{$`G \type \text{proj2\_sig}~t : P[\text{proj1\_sig}~t/x]$}
    \DP
  \end{center}
  \vspace{-1em}
  \caption{Subset type in \CCI}
  \label{fig:cci-subset}
  \vspace{-2.5em}
\end{figure}

We now need to change the conversion rule to a stronger one which will
include our subset equivalence.

\subsubsection{Equivalence}
We have renamed the technique from \ps{} to 
\emph{subset equivalence} because we have a symmetric relation, contrary
to usual subtyping relations. It also conveys the idea that it can
include the usual $\beta\pi$-conversion directly in the judgement, 
although it may not be possible if we have cummulative universes.
The judgment $`G \typed T \subd{} U : s$ (figure
\vref{fig:conversion-decl-rules}) reads $T$ is equivalent to $U$ in
environment $`G$, both being sorted by $s$. 

\begin{figure}[h]
  \subtdRules
  \caption{\Russell{} conversion}
  \label{fig:conversion-decl-rules}
\end{figure}

The rule \irule{SubConv} integrates $\beta\pi$-conversion in the
judgment. We use a judgemental equality here, which will be refined by
the usual conversion relation later. The \irule{SubSym} and
\irule{SubTrans} rules ensure that our judgement constructs an \emph{equivalence} and has
proper modularity. The next two rules do context closure for dependent
products and sums. It is remarkable that we use contravariance
\cite{journals/toplas/Castagna95} for
domains in the \irule{SubProd} rule, not restricting to invariance as in
\PVS. It is accessory here, as we could have used \emph{co}variance and
still get the same judgements because we have symetry. However, it will
become important when we create coercions (see
\vref{fig:subtyping-impl-rules}).

The really interesting rules are \irule{SubSub} and
\irule{SubProof}. The first one allows to use an object of a subset type
as an object of its support type. The later allows (maybe abusively) to
consider an object of any type as an object of any subset based on
this type. We must check that the property $P$ is well-formed, but
we do not care about its provability.

\subsubsection{Properties}
We have proved the metatheory for this system in \Coq{}
\cite{sozeau:coq/Russell/meta}. We have assumed that it is strongly
normalizing (SN) but we have proved subject reduction (SR) for it: 
if $`G \typed t : T$ and $t "->"_{\beta\pi} t'$ then $`G \typed t' :
T$. Gang Chen \cite{ChenPhD} has studied various type systems from the
$\lambda$-cube extended by subtyping or coercive subtyping
\cite{DBLP:conf/csl/Luo96}, including the Calculus of Constructions, and
proved such results as SN and SR for them. It requires a very careful
analysis of the system to avoid cycles in the proof due to the presence
of dependent types and conversion. However we prefered to adapt the method of
Robin Adams \cite{adams:PTSEQ} to prove SR, because Gang Chen's method
seemed very tied to the peculiarities of the system he studied. 
Strong normalization could also be proved, perhaps more easily,
using the generic proof method developed in \cite{geuvers95}, by finding
a proper interpretation of \Russell terms into the Calculus of
Constructions.

So, apart from strong normalization, we have shown all the usual structural
and metatheoretic properties of a dependent programming language, like
weakening, thinning and substitution, stability by context coercion etc\ldots
We stop here on the subject of theoretical properties of this first system, as
it gives no new insights for our purpose and we will focus more on the
algorithmic system's properties. Besides, the details of the
formalization and the proof fall outside the scope of this paper.
% The essential properties of the $\subd$ judgement are 
% its reflexivity: if $`G \typed A : s$, then $`G \typed A \subd A$,
% symetry: if $`G \typed A, B : s$ then $`G \typed A \subd B "<=>" `G \typed
% B \subd A$ and transitivity by \irule{SubTrans}.

% As typing and equivalence are mutually recursive, we will generaly prove
% properties by mutual induction on the two derivations.

% \begin{lemma}[Weakening]
%   Suppose $\wf{`G, x : S, `D}$.
%   If $`G, `D \typed t : T$ then $`G, x : S, `D \typed t : T$. 
%   If $`G, `D \typed T \sub U : s$ then $`G, x : S, `D \typed T \sub U : s$.
% \end{lemma}
% \begin{proof}
%   Straightforward mutual induction.
% \end{proof}

% Similarly for thining and substitution. An important property for
% dependent type systems is to have invariance of judgments which are
% definitionaly equal (here equivalent). Hence the following lemma:
% \begin{lemma}
%   Suppose $`G \typed U \sub V : s$.
%   If $`G, x : V, `D \typed t : T$ then $`G, x : U, `D \typed t : T$.
%   If $`G, x : V, `D \typed S \sub T : s'$ then
%   $`G, x : U, `D \typed S \sub T : s'$.
% \end{lemma}
% \begin{proof}
%   By mutual induction on the typing and equivalence derivations.
% \end{proof}

\subsubsection{Algorithmic typing}

\begin{paragraph}{}
We use a standard transformation to get an algorithm from our typing
rules, integrating the conversion (or subsumption) rule
(here \irule{Coerce}) to the premises of the other rules.
We recall that $`G \type t : s$ is shorthand for $`G \type t : T$ and
$T  `= s$ with $s `: \PTSsorts$ in a algorithmic presentation.
\TODO{App?, SumDep?, Pi?}. Our algorithmic judgement $`G \typea t : T$
(figure \vref{fig:typing-algo-rules})
reads: $t$ is a well-typed term of type $T$ in environment $`G$.
We need to introduce the notion of support for subset types in order to
define our algorithmic system. Indeed, when typing an application, 
we need to ensure that the object we apply can be seen as an object of a
product type modulo the equivalence. This notion is presented in \PVS{} by
means of a $\mu_0$ operator which was readily adaptable in our setting
\ref{fig:mualgo}. In Gang Chen's work, the notion is formalized by a
new judgement $\Pi_{lub}$ which is essentialy equivalent to the operator.
\begin{figure*}[t]
  \def\infvspace{0.5em}
    \def\type{\typea}
    \def\subt{\subta}
    \def\sub{\suba}
    \def\fCenter{\typea}
    \begin{center}
%     \WfEmpty\DP
    
%     \vspace{\infvspace}
%     \WfVar\DP
    
%     \vspace{\infvspace}
%     \Var\DP
    
%     \vspace{\infvspace}
%     \PropSet\DP
    
%     \vspace{\infvspace}
%     \Prod\DP

%     \vspace{\infvspace}
%     \Abs\DP

    \vspace{\infvspace}
    \AppA\DP

%     \vspace{\infvspace}
%     \SigmaR\DP
    
    \vspace{\infvspace}
    \SumDepA\DP

    \vspace{\infvspace}
    \PiLeftA\DP
    
    \vspace{\infvspace}
    \PiRightA\DP

%     \vspace{\infvspace}
%     \SubsetR\DP
  \end{center}
  \vspace{-2em}
  \caption{\Russell{} algorithmic typing, new rules}
  \label{fig:typing-algo-rules}
%  \vspace{-1em}
\end{figure*}

\begin{figure*}
    \def\fCenter{\suba}
    \def\type{\typea}
    \def\sub{\suba}
    \begin{center}
    \SubConvA\DP 

    \vspace{\infvspace}
    \SubHnfA\DP

    \vspace{\infvspace}
    \SubProdA\DP

    \vspace{\infvspace}
    \SubSigmaA\DP

    \vspace{\infvspace}
    \SubProofA\DP

    \vspace{\infvspace}
    \SubSubAs\DP
  \end{center}
  \vspace{-2em}
  \caption{\Russell{} algorithmic equivalence}
  \label{fig:subtyping-algo-rules}
  \vspace{-1em}
\end{figure*}


\end{paragraph}
\begin{paragraph}{}
  The next thing to do is to construct a decidable judgement for
  equivalence given two types. We denote it by $`G \typea T
  \suba U : s$ (figure \ref{fig:subtyping-algo-rules}).
  In our case, we have to check that conversion is decidable, which is the
  case. We also need to eliminate the transitivity rule which is not
  syntax-directed. That is the purpose of the following theorem:
\begin{theorem}[Elimination of transitivity]
  If $`G \typea T \suba U : s$ and $`G \typea U \suba V : s$, then $`G \typea T
  \suba V : s$.
\end{theorem}
\begin{proof}
  By induction on the sum of the depths of the two derivations.
  \TODO{example?}
\end{proof}
\end{paragraph}

Classicaly, we have the following correspondence between the two
systems:
\begin{theorem}[Soundness]
  If $`G \typea t : T$ then $`G \typed t : T$.
  If $`G \typea T \suba{} U : s$ then $`G \typed T \subd U : s$.
\end{theorem}

\begin{theorem}[Completeness]
  If $`G \typed t : T$ then $`G \typea t : T' \suba T$.
  If $`G \typed T \subd U : s$ then $`G \typea T \suba U : s$.
\end{theorem}

Finaly, we can state the desired property of the algorithmic system:
\begin{theorem}[Decidability of typing and equivalence]
  $`A `G~t, `E T, `G \typea t : T$ and $`A `G~T~U~s, `G \typea T \suba U :
  s$ are decidable problems.
\end{theorem}

\subsection{From \CC to \lng{}}
We have presented a calculus based on \CC with a stronger equivalence
but with restricted typing rules. We will now see how they relate
formally.
We can build a forgetful map from terms of \CCI to \Russell
(interpreting inductives as constants). It bears
relation to the $`e$ extraction function defined in
\cite{Werner:ProofIrrelevance}. Essentially, \Russell{} terms do not
contain or manipulate logical information attached to objects of subset
types, hence we must forget about it when translating.

We define the forgetful map $()^{\circ}$ as an homomorphism on terms
except for the following cases:
\begin{center}
  \CCtoRussellforgetFig
\end{center}

We can now prove the following:
\begin{theorem}[Forgetful map correctness]
  If $`G \typec t : T$ then $`G^{\circ} \typea t^{\circ} : T^{\circ}$ if $()^{\circ}$ is
  defined on $`G, t$ and $T$.
\end{theorem}

Practically, this means we can use almost any existing definition in the
\Coq environment, potentially turning them (locally) to an opaque form
if their body is not traductible. Obviously, this map is involutive and
the identity on \Russell terms. 

\section{From \lng{} to \CCq{}}
We will now build an interpretation
$\ip{t}{`G}$ of \Russell terms $t$ in environment $`G$ into \CCI
terms. We will check at the end that it respects the $()^{\circ}$ operator
in the sense that if $t$ is well-typed in $`G$ then $\ip{t}{`G}^{\circ} = t$.

Our interpretation will build a full-fledged \CCI term from its
algorithmic skeleton and a rich type written in \Russell. Obviously, we
cannot infer proof terms where they are needed in \CCI, but we can build
a \emph{partial} term, leaving typed holes where proofs are
needed. Hence we add a rule to build existential variables (or
metavariables) in the target calculus ($\typeq$ denotes the new system's typing judgement):
\begin{prooftree}
  \UAX{}
  {$`G \typeq P : \Prop$}
  {$`G \typeq ?_{P} : P$}
  {}
\end{prooftree}

We restrict it to objects of type $\Prop$ because we consider that the
informative part of the algorithm has been entirely given in the
original term. 

Now we can build a total interpretation:
\begin{proposition}[Interpretation correctness]
  If $`G \typea t : T$ then $\ipG{`G} \typeq \ip{t}{`G} : \ip{T}{`G}$.
\end{proposition}

The proof of this proposition is the main technical contribution of this
paper. It also represented the main difficulty in our work. 
The remainder of this section is organized as follows: first we will
define the explicit coercion derivation algorithm which will permit to
put proof obligations in the terms, then we will define the
interpretation of terms which is mutually recursive with the precedent
algorithm. Finaly we will present a proof sketch of the aforementionned
proposition.

\subsection{Explicit coercions}
The algorithm which derives explicit coercions is based on the
algorithmic equivalence derivations. 

\subsection{Terms}
- Follows algo typing derivation. Done at the same time as typing in the
impl.

\subsection{Properties}
- Proofs.

\section{Conclusion}
\subsection{Related work}

\subsection{Further work}

\bibliography{bib-joehurd,barras,pvs-bib,bcp,Luo,biblio-subset,%
cparent,demons,demons2,demons3}
\bibliographystyle{splncs}

\renewcommand{\thefootnote}{}
\footnotetext{This article was typeset in \LaTeX~using the
  \texttt{Concrete Math} font}
\end{document}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% LaTeX-command: "BIBINPUTS=\"${HOME}/research/demons-biblio:../bib:$BIBINPUTS\" TEXINPUTS=\"..:../style:$TEXINPUTS\" latex"
%%% End: 
